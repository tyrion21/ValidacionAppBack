
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model capacidad_lineas
 * 
 */
export type capacidad_lineas = $Result.DefaultSelection<Prisma.$capacidad_lineasPayload>
/**
 * Model cc_checklist
 * 
 */
export type cc_checklist = $Result.DefaultSelection<Prisma.$cc_checklistPayload>
/**
 * Model certificacion
 * 
 */
export type certificacion = $Result.DefaultSelection<Prisma.$certificacionPayload>
/**
 * Model correlativo
 * 
 */
export type correlativo = $Result.DefaultSelection<Prisma.$correlativoPayload>
/**
 * Model env_x_sellar
 * 
 */
export type env_x_sellar = $Result.DefaultSelection<Prisma.$env_x_sellarPayload>
/**
 * Model estados
 * 
 */
export type estados = $Result.DefaultSelection<Prisma.$estadosPayload>
/**
 * Model folios
 * 
 */
export type folios = $Result.DefaultSelection<Prisma.$foliosPayload>
/**
 * Model folios_frio
 * 
 */
export type folios_frio = $Result.DefaultSelection<Prisma.$folios_frioPayload>
/**
 * Model folios_pack
 * 
 */
export type folios_pack = $Result.DefaultSelection<Prisma.$folios_packPayload>
/**
 * Model folios_se
 * 
 */
export type folios_se = $Result.DefaultSelection<Prisma.$folios_sePayload>
/**
 * Model fr_repa_cab
 * 
 */
export type fr_repa_cab = $Result.DefaultSelection<Prisma.$fr_repa_cabPayload>
/**
 * Model fr_repa_det
 * 
 */
export type fr_repa_det = $Result.DefaultSelection<Prisma.$fr_repa_detPayload>
/**
 * Model Gr_Tipo_Cobro
 * 
 */
export type Gr_Tipo_Cobro = $Result.DefaultSelection<Prisma.$Gr_Tipo_CobroPayload>
/**
 * Model insp_cab
 * 
 */
export type insp_cab = $Result.DefaultSelection<Prisma.$insp_cabPayload>
/**
 * Model mae_sta_elena
 * 
 */
export type mae_sta_elena = $Result.DefaultSelection<Prisma.$mae_sta_elenaPayload>
/**
 * Model maestro_plu
 * 
 */
export type maestro_plu = $Result.DefaultSelection<Prisma.$maestro_pluPayload>
/**
 * Model pk_desver_cab
 * 
 */
export type pk_desver_cab = $Result.DefaultSelection<Prisma.$pk_desver_cabPayload>
/**
 * Model pk_desver_det
 * 
 */
export type pk_desver_det = $Result.DefaultSelection<Prisma.$pk_desver_detPayload>
/**
 * Model sys_log
 * 
 */
export type sys_log = $Result.DefaultSelection<Prisma.$sys_logPayload>
/**
 * Model sysdiagrams
 * 
 */
export type sysdiagrams = $Result.DefaultSelection<Prisma.$sysdiagramsPayload>
/**
 * Model tipo_ins
 * 
 */
export type tipo_ins = $Result.DefaultSelection<Prisma.$tipo_insPayload>
/**
 * Model traductor_calibre
 * 
 */
export type traductor_calibre = $Result.DefaultSelection<Prisma.$traductor_calibrePayload>
/**
 * Model validacion_pallets
 * 
 */
export type validacion_pallets = $Result.DefaultSelection<Prisma.$validacion_palletsPayload>
/**
 * Model existencias_cajas
 * 
 */
export type existencias_cajas = $Result.DefaultSelection<Prisma.$existencias_cajasPayload>
/**
 * Model existenciamix_cajas
 * 
 */
export type existenciamix_cajas = $Result.DefaultSelection<Prisma.$existenciamix_cajasPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Capacidad_lineas
 * const capacidad_lineas = await prisma.capacidad_lineas.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Capacidad_lineas
   * const capacidad_lineas = await prisma.capacidad_lineas.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.capacidad_lineas`: Exposes CRUD operations for the **capacidad_lineas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Capacidad_lineas
    * const capacidad_lineas = await prisma.capacidad_lineas.findMany()
    * ```
    */
  get capacidad_lineas(): Prisma.capacidad_lineasDelegate<ExtArgs>;

  /**
   * `prisma.cc_checklist`: Exposes CRUD operations for the **cc_checklist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cc_checklists
    * const cc_checklists = await prisma.cc_checklist.findMany()
    * ```
    */
  get cc_checklist(): Prisma.cc_checklistDelegate<ExtArgs>;

  /**
   * `prisma.certificacion`: Exposes CRUD operations for the **certificacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificacions
    * const certificacions = await prisma.certificacion.findMany()
    * ```
    */
  get certificacion(): Prisma.certificacionDelegate<ExtArgs>;

  /**
   * `prisma.correlativo`: Exposes CRUD operations for the **correlativo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Correlativos
    * const correlativos = await prisma.correlativo.findMany()
    * ```
    */
  get correlativo(): Prisma.correlativoDelegate<ExtArgs>;

  /**
   * `prisma.env_x_sellar`: Exposes CRUD operations for the **env_x_sellar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Env_x_sellars
    * const env_x_sellars = await prisma.env_x_sellar.findMany()
    * ```
    */
  get env_x_sellar(): Prisma.env_x_sellarDelegate<ExtArgs>;

  /**
   * `prisma.estados`: Exposes CRUD operations for the **estados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estados
    * const estados = await prisma.estados.findMany()
    * ```
    */
  get estados(): Prisma.estadosDelegate<ExtArgs>;

  /**
   * `prisma.folios`: Exposes CRUD operations for the **folios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Folios
    * const folios = await prisma.folios.findMany()
    * ```
    */
  get folios(): Prisma.foliosDelegate<ExtArgs>;

  /**
   * `prisma.folios_frio`: Exposes CRUD operations for the **folios_frio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Folios_frios
    * const folios_frios = await prisma.folios_frio.findMany()
    * ```
    */
  get folios_frio(): Prisma.folios_frioDelegate<ExtArgs>;

  /**
   * `prisma.folios_pack`: Exposes CRUD operations for the **folios_pack** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Folios_packs
    * const folios_packs = await prisma.folios_pack.findMany()
    * ```
    */
  get folios_pack(): Prisma.folios_packDelegate<ExtArgs>;

  /**
   * `prisma.folios_se`: Exposes CRUD operations for the **folios_se** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Folios_ses
    * const folios_ses = await prisma.folios_se.findMany()
    * ```
    */
  get folios_se(): Prisma.folios_seDelegate<ExtArgs>;

  /**
   * `prisma.fr_repa_cab`: Exposes CRUD operations for the **fr_repa_cab** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fr_repa_cabs
    * const fr_repa_cabs = await prisma.fr_repa_cab.findMany()
    * ```
    */
  get fr_repa_cab(): Prisma.fr_repa_cabDelegate<ExtArgs>;

  /**
   * `prisma.fr_repa_det`: Exposes CRUD operations for the **fr_repa_det** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fr_repa_dets
    * const fr_repa_dets = await prisma.fr_repa_det.findMany()
    * ```
    */
  get fr_repa_det(): Prisma.fr_repa_detDelegate<ExtArgs>;

  /**
   * `prisma.gr_Tipo_Cobro`: Exposes CRUD operations for the **Gr_Tipo_Cobro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gr_Tipo_Cobros
    * const gr_Tipo_Cobros = await prisma.gr_Tipo_Cobro.findMany()
    * ```
    */
  get gr_Tipo_Cobro(): Prisma.Gr_Tipo_CobroDelegate<ExtArgs>;

  /**
   * `prisma.insp_cab`: Exposes CRUD operations for the **insp_cab** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Insp_cabs
    * const insp_cabs = await prisma.insp_cab.findMany()
    * ```
    */
  get insp_cab(): Prisma.insp_cabDelegate<ExtArgs>;

  /**
   * `prisma.mae_sta_elena`: Exposes CRUD operations for the **mae_sta_elena** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mae_sta_elenas
    * const mae_sta_elenas = await prisma.mae_sta_elena.findMany()
    * ```
    */
  get mae_sta_elena(): Prisma.mae_sta_elenaDelegate<ExtArgs>;

  /**
   * `prisma.maestro_plu`: Exposes CRUD operations for the **maestro_plu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maestro_plus
    * const maestro_plus = await prisma.maestro_plu.findMany()
    * ```
    */
  get maestro_plu(): Prisma.maestro_pluDelegate<ExtArgs>;

  /**
   * `prisma.pk_desver_cab`: Exposes CRUD operations for the **pk_desver_cab** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pk_desver_cabs
    * const pk_desver_cabs = await prisma.pk_desver_cab.findMany()
    * ```
    */
  get pk_desver_cab(): Prisma.pk_desver_cabDelegate<ExtArgs>;

  /**
   * `prisma.pk_desver_det`: Exposes CRUD operations for the **pk_desver_det** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pk_desver_dets
    * const pk_desver_dets = await prisma.pk_desver_det.findMany()
    * ```
    */
  get pk_desver_det(): Prisma.pk_desver_detDelegate<ExtArgs>;

  /**
   * `prisma.sys_log`: Exposes CRUD operations for the **sys_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sys_logs
    * const sys_logs = await prisma.sys_log.findMany()
    * ```
    */
  get sys_log(): Prisma.sys_logDelegate<ExtArgs>;

  /**
   * `prisma.sysdiagrams`: Exposes CRUD operations for the **sysdiagrams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sysdiagrams
    * const sysdiagrams = await prisma.sysdiagrams.findMany()
    * ```
    */
  get sysdiagrams(): Prisma.sysdiagramsDelegate<ExtArgs>;

  /**
   * `prisma.tipo_ins`: Exposes CRUD operations for the **tipo_ins** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipo_ins
    * const tipo_ins = await prisma.tipo_ins.findMany()
    * ```
    */
  get tipo_ins(): Prisma.tipo_insDelegate<ExtArgs>;

  /**
   * `prisma.traductor_calibre`: Exposes CRUD operations for the **traductor_calibre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Traductor_calibres
    * const traductor_calibres = await prisma.traductor_calibre.findMany()
    * ```
    */
  get traductor_calibre(): Prisma.traductor_calibreDelegate<ExtArgs>;

  /**
   * `prisma.validacion_pallets`: Exposes CRUD operations for the **validacion_pallets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Validacion_pallets
    * const validacion_pallets = await prisma.validacion_pallets.findMany()
    * ```
    */
  get validacion_pallets(): Prisma.validacion_palletsDelegate<ExtArgs>;

  /**
   * `prisma.existencias_cajas`: Exposes CRUD operations for the **existencias_cajas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Existencias_cajas
    * const existencias_cajas = await prisma.existencias_cajas.findMany()
    * ```
    */
  get existencias_cajas(): Prisma.existencias_cajasDelegate<ExtArgs>;

  /**
   * `prisma.existenciamix_cajas`: Exposes CRUD operations for the **existenciamix_cajas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Existenciamix_cajas
    * const existenciamix_cajas = await prisma.existenciamix_cajas.findMany()
    * ```
    */
  get existenciamix_cajas(): Prisma.existenciamix_cajasDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    capacidad_lineas: 'capacidad_lineas',
    cc_checklist: 'cc_checklist',
    certificacion: 'certificacion',
    correlativo: 'correlativo',
    env_x_sellar: 'env_x_sellar',
    estados: 'estados',
    folios: 'folios',
    folios_frio: 'folios_frio',
    folios_pack: 'folios_pack',
    folios_se: 'folios_se',
    fr_repa_cab: 'fr_repa_cab',
    fr_repa_det: 'fr_repa_det',
    Gr_Tipo_Cobro: 'Gr_Tipo_Cobro',
    insp_cab: 'insp_cab',
    mae_sta_elena: 'mae_sta_elena',
    maestro_plu: 'maestro_plu',
    pk_desver_cab: 'pk_desver_cab',
    pk_desver_det: 'pk_desver_det',
    sys_log: 'sys_log',
    sysdiagrams: 'sysdiagrams',
    tipo_ins: 'tipo_ins',
    traductor_calibre: 'traductor_calibre',
    validacion_pallets: 'validacion_pallets',
    existencias_cajas: 'existencias_cajas',
    existenciamix_cajas: 'existenciamix_cajas'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "capacidad_lineas" | "cc_checklist" | "certificacion" | "correlativo" | "env_x_sellar" | "estados" | "folios" | "folios_frio" | "folios_pack" | "folios_se" | "fr_repa_cab" | "fr_repa_det" | "gr_Tipo_Cobro" | "insp_cab" | "mae_sta_elena" | "maestro_plu" | "pk_desver_cab" | "pk_desver_det" | "sys_log" | "sysdiagrams" | "tipo_ins" | "traductor_calibre" | "validacion_pallets" | "existencias_cajas" | "existenciamix_cajas"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      capacidad_lineas: {
        payload: Prisma.$capacidad_lineasPayload<ExtArgs>
        fields: Prisma.capacidad_lineasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.capacidad_lineasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacidad_lineasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.capacidad_lineasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacidad_lineasPayload>
          }
          findFirst: {
            args: Prisma.capacidad_lineasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacidad_lineasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.capacidad_lineasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacidad_lineasPayload>
          }
          findMany: {
            args: Prisma.capacidad_lineasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacidad_lineasPayload>[]
          }
          create: {
            args: Prisma.capacidad_lineasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacidad_lineasPayload>
          }
          createMany: {
            args: Prisma.capacidad_lineasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.capacidad_lineasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacidad_lineasPayload>
          }
          update: {
            args: Prisma.capacidad_lineasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacidad_lineasPayload>
          }
          deleteMany: {
            args: Prisma.capacidad_lineasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.capacidad_lineasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.capacidad_lineasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capacidad_lineasPayload>
          }
          aggregate: {
            args: Prisma.Capacidad_lineasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCapacidad_lineas>
          }
          groupBy: {
            args: Prisma.capacidad_lineasGroupByArgs<ExtArgs>
            result: $Utils.Optional<Capacidad_lineasGroupByOutputType>[]
          }
          count: {
            args: Prisma.capacidad_lineasCountArgs<ExtArgs>
            result: $Utils.Optional<Capacidad_lineasCountAggregateOutputType> | number
          }
        }
      }
      cc_checklist: {
        payload: Prisma.$cc_checklistPayload<ExtArgs>
        fields: Prisma.cc_checklistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cc_checklistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cc_checklistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cc_checklistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cc_checklistPayload>
          }
          findFirst: {
            args: Prisma.cc_checklistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cc_checklistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cc_checklistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cc_checklistPayload>
          }
          findMany: {
            args: Prisma.cc_checklistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cc_checklistPayload>[]
          }
          create: {
            args: Prisma.cc_checklistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cc_checklistPayload>
          }
          createMany: {
            args: Prisma.cc_checklistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cc_checklistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cc_checklistPayload>
          }
          update: {
            args: Prisma.cc_checklistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cc_checklistPayload>
          }
          deleteMany: {
            args: Prisma.cc_checklistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cc_checklistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cc_checklistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cc_checklistPayload>
          }
          aggregate: {
            args: Prisma.Cc_checklistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCc_checklist>
          }
          groupBy: {
            args: Prisma.cc_checklistGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cc_checklistGroupByOutputType>[]
          }
          count: {
            args: Prisma.cc_checklistCountArgs<ExtArgs>
            result: $Utils.Optional<Cc_checklistCountAggregateOutputType> | number
          }
        }
      }
      certificacion: {
        payload: Prisma.$certificacionPayload<ExtArgs>
        fields: Prisma.certificacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.certificacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.certificacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificacionPayload>
          }
          findFirst: {
            args: Prisma.certificacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.certificacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificacionPayload>
          }
          findMany: {
            args: Prisma.certificacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificacionPayload>[]
          }
          create: {
            args: Prisma.certificacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificacionPayload>
          }
          createMany: {
            args: Prisma.certificacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.certificacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificacionPayload>
          }
          update: {
            args: Prisma.certificacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificacionPayload>
          }
          deleteMany: {
            args: Prisma.certificacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.certificacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.certificacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificacionPayload>
          }
          aggregate: {
            args: Prisma.CertificacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificacion>
          }
          groupBy: {
            args: Prisma.certificacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.certificacionCountArgs<ExtArgs>
            result: $Utils.Optional<CertificacionCountAggregateOutputType> | number
          }
        }
      }
      correlativo: {
        payload: Prisma.$correlativoPayload<ExtArgs>
        fields: Prisma.correlativoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.correlativoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$correlativoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.correlativoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$correlativoPayload>
          }
          findFirst: {
            args: Prisma.correlativoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$correlativoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.correlativoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$correlativoPayload>
          }
          findMany: {
            args: Prisma.correlativoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$correlativoPayload>[]
          }
          create: {
            args: Prisma.correlativoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$correlativoPayload>
          }
          createMany: {
            args: Prisma.correlativoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.correlativoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$correlativoPayload>
          }
          update: {
            args: Prisma.correlativoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$correlativoPayload>
          }
          deleteMany: {
            args: Prisma.correlativoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.correlativoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.correlativoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$correlativoPayload>
          }
          aggregate: {
            args: Prisma.CorrelativoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCorrelativo>
          }
          groupBy: {
            args: Prisma.correlativoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CorrelativoGroupByOutputType>[]
          }
          count: {
            args: Prisma.correlativoCountArgs<ExtArgs>
            result: $Utils.Optional<CorrelativoCountAggregateOutputType> | number
          }
        }
      }
      env_x_sellar: {
        payload: Prisma.$env_x_sellarPayload<ExtArgs>
        fields: Prisma.env_x_sellarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.env_x_sellarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_x_sellarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.env_x_sellarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_x_sellarPayload>
          }
          findFirst: {
            args: Prisma.env_x_sellarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_x_sellarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.env_x_sellarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_x_sellarPayload>
          }
          findMany: {
            args: Prisma.env_x_sellarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_x_sellarPayload>[]
          }
          create: {
            args: Prisma.env_x_sellarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_x_sellarPayload>
          }
          createMany: {
            args: Prisma.env_x_sellarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.env_x_sellarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_x_sellarPayload>
          }
          update: {
            args: Prisma.env_x_sellarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_x_sellarPayload>
          }
          deleteMany: {
            args: Prisma.env_x_sellarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.env_x_sellarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.env_x_sellarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_x_sellarPayload>
          }
          aggregate: {
            args: Prisma.Env_x_sellarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnv_x_sellar>
          }
          groupBy: {
            args: Prisma.env_x_sellarGroupByArgs<ExtArgs>
            result: $Utils.Optional<Env_x_sellarGroupByOutputType>[]
          }
          count: {
            args: Prisma.env_x_sellarCountArgs<ExtArgs>
            result: $Utils.Optional<Env_x_sellarCountAggregateOutputType> | number
          }
        }
      }
      estados: {
        payload: Prisma.$estadosPayload<ExtArgs>
        fields: Prisma.estadosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.estadosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.estadosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadosPayload>
          }
          findFirst: {
            args: Prisma.estadosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.estadosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadosPayload>
          }
          findMany: {
            args: Prisma.estadosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadosPayload>[]
          }
          create: {
            args: Prisma.estadosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadosPayload>
          }
          createMany: {
            args: Prisma.estadosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.estadosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadosPayload>
          }
          update: {
            args: Prisma.estadosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadosPayload>
          }
          deleteMany: {
            args: Prisma.estadosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.estadosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.estadosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadosPayload>
          }
          aggregate: {
            args: Prisma.EstadosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstados>
          }
          groupBy: {
            args: Prisma.estadosGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstadosGroupByOutputType>[]
          }
          count: {
            args: Prisma.estadosCountArgs<ExtArgs>
            result: $Utils.Optional<EstadosCountAggregateOutputType> | number
          }
        }
      }
      folios: {
        payload: Prisma.$foliosPayload<ExtArgs>
        fields: Prisma.foliosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.foliosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$foliosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.foliosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$foliosPayload>
          }
          findFirst: {
            args: Prisma.foliosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$foliosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.foliosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$foliosPayload>
          }
          findMany: {
            args: Prisma.foliosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$foliosPayload>[]
          }
          create: {
            args: Prisma.foliosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$foliosPayload>
          }
          createMany: {
            args: Prisma.foliosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.foliosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$foliosPayload>
          }
          update: {
            args: Prisma.foliosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$foliosPayload>
          }
          deleteMany: {
            args: Prisma.foliosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.foliosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.foliosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$foliosPayload>
          }
          aggregate: {
            args: Prisma.FoliosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFolios>
          }
          groupBy: {
            args: Prisma.foliosGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoliosGroupByOutputType>[]
          }
          count: {
            args: Prisma.foliosCountArgs<ExtArgs>
            result: $Utils.Optional<FoliosCountAggregateOutputType> | number
          }
        }
      }
      folios_frio: {
        payload: Prisma.$folios_frioPayload<ExtArgs>
        fields: Prisma.folios_frioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.folios_frioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_frioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.folios_frioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_frioPayload>
          }
          findFirst: {
            args: Prisma.folios_frioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_frioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.folios_frioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_frioPayload>
          }
          findMany: {
            args: Prisma.folios_frioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_frioPayload>[]
          }
          create: {
            args: Prisma.folios_frioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_frioPayload>
          }
          createMany: {
            args: Prisma.folios_frioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.folios_frioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_frioPayload>
          }
          update: {
            args: Prisma.folios_frioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_frioPayload>
          }
          deleteMany: {
            args: Prisma.folios_frioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.folios_frioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.folios_frioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_frioPayload>
          }
          aggregate: {
            args: Prisma.Folios_frioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFolios_frio>
          }
          groupBy: {
            args: Prisma.folios_frioGroupByArgs<ExtArgs>
            result: $Utils.Optional<Folios_frioGroupByOutputType>[]
          }
          count: {
            args: Prisma.folios_frioCountArgs<ExtArgs>
            result: $Utils.Optional<Folios_frioCountAggregateOutputType> | number
          }
        }
      }
      folios_pack: {
        payload: Prisma.$folios_packPayload<ExtArgs>
        fields: Prisma.folios_packFieldRefs
        operations: {
          findUnique: {
            args: Prisma.folios_packFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_packPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.folios_packFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_packPayload>
          }
          findFirst: {
            args: Prisma.folios_packFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_packPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.folios_packFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_packPayload>
          }
          findMany: {
            args: Prisma.folios_packFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_packPayload>[]
          }
          create: {
            args: Prisma.folios_packCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_packPayload>
          }
          createMany: {
            args: Prisma.folios_packCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.folios_packDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_packPayload>
          }
          update: {
            args: Prisma.folios_packUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_packPayload>
          }
          deleteMany: {
            args: Prisma.folios_packDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.folios_packUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.folios_packUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_packPayload>
          }
          aggregate: {
            args: Prisma.Folios_packAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFolios_pack>
          }
          groupBy: {
            args: Prisma.folios_packGroupByArgs<ExtArgs>
            result: $Utils.Optional<Folios_packGroupByOutputType>[]
          }
          count: {
            args: Prisma.folios_packCountArgs<ExtArgs>
            result: $Utils.Optional<Folios_packCountAggregateOutputType> | number
          }
        }
      }
      folios_se: {
        payload: Prisma.$folios_sePayload<ExtArgs>
        fields: Prisma.folios_seFieldRefs
        operations: {
          findUnique: {
            args: Prisma.folios_seFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_sePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.folios_seFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_sePayload>
          }
          findFirst: {
            args: Prisma.folios_seFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_sePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.folios_seFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_sePayload>
          }
          findMany: {
            args: Prisma.folios_seFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_sePayload>[]
          }
          create: {
            args: Prisma.folios_seCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_sePayload>
          }
          createMany: {
            args: Prisma.folios_seCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.folios_seDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_sePayload>
          }
          update: {
            args: Prisma.folios_seUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_sePayload>
          }
          deleteMany: {
            args: Prisma.folios_seDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.folios_seUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.folios_seUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$folios_sePayload>
          }
          aggregate: {
            args: Prisma.Folios_seAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFolios_se>
          }
          groupBy: {
            args: Prisma.folios_seGroupByArgs<ExtArgs>
            result: $Utils.Optional<Folios_seGroupByOutputType>[]
          }
          count: {
            args: Prisma.folios_seCountArgs<ExtArgs>
            result: $Utils.Optional<Folios_seCountAggregateOutputType> | number
          }
        }
      }
      fr_repa_cab: {
        payload: Prisma.$fr_repa_cabPayload<ExtArgs>
        fields: Prisma.fr_repa_cabFieldRefs
        operations: {
          findUnique: {
            args: Prisma.fr_repa_cabFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fr_repa_cabPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fr_repa_cabFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fr_repa_cabPayload>
          }
          findFirst: {
            args: Prisma.fr_repa_cabFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fr_repa_cabPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fr_repa_cabFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fr_repa_cabPayload>
          }
          findMany: {
            args: Prisma.fr_repa_cabFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fr_repa_cabPayload>[]
          }
          create: {
            args: Prisma.fr_repa_cabCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fr_repa_cabPayload>
          }
          createMany: {
            args: Prisma.fr_repa_cabCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.fr_repa_cabDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fr_repa_cabPayload>
          }
          update: {
            args: Prisma.fr_repa_cabUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fr_repa_cabPayload>
          }
          deleteMany: {
            args: Prisma.fr_repa_cabDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.fr_repa_cabUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.fr_repa_cabUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fr_repa_cabPayload>
          }
          aggregate: {
            args: Prisma.Fr_repa_cabAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFr_repa_cab>
          }
          groupBy: {
            args: Prisma.fr_repa_cabGroupByArgs<ExtArgs>
            result: $Utils.Optional<Fr_repa_cabGroupByOutputType>[]
          }
          count: {
            args: Prisma.fr_repa_cabCountArgs<ExtArgs>
            result: $Utils.Optional<Fr_repa_cabCountAggregateOutputType> | number
          }
        }
      }
      fr_repa_det: {
        payload: Prisma.$fr_repa_detPayload<ExtArgs>
        fields: Prisma.fr_repa_detFieldRefs
        operations: {
          findUnique: {
            args: Prisma.fr_repa_detFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fr_repa_detPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fr_repa_detFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fr_repa_detPayload>
          }
          findFirst: {
            args: Prisma.fr_repa_detFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fr_repa_detPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fr_repa_detFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fr_repa_detPayload>
          }
          findMany: {
            args: Prisma.fr_repa_detFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fr_repa_detPayload>[]
          }
          create: {
            args: Prisma.fr_repa_detCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fr_repa_detPayload>
          }
          createMany: {
            args: Prisma.fr_repa_detCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.fr_repa_detDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fr_repa_detPayload>
          }
          update: {
            args: Prisma.fr_repa_detUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fr_repa_detPayload>
          }
          deleteMany: {
            args: Prisma.fr_repa_detDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.fr_repa_detUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.fr_repa_detUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fr_repa_detPayload>
          }
          aggregate: {
            args: Prisma.Fr_repa_detAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFr_repa_det>
          }
          groupBy: {
            args: Prisma.fr_repa_detGroupByArgs<ExtArgs>
            result: $Utils.Optional<Fr_repa_detGroupByOutputType>[]
          }
          count: {
            args: Prisma.fr_repa_detCountArgs<ExtArgs>
            result: $Utils.Optional<Fr_repa_detCountAggregateOutputType> | number
          }
        }
      }
      Gr_Tipo_Cobro: {
        payload: Prisma.$Gr_Tipo_CobroPayload<ExtArgs>
        fields: Prisma.Gr_Tipo_CobroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Gr_Tipo_CobroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gr_Tipo_CobroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Gr_Tipo_CobroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gr_Tipo_CobroPayload>
          }
          findFirst: {
            args: Prisma.Gr_Tipo_CobroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gr_Tipo_CobroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Gr_Tipo_CobroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gr_Tipo_CobroPayload>
          }
          findMany: {
            args: Prisma.Gr_Tipo_CobroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gr_Tipo_CobroPayload>[]
          }
          create: {
            args: Prisma.Gr_Tipo_CobroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gr_Tipo_CobroPayload>
          }
          createMany: {
            args: Prisma.Gr_Tipo_CobroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Gr_Tipo_CobroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gr_Tipo_CobroPayload>
          }
          update: {
            args: Prisma.Gr_Tipo_CobroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gr_Tipo_CobroPayload>
          }
          deleteMany: {
            args: Prisma.Gr_Tipo_CobroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Gr_Tipo_CobroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Gr_Tipo_CobroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gr_Tipo_CobroPayload>
          }
          aggregate: {
            args: Prisma.Gr_Tipo_CobroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGr_Tipo_Cobro>
          }
          groupBy: {
            args: Prisma.Gr_Tipo_CobroGroupByArgs<ExtArgs>
            result: $Utils.Optional<Gr_Tipo_CobroGroupByOutputType>[]
          }
          count: {
            args: Prisma.Gr_Tipo_CobroCountArgs<ExtArgs>
            result: $Utils.Optional<Gr_Tipo_CobroCountAggregateOutputType> | number
          }
        }
      }
      insp_cab: {
        payload: Prisma.$insp_cabPayload<ExtArgs>
        fields: Prisma.insp_cabFieldRefs
        operations: {
          findUnique: {
            args: Prisma.insp_cabFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$insp_cabPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.insp_cabFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$insp_cabPayload>
          }
          findFirst: {
            args: Prisma.insp_cabFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$insp_cabPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.insp_cabFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$insp_cabPayload>
          }
          findMany: {
            args: Prisma.insp_cabFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$insp_cabPayload>[]
          }
          create: {
            args: Prisma.insp_cabCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$insp_cabPayload>
          }
          createMany: {
            args: Prisma.insp_cabCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.insp_cabDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$insp_cabPayload>
          }
          update: {
            args: Prisma.insp_cabUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$insp_cabPayload>
          }
          deleteMany: {
            args: Prisma.insp_cabDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.insp_cabUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.insp_cabUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$insp_cabPayload>
          }
          aggregate: {
            args: Prisma.Insp_cabAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsp_cab>
          }
          groupBy: {
            args: Prisma.insp_cabGroupByArgs<ExtArgs>
            result: $Utils.Optional<Insp_cabGroupByOutputType>[]
          }
          count: {
            args: Prisma.insp_cabCountArgs<ExtArgs>
            result: $Utils.Optional<Insp_cabCountAggregateOutputType> | number
          }
        }
      }
      mae_sta_elena: {
        payload: Prisma.$mae_sta_elenaPayload<ExtArgs>
        fields: Prisma.mae_sta_elenaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mae_sta_elenaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mae_sta_elenaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mae_sta_elenaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mae_sta_elenaPayload>
          }
          findFirst: {
            args: Prisma.mae_sta_elenaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mae_sta_elenaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mae_sta_elenaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mae_sta_elenaPayload>
          }
          findMany: {
            args: Prisma.mae_sta_elenaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mae_sta_elenaPayload>[]
          }
          create: {
            args: Prisma.mae_sta_elenaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mae_sta_elenaPayload>
          }
          createMany: {
            args: Prisma.mae_sta_elenaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.mae_sta_elenaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mae_sta_elenaPayload>
          }
          update: {
            args: Prisma.mae_sta_elenaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mae_sta_elenaPayload>
          }
          deleteMany: {
            args: Prisma.mae_sta_elenaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mae_sta_elenaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.mae_sta_elenaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mae_sta_elenaPayload>
          }
          aggregate: {
            args: Prisma.Mae_sta_elenaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMae_sta_elena>
          }
          groupBy: {
            args: Prisma.mae_sta_elenaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Mae_sta_elenaGroupByOutputType>[]
          }
          count: {
            args: Prisma.mae_sta_elenaCountArgs<ExtArgs>
            result: $Utils.Optional<Mae_sta_elenaCountAggregateOutputType> | number
          }
        }
      }
      maestro_plu: {
        payload: Prisma.$maestro_pluPayload<ExtArgs>
        fields: Prisma.maestro_pluFieldRefs
        operations: {
          findUnique: {
            args: Prisma.maestro_pluFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maestro_pluPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.maestro_pluFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maestro_pluPayload>
          }
          findFirst: {
            args: Prisma.maestro_pluFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maestro_pluPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.maestro_pluFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maestro_pluPayload>
          }
          findMany: {
            args: Prisma.maestro_pluFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maestro_pluPayload>[]
          }
          create: {
            args: Prisma.maestro_pluCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maestro_pluPayload>
          }
          createMany: {
            args: Prisma.maestro_pluCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.maestro_pluDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maestro_pluPayload>
          }
          update: {
            args: Prisma.maestro_pluUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maestro_pluPayload>
          }
          deleteMany: {
            args: Prisma.maestro_pluDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.maestro_pluUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.maestro_pluUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maestro_pluPayload>
          }
          aggregate: {
            args: Prisma.Maestro_pluAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaestro_plu>
          }
          groupBy: {
            args: Prisma.maestro_pluGroupByArgs<ExtArgs>
            result: $Utils.Optional<Maestro_pluGroupByOutputType>[]
          }
          count: {
            args: Prisma.maestro_pluCountArgs<ExtArgs>
            result: $Utils.Optional<Maestro_pluCountAggregateOutputType> | number
          }
        }
      }
      pk_desver_cab: {
        payload: Prisma.$pk_desver_cabPayload<ExtArgs>
        fields: Prisma.pk_desver_cabFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pk_desver_cabFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_desver_cabPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pk_desver_cabFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_desver_cabPayload>
          }
          findFirst: {
            args: Prisma.pk_desver_cabFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_desver_cabPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pk_desver_cabFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_desver_cabPayload>
          }
          findMany: {
            args: Prisma.pk_desver_cabFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_desver_cabPayload>[]
          }
          create: {
            args: Prisma.pk_desver_cabCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_desver_cabPayload>
          }
          createMany: {
            args: Prisma.pk_desver_cabCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pk_desver_cabDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_desver_cabPayload>
          }
          update: {
            args: Prisma.pk_desver_cabUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_desver_cabPayload>
          }
          deleteMany: {
            args: Prisma.pk_desver_cabDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pk_desver_cabUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pk_desver_cabUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_desver_cabPayload>
          }
          aggregate: {
            args: Prisma.Pk_desver_cabAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePk_desver_cab>
          }
          groupBy: {
            args: Prisma.pk_desver_cabGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pk_desver_cabGroupByOutputType>[]
          }
          count: {
            args: Prisma.pk_desver_cabCountArgs<ExtArgs>
            result: $Utils.Optional<Pk_desver_cabCountAggregateOutputType> | number
          }
        }
      }
      pk_desver_det: {
        payload: Prisma.$pk_desver_detPayload<ExtArgs>
        fields: Prisma.pk_desver_detFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pk_desver_detFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_desver_detPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pk_desver_detFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_desver_detPayload>
          }
          findFirst: {
            args: Prisma.pk_desver_detFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_desver_detPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pk_desver_detFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_desver_detPayload>
          }
          findMany: {
            args: Prisma.pk_desver_detFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_desver_detPayload>[]
          }
          create: {
            args: Prisma.pk_desver_detCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_desver_detPayload>
          }
          createMany: {
            args: Prisma.pk_desver_detCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pk_desver_detDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_desver_detPayload>
          }
          update: {
            args: Prisma.pk_desver_detUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_desver_detPayload>
          }
          deleteMany: {
            args: Prisma.pk_desver_detDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pk_desver_detUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pk_desver_detUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_desver_detPayload>
          }
          aggregate: {
            args: Prisma.Pk_desver_detAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePk_desver_det>
          }
          groupBy: {
            args: Prisma.pk_desver_detGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pk_desver_detGroupByOutputType>[]
          }
          count: {
            args: Prisma.pk_desver_detCountArgs<ExtArgs>
            result: $Utils.Optional<Pk_desver_detCountAggregateOutputType> | number
          }
        }
      }
      sys_log: {
        payload: Prisma.$sys_logPayload<ExtArgs>
        fields: Prisma.sys_logFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sys_logFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sys_logFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_logPayload>
          }
          findFirst: {
            args: Prisma.sys_logFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sys_logFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_logPayload>
          }
          findMany: {
            args: Prisma.sys_logFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_logPayload>[]
          }
          create: {
            args: Prisma.sys_logCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_logPayload>
          }
          createMany: {
            args: Prisma.sys_logCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sys_logDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_logPayload>
          }
          update: {
            args: Prisma.sys_logUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_logPayload>
          }
          deleteMany: {
            args: Prisma.sys_logDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sys_logUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sys_logUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sys_logPayload>
          }
          aggregate: {
            args: Prisma.Sys_logAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSys_log>
          }
          groupBy: {
            args: Prisma.sys_logGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sys_logGroupByOutputType>[]
          }
          count: {
            args: Prisma.sys_logCountArgs<ExtArgs>
            result: $Utils.Optional<Sys_logCountAggregateOutputType> | number
          }
        }
      }
      sysdiagrams: {
        payload: Prisma.$sysdiagramsPayload<ExtArgs>
        fields: Prisma.sysdiagramsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sysdiagramsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sysdiagramsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          findFirst: {
            args: Prisma.sysdiagramsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sysdiagramsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          findMany: {
            args: Prisma.sysdiagramsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>[]
          }
          create: {
            args: Prisma.sysdiagramsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          createMany: {
            args: Prisma.sysdiagramsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sysdiagramsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          update: {
            args: Prisma.sysdiagramsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          deleteMany: {
            args: Prisma.sysdiagramsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sysdiagramsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sysdiagramsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          aggregate: {
            args: Prisma.SysdiagramsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSysdiagrams>
          }
          groupBy: {
            args: Prisma.sysdiagramsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SysdiagramsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sysdiagramsCountArgs<ExtArgs>
            result: $Utils.Optional<SysdiagramsCountAggregateOutputType> | number
          }
        }
      }
      tipo_ins: {
        payload: Prisma.$tipo_insPayload<ExtArgs>
        fields: Prisma.tipo_insFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tipo_insFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_insPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tipo_insFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_insPayload>
          }
          findFirst: {
            args: Prisma.tipo_insFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_insPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tipo_insFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_insPayload>
          }
          findMany: {
            args: Prisma.tipo_insFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_insPayload>[]
          }
          create: {
            args: Prisma.tipo_insCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_insPayload>
          }
          createMany: {
            args: Prisma.tipo_insCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tipo_insDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_insPayload>
          }
          update: {
            args: Prisma.tipo_insUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_insPayload>
          }
          deleteMany: {
            args: Prisma.tipo_insDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tipo_insUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tipo_insUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_insPayload>
          }
          aggregate: {
            args: Prisma.Tipo_insAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipo_ins>
          }
          groupBy: {
            args: Prisma.tipo_insGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tipo_insGroupByOutputType>[]
          }
          count: {
            args: Prisma.tipo_insCountArgs<ExtArgs>
            result: $Utils.Optional<Tipo_insCountAggregateOutputType> | number
          }
        }
      }
      traductor_calibre: {
        payload: Prisma.$traductor_calibrePayload<ExtArgs>
        fields: Prisma.traductor_calibreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.traductor_calibreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$traductor_calibrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.traductor_calibreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$traductor_calibrePayload>
          }
          findFirst: {
            args: Prisma.traductor_calibreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$traductor_calibrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.traductor_calibreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$traductor_calibrePayload>
          }
          findMany: {
            args: Prisma.traductor_calibreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$traductor_calibrePayload>[]
          }
          create: {
            args: Prisma.traductor_calibreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$traductor_calibrePayload>
          }
          createMany: {
            args: Prisma.traductor_calibreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.traductor_calibreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$traductor_calibrePayload>
          }
          update: {
            args: Prisma.traductor_calibreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$traductor_calibrePayload>
          }
          deleteMany: {
            args: Prisma.traductor_calibreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.traductor_calibreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.traductor_calibreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$traductor_calibrePayload>
          }
          aggregate: {
            args: Prisma.Traductor_calibreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTraductor_calibre>
          }
          groupBy: {
            args: Prisma.traductor_calibreGroupByArgs<ExtArgs>
            result: $Utils.Optional<Traductor_calibreGroupByOutputType>[]
          }
          count: {
            args: Prisma.traductor_calibreCountArgs<ExtArgs>
            result: $Utils.Optional<Traductor_calibreCountAggregateOutputType> | number
          }
        }
      }
      validacion_pallets: {
        payload: Prisma.$validacion_palletsPayload<ExtArgs>
        fields: Prisma.validacion_palletsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.validacion_palletsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$validacion_palletsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.validacion_palletsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$validacion_palletsPayload>
          }
          findFirst: {
            args: Prisma.validacion_palletsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$validacion_palletsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.validacion_palletsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$validacion_palletsPayload>
          }
          findMany: {
            args: Prisma.validacion_palletsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$validacion_palletsPayload>[]
          }
          create: {
            args: Prisma.validacion_palletsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$validacion_palletsPayload>
          }
          createMany: {
            args: Prisma.validacion_palletsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.validacion_palletsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$validacion_palletsPayload>
          }
          update: {
            args: Prisma.validacion_palletsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$validacion_palletsPayload>
          }
          deleteMany: {
            args: Prisma.validacion_palletsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.validacion_palletsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.validacion_palletsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$validacion_palletsPayload>
          }
          aggregate: {
            args: Prisma.Validacion_palletsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateValidacion_pallets>
          }
          groupBy: {
            args: Prisma.validacion_palletsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Validacion_palletsGroupByOutputType>[]
          }
          count: {
            args: Prisma.validacion_palletsCountArgs<ExtArgs>
            result: $Utils.Optional<Validacion_palletsCountAggregateOutputType> | number
          }
        }
      }
      existencias_cajas: {
        payload: Prisma.$existencias_cajasPayload<ExtArgs>
        fields: Prisma.existencias_cajasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.existencias_cajasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$existencias_cajasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.existencias_cajasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$existencias_cajasPayload>
          }
          findFirst: {
            args: Prisma.existencias_cajasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$existencias_cajasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.existencias_cajasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$existencias_cajasPayload>
          }
          findMany: {
            args: Prisma.existencias_cajasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$existencias_cajasPayload>[]
          }
          create: {
            args: Prisma.existencias_cajasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$existencias_cajasPayload>
          }
          createMany: {
            args: Prisma.existencias_cajasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.existencias_cajasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$existencias_cajasPayload>
          }
          update: {
            args: Prisma.existencias_cajasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$existencias_cajasPayload>
          }
          deleteMany: {
            args: Prisma.existencias_cajasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.existencias_cajasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.existencias_cajasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$existencias_cajasPayload>
          }
          aggregate: {
            args: Prisma.Existencias_cajasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExistencias_cajas>
          }
          groupBy: {
            args: Prisma.existencias_cajasGroupByArgs<ExtArgs>
            result: $Utils.Optional<Existencias_cajasGroupByOutputType>[]
          }
          count: {
            args: Prisma.existencias_cajasCountArgs<ExtArgs>
            result: $Utils.Optional<Existencias_cajasCountAggregateOutputType> | number
          }
        }
      }
      existenciamix_cajas: {
        payload: Prisma.$existenciamix_cajasPayload<ExtArgs>
        fields: Prisma.existenciamix_cajasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.existenciamix_cajasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$existenciamix_cajasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.existenciamix_cajasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$existenciamix_cajasPayload>
          }
          findFirst: {
            args: Prisma.existenciamix_cajasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$existenciamix_cajasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.existenciamix_cajasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$existenciamix_cajasPayload>
          }
          findMany: {
            args: Prisma.existenciamix_cajasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$existenciamix_cajasPayload>[]
          }
          create: {
            args: Prisma.existenciamix_cajasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$existenciamix_cajasPayload>
          }
          createMany: {
            args: Prisma.existenciamix_cajasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.existenciamix_cajasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$existenciamix_cajasPayload>
          }
          update: {
            args: Prisma.existenciamix_cajasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$existenciamix_cajasPayload>
          }
          deleteMany: {
            args: Prisma.existenciamix_cajasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.existenciamix_cajasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.existenciamix_cajasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$existenciamix_cajasPayload>
          }
          aggregate: {
            args: Prisma.Existenciamix_cajasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExistenciamix_cajas>
          }
          groupBy: {
            args: Prisma.existenciamix_cajasGroupByArgs<ExtArgs>
            result: $Utils.Optional<Existenciamix_cajasGroupByOutputType>[]
          }
          count: {
            args: Prisma.existenciamix_cajasCountArgs<ExtArgs>
            result: $Utils.Optional<Existenciamix_cajasCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model capacidad_lineas
   */

  export type AggregateCapacidad_lineas = {
    _count: Capacidad_lineasCountAggregateOutputType | null
    _avg: Capacidad_lineasAvgAggregateOutputType | null
    _sum: Capacidad_lineasSumAggregateOutputType | null
    _min: Capacidad_lineasMinAggregateOutputType | null
    _max: Capacidad_lineasMaxAggregateOutputType | null
  }

  export type Capacidad_lineasAvgAggregateOutputType = {
    id: number | null
    nro_vias: number | null
    capacidad_vias: Decimal | null
  }

  export type Capacidad_lineasSumAggregateOutputType = {
    id: number | null
    nro_vias: number | null
    capacidad_vias: Decimal | null
  }

  export type Capacidad_lineasMinAggregateOutputType = {
    id: number | null
    cod_linea: string | null
    cod_esp: string | null
    nro_vias: number | null
    capacidad_vias: Decimal | null
  }

  export type Capacidad_lineasMaxAggregateOutputType = {
    id: number | null
    cod_linea: string | null
    cod_esp: string | null
    nro_vias: number | null
    capacidad_vias: Decimal | null
  }

  export type Capacidad_lineasCountAggregateOutputType = {
    id: number
    cod_linea: number
    cod_esp: number
    nro_vias: number
    capacidad_vias: number
    _all: number
  }


  export type Capacidad_lineasAvgAggregateInputType = {
    id?: true
    nro_vias?: true
    capacidad_vias?: true
  }

  export type Capacidad_lineasSumAggregateInputType = {
    id?: true
    nro_vias?: true
    capacidad_vias?: true
  }

  export type Capacidad_lineasMinAggregateInputType = {
    id?: true
    cod_linea?: true
    cod_esp?: true
    nro_vias?: true
    capacidad_vias?: true
  }

  export type Capacidad_lineasMaxAggregateInputType = {
    id?: true
    cod_linea?: true
    cod_esp?: true
    nro_vias?: true
    capacidad_vias?: true
  }

  export type Capacidad_lineasCountAggregateInputType = {
    id?: true
    cod_linea?: true
    cod_esp?: true
    nro_vias?: true
    capacidad_vias?: true
    _all?: true
  }

  export type Capacidad_lineasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which capacidad_lineas to aggregate.
     */
    where?: capacidad_lineasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacidad_lineas to fetch.
     */
    orderBy?: capacidad_lineasOrderByWithRelationInput | capacidad_lineasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: capacidad_lineasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacidad_lineas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacidad_lineas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned capacidad_lineas
    **/
    _count?: true | Capacidad_lineasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Capacidad_lineasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Capacidad_lineasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Capacidad_lineasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Capacidad_lineasMaxAggregateInputType
  }

  export type GetCapacidad_lineasAggregateType<T extends Capacidad_lineasAggregateArgs> = {
        [P in keyof T & keyof AggregateCapacidad_lineas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapacidad_lineas[P]>
      : GetScalarType<T[P], AggregateCapacidad_lineas[P]>
  }




  export type capacidad_lineasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capacidad_lineasWhereInput
    orderBy?: capacidad_lineasOrderByWithAggregationInput | capacidad_lineasOrderByWithAggregationInput[]
    by: Capacidad_lineasScalarFieldEnum[] | Capacidad_lineasScalarFieldEnum
    having?: capacidad_lineasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Capacidad_lineasCountAggregateInputType | true
    _avg?: Capacidad_lineasAvgAggregateInputType
    _sum?: Capacidad_lineasSumAggregateInputType
    _min?: Capacidad_lineasMinAggregateInputType
    _max?: Capacidad_lineasMaxAggregateInputType
  }

  export type Capacidad_lineasGroupByOutputType = {
    id: number
    cod_linea: string | null
    cod_esp: string | null
    nro_vias: number | null
    capacidad_vias: Decimal | null
    _count: Capacidad_lineasCountAggregateOutputType | null
    _avg: Capacidad_lineasAvgAggregateOutputType | null
    _sum: Capacidad_lineasSumAggregateOutputType | null
    _min: Capacidad_lineasMinAggregateOutputType | null
    _max: Capacidad_lineasMaxAggregateOutputType | null
  }

  type GetCapacidad_lineasGroupByPayload<T extends capacidad_lineasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Capacidad_lineasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Capacidad_lineasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Capacidad_lineasGroupByOutputType[P]>
            : GetScalarType<T[P], Capacidad_lineasGroupByOutputType[P]>
        }
      >
    >


  export type capacidad_lineasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cod_linea?: boolean
    cod_esp?: boolean
    nro_vias?: boolean
    capacidad_vias?: boolean
  }, ExtArgs["result"]["capacidad_lineas"]>


  export type capacidad_lineasSelectScalar = {
    id?: boolean
    cod_linea?: boolean
    cod_esp?: boolean
    nro_vias?: boolean
    capacidad_vias?: boolean
  }


  export type $capacidad_lineasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "capacidad_lineas"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cod_linea: string | null
      cod_esp: string | null
      nro_vias: number | null
      capacidad_vias: Prisma.Decimal | null
    }, ExtArgs["result"]["capacidad_lineas"]>
    composites: {}
  }

  type capacidad_lineasGetPayload<S extends boolean | null | undefined | capacidad_lineasDefaultArgs> = $Result.GetResult<Prisma.$capacidad_lineasPayload, S>

  type capacidad_lineasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<capacidad_lineasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Capacidad_lineasCountAggregateInputType | true
    }

  export interface capacidad_lineasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['capacidad_lineas'], meta: { name: 'capacidad_lineas' } }
    /**
     * Find zero or one Capacidad_lineas that matches the filter.
     * @param {capacidad_lineasFindUniqueArgs} args - Arguments to find a Capacidad_lineas
     * @example
     * // Get one Capacidad_lineas
     * const capacidad_lineas = await prisma.capacidad_lineas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends capacidad_lineasFindUniqueArgs>(args: SelectSubset<T, capacidad_lineasFindUniqueArgs<ExtArgs>>): Prisma__capacidad_lineasClient<$Result.GetResult<Prisma.$capacidad_lineasPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Capacidad_lineas that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {capacidad_lineasFindUniqueOrThrowArgs} args - Arguments to find a Capacidad_lineas
     * @example
     * // Get one Capacidad_lineas
     * const capacidad_lineas = await prisma.capacidad_lineas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends capacidad_lineasFindUniqueOrThrowArgs>(args: SelectSubset<T, capacidad_lineasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__capacidad_lineasClient<$Result.GetResult<Prisma.$capacidad_lineasPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Capacidad_lineas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacidad_lineasFindFirstArgs} args - Arguments to find a Capacidad_lineas
     * @example
     * // Get one Capacidad_lineas
     * const capacidad_lineas = await prisma.capacidad_lineas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends capacidad_lineasFindFirstArgs>(args?: SelectSubset<T, capacidad_lineasFindFirstArgs<ExtArgs>>): Prisma__capacidad_lineasClient<$Result.GetResult<Prisma.$capacidad_lineasPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Capacidad_lineas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacidad_lineasFindFirstOrThrowArgs} args - Arguments to find a Capacidad_lineas
     * @example
     * // Get one Capacidad_lineas
     * const capacidad_lineas = await prisma.capacidad_lineas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends capacidad_lineasFindFirstOrThrowArgs>(args?: SelectSubset<T, capacidad_lineasFindFirstOrThrowArgs<ExtArgs>>): Prisma__capacidad_lineasClient<$Result.GetResult<Prisma.$capacidad_lineasPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Capacidad_lineas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacidad_lineasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Capacidad_lineas
     * const capacidad_lineas = await prisma.capacidad_lineas.findMany()
     * 
     * // Get first 10 Capacidad_lineas
     * const capacidad_lineas = await prisma.capacidad_lineas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const capacidad_lineasWithIdOnly = await prisma.capacidad_lineas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends capacidad_lineasFindManyArgs>(args?: SelectSubset<T, capacidad_lineasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capacidad_lineasPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Capacidad_lineas.
     * @param {capacidad_lineasCreateArgs} args - Arguments to create a Capacidad_lineas.
     * @example
     * // Create one Capacidad_lineas
     * const Capacidad_lineas = await prisma.capacidad_lineas.create({
     *   data: {
     *     // ... data to create a Capacidad_lineas
     *   }
     * })
     * 
     */
    create<T extends capacidad_lineasCreateArgs>(args: SelectSubset<T, capacidad_lineasCreateArgs<ExtArgs>>): Prisma__capacidad_lineasClient<$Result.GetResult<Prisma.$capacidad_lineasPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Capacidad_lineas.
     * @param {capacidad_lineasCreateManyArgs} args - Arguments to create many Capacidad_lineas.
     * @example
     * // Create many Capacidad_lineas
     * const capacidad_lineas = await prisma.capacidad_lineas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends capacidad_lineasCreateManyArgs>(args?: SelectSubset<T, capacidad_lineasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Capacidad_lineas.
     * @param {capacidad_lineasDeleteArgs} args - Arguments to delete one Capacidad_lineas.
     * @example
     * // Delete one Capacidad_lineas
     * const Capacidad_lineas = await prisma.capacidad_lineas.delete({
     *   where: {
     *     // ... filter to delete one Capacidad_lineas
     *   }
     * })
     * 
     */
    delete<T extends capacidad_lineasDeleteArgs>(args: SelectSubset<T, capacidad_lineasDeleteArgs<ExtArgs>>): Prisma__capacidad_lineasClient<$Result.GetResult<Prisma.$capacidad_lineasPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Capacidad_lineas.
     * @param {capacidad_lineasUpdateArgs} args - Arguments to update one Capacidad_lineas.
     * @example
     * // Update one Capacidad_lineas
     * const capacidad_lineas = await prisma.capacidad_lineas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends capacidad_lineasUpdateArgs>(args: SelectSubset<T, capacidad_lineasUpdateArgs<ExtArgs>>): Prisma__capacidad_lineasClient<$Result.GetResult<Prisma.$capacidad_lineasPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Capacidad_lineas.
     * @param {capacidad_lineasDeleteManyArgs} args - Arguments to filter Capacidad_lineas to delete.
     * @example
     * // Delete a few Capacidad_lineas
     * const { count } = await prisma.capacidad_lineas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends capacidad_lineasDeleteManyArgs>(args?: SelectSubset<T, capacidad_lineasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Capacidad_lineas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacidad_lineasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Capacidad_lineas
     * const capacidad_lineas = await prisma.capacidad_lineas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends capacidad_lineasUpdateManyArgs>(args: SelectSubset<T, capacidad_lineasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Capacidad_lineas.
     * @param {capacidad_lineasUpsertArgs} args - Arguments to update or create a Capacidad_lineas.
     * @example
     * // Update or create a Capacidad_lineas
     * const capacidad_lineas = await prisma.capacidad_lineas.upsert({
     *   create: {
     *     // ... data to create a Capacidad_lineas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Capacidad_lineas we want to update
     *   }
     * })
     */
    upsert<T extends capacidad_lineasUpsertArgs>(args: SelectSubset<T, capacidad_lineasUpsertArgs<ExtArgs>>): Prisma__capacidad_lineasClient<$Result.GetResult<Prisma.$capacidad_lineasPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Capacidad_lineas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacidad_lineasCountArgs} args - Arguments to filter Capacidad_lineas to count.
     * @example
     * // Count the number of Capacidad_lineas
     * const count = await prisma.capacidad_lineas.count({
     *   where: {
     *     // ... the filter for the Capacidad_lineas we want to count
     *   }
     * })
    **/
    count<T extends capacidad_lineasCountArgs>(
      args?: Subset<T, capacidad_lineasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Capacidad_lineasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Capacidad_lineas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Capacidad_lineasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Capacidad_lineasAggregateArgs>(args: Subset<T, Capacidad_lineasAggregateArgs>): Prisma.PrismaPromise<GetCapacidad_lineasAggregateType<T>>

    /**
     * Group by Capacidad_lineas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capacidad_lineasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends capacidad_lineasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: capacidad_lineasGroupByArgs['orderBy'] }
        : { orderBy?: capacidad_lineasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, capacidad_lineasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapacidad_lineasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the capacidad_lineas model
   */
  readonly fields: capacidad_lineasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for capacidad_lineas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__capacidad_lineasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the capacidad_lineas model
   */ 
  interface capacidad_lineasFieldRefs {
    readonly id: FieldRef<"capacidad_lineas", 'Int'>
    readonly cod_linea: FieldRef<"capacidad_lineas", 'String'>
    readonly cod_esp: FieldRef<"capacidad_lineas", 'String'>
    readonly nro_vias: FieldRef<"capacidad_lineas", 'Int'>
    readonly capacidad_vias: FieldRef<"capacidad_lineas", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * capacidad_lineas findUnique
   */
  export type capacidad_lineasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacidad_lineas
     */
    select?: capacidad_lineasSelect<ExtArgs> | null
    /**
     * Filter, which capacidad_lineas to fetch.
     */
    where: capacidad_lineasWhereUniqueInput
  }

  /**
   * capacidad_lineas findUniqueOrThrow
   */
  export type capacidad_lineasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacidad_lineas
     */
    select?: capacidad_lineasSelect<ExtArgs> | null
    /**
     * Filter, which capacidad_lineas to fetch.
     */
    where: capacidad_lineasWhereUniqueInput
  }

  /**
   * capacidad_lineas findFirst
   */
  export type capacidad_lineasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacidad_lineas
     */
    select?: capacidad_lineasSelect<ExtArgs> | null
    /**
     * Filter, which capacidad_lineas to fetch.
     */
    where?: capacidad_lineasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacidad_lineas to fetch.
     */
    orderBy?: capacidad_lineasOrderByWithRelationInput | capacidad_lineasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capacidad_lineas.
     */
    cursor?: capacidad_lineasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacidad_lineas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacidad_lineas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capacidad_lineas.
     */
    distinct?: Capacidad_lineasScalarFieldEnum | Capacidad_lineasScalarFieldEnum[]
  }

  /**
   * capacidad_lineas findFirstOrThrow
   */
  export type capacidad_lineasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacidad_lineas
     */
    select?: capacidad_lineasSelect<ExtArgs> | null
    /**
     * Filter, which capacidad_lineas to fetch.
     */
    where?: capacidad_lineasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacidad_lineas to fetch.
     */
    orderBy?: capacidad_lineasOrderByWithRelationInput | capacidad_lineasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capacidad_lineas.
     */
    cursor?: capacidad_lineasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacidad_lineas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacidad_lineas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capacidad_lineas.
     */
    distinct?: Capacidad_lineasScalarFieldEnum | Capacidad_lineasScalarFieldEnum[]
  }

  /**
   * capacidad_lineas findMany
   */
  export type capacidad_lineasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacidad_lineas
     */
    select?: capacidad_lineasSelect<ExtArgs> | null
    /**
     * Filter, which capacidad_lineas to fetch.
     */
    where?: capacidad_lineasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capacidad_lineas to fetch.
     */
    orderBy?: capacidad_lineasOrderByWithRelationInput | capacidad_lineasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing capacidad_lineas.
     */
    cursor?: capacidad_lineasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capacidad_lineas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capacidad_lineas.
     */
    skip?: number
    distinct?: Capacidad_lineasScalarFieldEnum | Capacidad_lineasScalarFieldEnum[]
  }

  /**
   * capacidad_lineas create
   */
  export type capacidad_lineasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacidad_lineas
     */
    select?: capacidad_lineasSelect<ExtArgs> | null
    /**
     * The data needed to create a capacidad_lineas.
     */
    data?: XOR<capacidad_lineasCreateInput, capacidad_lineasUncheckedCreateInput>
  }

  /**
   * capacidad_lineas createMany
   */
  export type capacidad_lineasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many capacidad_lineas.
     */
    data: capacidad_lineasCreateManyInput | capacidad_lineasCreateManyInput[]
  }

  /**
   * capacidad_lineas update
   */
  export type capacidad_lineasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacidad_lineas
     */
    select?: capacidad_lineasSelect<ExtArgs> | null
    /**
     * The data needed to update a capacidad_lineas.
     */
    data: XOR<capacidad_lineasUpdateInput, capacidad_lineasUncheckedUpdateInput>
    /**
     * Choose, which capacidad_lineas to update.
     */
    where: capacidad_lineasWhereUniqueInput
  }

  /**
   * capacidad_lineas updateMany
   */
  export type capacidad_lineasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update capacidad_lineas.
     */
    data: XOR<capacidad_lineasUpdateManyMutationInput, capacidad_lineasUncheckedUpdateManyInput>
    /**
     * Filter which capacidad_lineas to update
     */
    where?: capacidad_lineasWhereInput
  }

  /**
   * capacidad_lineas upsert
   */
  export type capacidad_lineasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacidad_lineas
     */
    select?: capacidad_lineasSelect<ExtArgs> | null
    /**
     * The filter to search for the capacidad_lineas to update in case it exists.
     */
    where: capacidad_lineasWhereUniqueInput
    /**
     * In case the capacidad_lineas found by the `where` argument doesn't exist, create a new capacidad_lineas with this data.
     */
    create: XOR<capacidad_lineasCreateInput, capacidad_lineasUncheckedCreateInput>
    /**
     * In case the capacidad_lineas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<capacidad_lineasUpdateInput, capacidad_lineasUncheckedUpdateInput>
  }

  /**
   * capacidad_lineas delete
   */
  export type capacidad_lineasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacidad_lineas
     */
    select?: capacidad_lineasSelect<ExtArgs> | null
    /**
     * Filter which capacidad_lineas to delete.
     */
    where: capacidad_lineasWhereUniqueInput
  }

  /**
   * capacidad_lineas deleteMany
   */
  export type capacidad_lineasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which capacidad_lineas to delete
     */
    where?: capacidad_lineasWhereInput
  }

  /**
   * capacidad_lineas without action
   */
  export type capacidad_lineasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capacidad_lineas
     */
    select?: capacidad_lineasSelect<ExtArgs> | null
  }


  /**
   * Model cc_checklist
   */

  export type AggregateCc_checklist = {
    _count: Cc_checklistCountAggregateOutputType | null
    _avg: Cc_checklistAvgAggregateOutputType | null
    _sum: Cc_checklistSumAggregateOutputType | null
    _min: Cc_checklistMinAggregateOutputType | null
    _max: Cc_checklistMaxAggregateOutputType | null
  }

  export type Cc_checklistAvgAggregateOutputType = {
    id: number | null
    n_proceso: number | null
    porc_exp: number | null
    peso_caj: Decimal | null
    porc_plu: number | null
  }

  export type Cc_checklistSumAggregateOutputType = {
    id: number | null
    n_proceso: number | null
    porc_exp: number | null
    peso_caj: Decimal | null
    porc_plu: number | null
  }

  export type Cc_checklistMinAggregateOutputType = {
    id: number | null
    n_proceso: number | null
    cod_esp: string | null
    cod_var: string | null
    cod_pro: string | null
    cod_linea: string | null
    fecha: Date | null
    cal_encerado: string | null
    porc_exp: number | null
    cal_cajas: string | null
    porc_plu_c: string | null
    peso_caj: Decimal | null
    cal_palet: string | null
    saturacion: string | null
    porc_exp_c: string | null
    usuario: string | null
    porc_plu: number | null
    cod_emp: string | null
    cod_tem: string | null
    cod_envop: string | null
    peso_c: string | null
    fec_muestra: Date | null
  }

  export type Cc_checklistMaxAggregateOutputType = {
    id: number | null
    n_proceso: number | null
    cod_esp: string | null
    cod_var: string | null
    cod_pro: string | null
    cod_linea: string | null
    fecha: Date | null
    cal_encerado: string | null
    porc_exp: number | null
    cal_cajas: string | null
    porc_plu_c: string | null
    peso_caj: Decimal | null
    cal_palet: string | null
    saturacion: string | null
    porc_exp_c: string | null
    usuario: string | null
    porc_plu: number | null
    cod_emp: string | null
    cod_tem: string | null
    cod_envop: string | null
    peso_c: string | null
    fec_muestra: Date | null
  }

  export type Cc_checklistCountAggregateOutputType = {
    id: number
    n_proceso: number
    cod_esp: number
    cod_var: number
    cod_pro: number
    cod_linea: number
    fecha: number
    cal_encerado: number
    porc_exp: number
    cal_cajas: number
    porc_plu_c: number
    peso_caj: number
    cal_palet: number
    saturacion: number
    porc_exp_c: number
    usuario: number
    porc_plu: number
    cod_emp: number
    cod_tem: number
    cod_envop: number
    peso_c: number
    fec_muestra: number
    _all: number
  }


  export type Cc_checklistAvgAggregateInputType = {
    id?: true
    n_proceso?: true
    porc_exp?: true
    peso_caj?: true
    porc_plu?: true
  }

  export type Cc_checklistSumAggregateInputType = {
    id?: true
    n_proceso?: true
    porc_exp?: true
    peso_caj?: true
    porc_plu?: true
  }

  export type Cc_checklistMinAggregateInputType = {
    id?: true
    n_proceso?: true
    cod_esp?: true
    cod_var?: true
    cod_pro?: true
    cod_linea?: true
    fecha?: true
    cal_encerado?: true
    porc_exp?: true
    cal_cajas?: true
    porc_plu_c?: true
    peso_caj?: true
    cal_palet?: true
    saturacion?: true
    porc_exp_c?: true
    usuario?: true
    porc_plu?: true
    cod_emp?: true
    cod_tem?: true
    cod_envop?: true
    peso_c?: true
    fec_muestra?: true
  }

  export type Cc_checklistMaxAggregateInputType = {
    id?: true
    n_proceso?: true
    cod_esp?: true
    cod_var?: true
    cod_pro?: true
    cod_linea?: true
    fecha?: true
    cal_encerado?: true
    porc_exp?: true
    cal_cajas?: true
    porc_plu_c?: true
    peso_caj?: true
    cal_palet?: true
    saturacion?: true
    porc_exp_c?: true
    usuario?: true
    porc_plu?: true
    cod_emp?: true
    cod_tem?: true
    cod_envop?: true
    peso_c?: true
    fec_muestra?: true
  }

  export type Cc_checklistCountAggregateInputType = {
    id?: true
    n_proceso?: true
    cod_esp?: true
    cod_var?: true
    cod_pro?: true
    cod_linea?: true
    fecha?: true
    cal_encerado?: true
    porc_exp?: true
    cal_cajas?: true
    porc_plu_c?: true
    peso_caj?: true
    cal_palet?: true
    saturacion?: true
    porc_exp_c?: true
    usuario?: true
    porc_plu?: true
    cod_emp?: true
    cod_tem?: true
    cod_envop?: true
    peso_c?: true
    fec_muestra?: true
    _all?: true
  }

  export type Cc_checklistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cc_checklist to aggregate.
     */
    where?: cc_checklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cc_checklists to fetch.
     */
    orderBy?: cc_checklistOrderByWithRelationInput | cc_checklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cc_checklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cc_checklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cc_checklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cc_checklists
    **/
    _count?: true | Cc_checklistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cc_checklistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cc_checklistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cc_checklistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cc_checklistMaxAggregateInputType
  }

  export type GetCc_checklistAggregateType<T extends Cc_checklistAggregateArgs> = {
        [P in keyof T & keyof AggregateCc_checklist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCc_checklist[P]>
      : GetScalarType<T[P], AggregateCc_checklist[P]>
  }




  export type cc_checklistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cc_checklistWhereInput
    orderBy?: cc_checklistOrderByWithAggregationInput | cc_checklistOrderByWithAggregationInput[]
    by: Cc_checklistScalarFieldEnum[] | Cc_checklistScalarFieldEnum
    having?: cc_checklistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cc_checklistCountAggregateInputType | true
    _avg?: Cc_checklistAvgAggregateInputType
    _sum?: Cc_checklistSumAggregateInputType
    _min?: Cc_checklistMinAggregateInputType
    _max?: Cc_checklistMaxAggregateInputType
  }

  export type Cc_checklistGroupByOutputType = {
    id: number
    n_proceso: number | null
    cod_esp: string | null
    cod_var: string | null
    cod_pro: string | null
    cod_linea: string | null
    fecha: Date | null
    cal_encerado: string | null
    porc_exp: number | null
    cal_cajas: string | null
    porc_plu_c: string | null
    peso_caj: Decimal | null
    cal_palet: string | null
    saturacion: string | null
    porc_exp_c: string | null
    usuario: string | null
    porc_plu: number | null
    cod_emp: string | null
    cod_tem: string | null
    cod_envop: string | null
    peso_c: string | null
    fec_muestra: Date | null
    _count: Cc_checklistCountAggregateOutputType | null
    _avg: Cc_checklistAvgAggregateOutputType | null
    _sum: Cc_checklistSumAggregateOutputType | null
    _min: Cc_checklistMinAggregateOutputType | null
    _max: Cc_checklistMaxAggregateOutputType | null
  }

  type GetCc_checklistGroupByPayload<T extends cc_checklistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cc_checklistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cc_checklistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cc_checklistGroupByOutputType[P]>
            : GetScalarType<T[P], Cc_checklistGroupByOutputType[P]>
        }
      >
    >


  export type cc_checklistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    n_proceso?: boolean
    cod_esp?: boolean
    cod_var?: boolean
    cod_pro?: boolean
    cod_linea?: boolean
    fecha?: boolean
    cal_encerado?: boolean
    porc_exp?: boolean
    cal_cajas?: boolean
    porc_plu_c?: boolean
    peso_caj?: boolean
    cal_palet?: boolean
    saturacion?: boolean
    porc_exp_c?: boolean
    usuario?: boolean
    porc_plu?: boolean
    cod_emp?: boolean
    cod_tem?: boolean
    cod_envop?: boolean
    peso_c?: boolean
    fec_muestra?: boolean
  }, ExtArgs["result"]["cc_checklist"]>


  export type cc_checklistSelectScalar = {
    id?: boolean
    n_proceso?: boolean
    cod_esp?: boolean
    cod_var?: boolean
    cod_pro?: boolean
    cod_linea?: boolean
    fecha?: boolean
    cal_encerado?: boolean
    porc_exp?: boolean
    cal_cajas?: boolean
    porc_plu_c?: boolean
    peso_caj?: boolean
    cal_palet?: boolean
    saturacion?: boolean
    porc_exp_c?: boolean
    usuario?: boolean
    porc_plu?: boolean
    cod_emp?: boolean
    cod_tem?: boolean
    cod_envop?: boolean
    peso_c?: boolean
    fec_muestra?: boolean
  }


  export type $cc_checklistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cc_checklist"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      n_proceso: number | null
      cod_esp: string | null
      cod_var: string | null
      cod_pro: string | null
      cod_linea: string | null
      fecha: Date | null
      cal_encerado: string | null
      porc_exp: number | null
      cal_cajas: string | null
      porc_plu_c: string | null
      peso_caj: Prisma.Decimal | null
      cal_palet: string | null
      saturacion: string | null
      porc_exp_c: string | null
      usuario: string | null
      porc_plu: number | null
      cod_emp: string | null
      cod_tem: string | null
      cod_envop: string | null
      peso_c: string | null
      fec_muestra: Date | null
    }, ExtArgs["result"]["cc_checklist"]>
    composites: {}
  }

  type cc_checklistGetPayload<S extends boolean | null | undefined | cc_checklistDefaultArgs> = $Result.GetResult<Prisma.$cc_checklistPayload, S>

  type cc_checklistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<cc_checklistFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Cc_checklistCountAggregateInputType | true
    }

  export interface cc_checklistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cc_checklist'], meta: { name: 'cc_checklist' } }
    /**
     * Find zero or one Cc_checklist that matches the filter.
     * @param {cc_checklistFindUniqueArgs} args - Arguments to find a Cc_checklist
     * @example
     * // Get one Cc_checklist
     * const cc_checklist = await prisma.cc_checklist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cc_checklistFindUniqueArgs>(args: SelectSubset<T, cc_checklistFindUniqueArgs<ExtArgs>>): Prisma__cc_checklistClient<$Result.GetResult<Prisma.$cc_checklistPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cc_checklist that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {cc_checklistFindUniqueOrThrowArgs} args - Arguments to find a Cc_checklist
     * @example
     * // Get one Cc_checklist
     * const cc_checklist = await prisma.cc_checklist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cc_checklistFindUniqueOrThrowArgs>(args: SelectSubset<T, cc_checklistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cc_checklistClient<$Result.GetResult<Prisma.$cc_checklistPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cc_checklist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cc_checklistFindFirstArgs} args - Arguments to find a Cc_checklist
     * @example
     * // Get one Cc_checklist
     * const cc_checklist = await prisma.cc_checklist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cc_checklistFindFirstArgs>(args?: SelectSubset<T, cc_checklistFindFirstArgs<ExtArgs>>): Prisma__cc_checklistClient<$Result.GetResult<Prisma.$cc_checklistPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cc_checklist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cc_checklistFindFirstOrThrowArgs} args - Arguments to find a Cc_checklist
     * @example
     * // Get one Cc_checklist
     * const cc_checklist = await prisma.cc_checklist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cc_checklistFindFirstOrThrowArgs>(args?: SelectSubset<T, cc_checklistFindFirstOrThrowArgs<ExtArgs>>): Prisma__cc_checklistClient<$Result.GetResult<Prisma.$cc_checklistPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cc_checklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cc_checklistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cc_checklists
     * const cc_checklists = await prisma.cc_checklist.findMany()
     * 
     * // Get first 10 Cc_checklists
     * const cc_checklists = await prisma.cc_checklist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cc_checklistWithIdOnly = await prisma.cc_checklist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cc_checklistFindManyArgs>(args?: SelectSubset<T, cc_checklistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cc_checklistPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cc_checklist.
     * @param {cc_checklistCreateArgs} args - Arguments to create a Cc_checklist.
     * @example
     * // Create one Cc_checklist
     * const Cc_checklist = await prisma.cc_checklist.create({
     *   data: {
     *     // ... data to create a Cc_checklist
     *   }
     * })
     * 
     */
    create<T extends cc_checklistCreateArgs>(args: SelectSubset<T, cc_checklistCreateArgs<ExtArgs>>): Prisma__cc_checklistClient<$Result.GetResult<Prisma.$cc_checklistPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cc_checklists.
     * @param {cc_checklistCreateManyArgs} args - Arguments to create many Cc_checklists.
     * @example
     * // Create many Cc_checklists
     * const cc_checklist = await prisma.cc_checklist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cc_checklistCreateManyArgs>(args?: SelectSubset<T, cc_checklistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cc_checklist.
     * @param {cc_checklistDeleteArgs} args - Arguments to delete one Cc_checklist.
     * @example
     * // Delete one Cc_checklist
     * const Cc_checklist = await prisma.cc_checklist.delete({
     *   where: {
     *     // ... filter to delete one Cc_checklist
     *   }
     * })
     * 
     */
    delete<T extends cc_checklistDeleteArgs>(args: SelectSubset<T, cc_checklistDeleteArgs<ExtArgs>>): Prisma__cc_checklistClient<$Result.GetResult<Prisma.$cc_checklistPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cc_checklist.
     * @param {cc_checklistUpdateArgs} args - Arguments to update one Cc_checklist.
     * @example
     * // Update one Cc_checklist
     * const cc_checklist = await prisma.cc_checklist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cc_checklistUpdateArgs>(args: SelectSubset<T, cc_checklistUpdateArgs<ExtArgs>>): Prisma__cc_checklistClient<$Result.GetResult<Prisma.$cc_checklistPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cc_checklists.
     * @param {cc_checklistDeleteManyArgs} args - Arguments to filter Cc_checklists to delete.
     * @example
     * // Delete a few Cc_checklists
     * const { count } = await prisma.cc_checklist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cc_checklistDeleteManyArgs>(args?: SelectSubset<T, cc_checklistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cc_checklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cc_checklistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cc_checklists
     * const cc_checklist = await prisma.cc_checklist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cc_checklistUpdateManyArgs>(args: SelectSubset<T, cc_checklistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cc_checklist.
     * @param {cc_checklistUpsertArgs} args - Arguments to update or create a Cc_checklist.
     * @example
     * // Update or create a Cc_checklist
     * const cc_checklist = await prisma.cc_checklist.upsert({
     *   create: {
     *     // ... data to create a Cc_checklist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cc_checklist we want to update
     *   }
     * })
     */
    upsert<T extends cc_checklistUpsertArgs>(args: SelectSubset<T, cc_checklistUpsertArgs<ExtArgs>>): Prisma__cc_checklistClient<$Result.GetResult<Prisma.$cc_checklistPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cc_checklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cc_checklistCountArgs} args - Arguments to filter Cc_checklists to count.
     * @example
     * // Count the number of Cc_checklists
     * const count = await prisma.cc_checklist.count({
     *   where: {
     *     // ... the filter for the Cc_checklists we want to count
     *   }
     * })
    **/
    count<T extends cc_checklistCountArgs>(
      args?: Subset<T, cc_checklistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cc_checklistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cc_checklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cc_checklistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cc_checklistAggregateArgs>(args: Subset<T, Cc_checklistAggregateArgs>): Prisma.PrismaPromise<GetCc_checklistAggregateType<T>>

    /**
     * Group by Cc_checklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cc_checklistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cc_checklistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cc_checklistGroupByArgs['orderBy'] }
        : { orderBy?: cc_checklistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cc_checklistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCc_checklistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cc_checklist model
   */
  readonly fields: cc_checklistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cc_checklist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cc_checklistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cc_checklist model
   */ 
  interface cc_checklistFieldRefs {
    readonly id: FieldRef<"cc_checklist", 'Int'>
    readonly n_proceso: FieldRef<"cc_checklist", 'Int'>
    readonly cod_esp: FieldRef<"cc_checklist", 'String'>
    readonly cod_var: FieldRef<"cc_checklist", 'String'>
    readonly cod_pro: FieldRef<"cc_checklist", 'String'>
    readonly cod_linea: FieldRef<"cc_checklist", 'String'>
    readonly fecha: FieldRef<"cc_checklist", 'DateTime'>
    readonly cal_encerado: FieldRef<"cc_checklist", 'String'>
    readonly porc_exp: FieldRef<"cc_checklist", 'Int'>
    readonly cal_cajas: FieldRef<"cc_checklist", 'String'>
    readonly porc_plu_c: FieldRef<"cc_checklist", 'String'>
    readonly peso_caj: FieldRef<"cc_checklist", 'Decimal'>
    readonly cal_palet: FieldRef<"cc_checklist", 'String'>
    readonly saturacion: FieldRef<"cc_checklist", 'String'>
    readonly porc_exp_c: FieldRef<"cc_checklist", 'String'>
    readonly usuario: FieldRef<"cc_checklist", 'String'>
    readonly porc_plu: FieldRef<"cc_checklist", 'Int'>
    readonly cod_emp: FieldRef<"cc_checklist", 'String'>
    readonly cod_tem: FieldRef<"cc_checklist", 'String'>
    readonly cod_envop: FieldRef<"cc_checklist", 'String'>
    readonly peso_c: FieldRef<"cc_checklist", 'String'>
    readonly fec_muestra: FieldRef<"cc_checklist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * cc_checklist findUnique
   */
  export type cc_checklistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cc_checklist
     */
    select?: cc_checklistSelect<ExtArgs> | null
    /**
     * Filter, which cc_checklist to fetch.
     */
    where: cc_checklistWhereUniqueInput
  }

  /**
   * cc_checklist findUniqueOrThrow
   */
  export type cc_checklistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cc_checklist
     */
    select?: cc_checklistSelect<ExtArgs> | null
    /**
     * Filter, which cc_checklist to fetch.
     */
    where: cc_checklistWhereUniqueInput
  }

  /**
   * cc_checklist findFirst
   */
  export type cc_checklistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cc_checklist
     */
    select?: cc_checklistSelect<ExtArgs> | null
    /**
     * Filter, which cc_checklist to fetch.
     */
    where?: cc_checklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cc_checklists to fetch.
     */
    orderBy?: cc_checklistOrderByWithRelationInput | cc_checklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cc_checklists.
     */
    cursor?: cc_checklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cc_checklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cc_checklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cc_checklists.
     */
    distinct?: Cc_checklistScalarFieldEnum | Cc_checklistScalarFieldEnum[]
  }

  /**
   * cc_checklist findFirstOrThrow
   */
  export type cc_checklistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cc_checklist
     */
    select?: cc_checklistSelect<ExtArgs> | null
    /**
     * Filter, which cc_checklist to fetch.
     */
    where?: cc_checklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cc_checklists to fetch.
     */
    orderBy?: cc_checklistOrderByWithRelationInput | cc_checklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cc_checklists.
     */
    cursor?: cc_checklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cc_checklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cc_checklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cc_checklists.
     */
    distinct?: Cc_checklistScalarFieldEnum | Cc_checklistScalarFieldEnum[]
  }

  /**
   * cc_checklist findMany
   */
  export type cc_checklistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cc_checklist
     */
    select?: cc_checklistSelect<ExtArgs> | null
    /**
     * Filter, which cc_checklists to fetch.
     */
    where?: cc_checklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cc_checklists to fetch.
     */
    orderBy?: cc_checklistOrderByWithRelationInput | cc_checklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cc_checklists.
     */
    cursor?: cc_checklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cc_checklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cc_checklists.
     */
    skip?: number
    distinct?: Cc_checklistScalarFieldEnum | Cc_checklistScalarFieldEnum[]
  }

  /**
   * cc_checklist create
   */
  export type cc_checklistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cc_checklist
     */
    select?: cc_checklistSelect<ExtArgs> | null
    /**
     * The data needed to create a cc_checklist.
     */
    data?: XOR<cc_checklistCreateInput, cc_checklistUncheckedCreateInput>
  }

  /**
   * cc_checklist createMany
   */
  export type cc_checklistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cc_checklists.
     */
    data: cc_checklistCreateManyInput | cc_checklistCreateManyInput[]
  }

  /**
   * cc_checklist update
   */
  export type cc_checklistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cc_checklist
     */
    select?: cc_checklistSelect<ExtArgs> | null
    /**
     * The data needed to update a cc_checklist.
     */
    data: XOR<cc_checklistUpdateInput, cc_checklistUncheckedUpdateInput>
    /**
     * Choose, which cc_checklist to update.
     */
    where: cc_checklistWhereUniqueInput
  }

  /**
   * cc_checklist updateMany
   */
  export type cc_checklistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cc_checklists.
     */
    data: XOR<cc_checklistUpdateManyMutationInput, cc_checklistUncheckedUpdateManyInput>
    /**
     * Filter which cc_checklists to update
     */
    where?: cc_checklistWhereInput
  }

  /**
   * cc_checklist upsert
   */
  export type cc_checklistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cc_checklist
     */
    select?: cc_checklistSelect<ExtArgs> | null
    /**
     * The filter to search for the cc_checklist to update in case it exists.
     */
    where: cc_checklistWhereUniqueInput
    /**
     * In case the cc_checklist found by the `where` argument doesn't exist, create a new cc_checklist with this data.
     */
    create: XOR<cc_checklistCreateInput, cc_checklistUncheckedCreateInput>
    /**
     * In case the cc_checklist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cc_checklistUpdateInput, cc_checklistUncheckedUpdateInput>
  }

  /**
   * cc_checklist delete
   */
  export type cc_checklistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cc_checklist
     */
    select?: cc_checklistSelect<ExtArgs> | null
    /**
     * Filter which cc_checklist to delete.
     */
    where: cc_checklistWhereUniqueInput
  }

  /**
   * cc_checklist deleteMany
   */
  export type cc_checklistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cc_checklists to delete
     */
    where?: cc_checklistWhereInput
  }

  /**
   * cc_checklist without action
   */
  export type cc_checklistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cc_checklist
     */
    select?: cc_checklistSelect<ExtArgs> | null
  }


  /**
   * Model certificacion
   */

  export type AggregateCertificacion = {
    _count: CertificacionCountAggregateOutputType | null
    _avg: CertificacionAvgAggregateOutputType | null
    _sum: CertificacionSumAggregateOutputType | null
    _min: CertificacionMinAggregateOutputType | null
    _max: CertificacionMaxAggregateOutputType | null
  }

  export type CertificacionAvgAggregateOutputType = {
    id: number | null
  }

  export type CertificacionSumAggregateOutputType = {
    id: number | null
  }

  export type CertificacionMinAggregateOutputType = {
    id: number | null
    exportadora: string | null
    productor: string | null
    ggn: string | null
    fecha_emision: Date | null
    fecha_caducidad: Date | null
    vigencia: string | null
    especie: string | null
    mercados: string | null
  }

  export type CertificacionMaxAggregateOutputType = {
    id: number | null
    exportadora: string | null
    productor: string | null
    ggn: string | null
    fecha_emision: Date | null
    fecha_caducidad: Date | null
    vigencia: string | null
    especie: string | null
    mercados: string | null
  }

  export type CertificacionCountAggregateOutputType = {
    id: number
    exportadora: number
    productor: number
    ggn: number
    fecha_emision: number
    fecha_caducidad: number
    vigencia: number
    especie: number
    mercados: number
    _all: number
  }


  export type CertificacionAvgAggregateInputType = {
    id?: true
  }

  export type CertificacionSumAggregateInputType = {
    id?: true
  }

  export type CertificacionMinAggregateInputType = {
    id?: true
    exportadora?: true
    productor?: true
    ggn?: true
    fecha_emision?: true
    fecha_caducidad?: true
    vigencia?: true
    especie?: true
    mercados?: true
  }

  export type CertificacionMaxAggregateInputType = {
    id?: true
    exportadora?: true
    productor?: true
    ggn?: true
    fecha_emision?: true
    fecha_caducidad?: true
    vigencia?: true
    especie?: true
    mercados?: true
  }

  export type CertificacionCountAggregateInputType = {
    id?: true
    exportadora?: true
    productor?: true
    ggn?: true
    fecha_emision?: true
    fecha_caducidad?: true
    vigencia?: true
    especie?: true
    mercados?: true
    _all?: true
  }

  export type CertificacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which certificacion to aggregate.
     */
    where?: certificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificacions to fetch.
     */
    orderBy?: certificacionOrderByWithRelationInput | certificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: certificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned certificacions
    **/
    _count?: true | CertificacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificacionMaxAggregateInputType
  }

  export type GetCertificacionAggregateType<T extends CertificacionAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificacion[P]>
      : GetScalarType<T[P], AggregateCertificacion[P]>
  }




  export type certificacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: certificacionWhereInput
    orderBy?: certificacionOrderByWithAggregationInput | certificacionOrderByWithAggregationInput[]
    by: CertificacionScalarFieldEnum[] | CertificacionScalarFieldEnum
    having?: certificacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificacionCountAggregateInputType | true
    _avg?: CertificacionAvgAggregateInputType
    _sum?: CertificacionSumAggregateInputType
    _min?: CertificacionMinAggregateInputType
    _max?: CertificacionMaxAggregateInputType
  }

  export type CertificacionGroupByOutputType = {
    id: number
    exportadora: string
    productor: string
    ggn: string
    fecha_emision: Date
    fecha_caducidad: Date
    vigencia: string
    especie: string
    mercados: string
    _count: CertificacionCountAggregateOutputType | null
    _avg: CertificacionAvgAggregateOutputType | null
    _sum: CertificacionSumAggregateOutputType | null
    _min: CertificacionMinAggregateOutputType | null
    _max: CertificacionMaxAggregateOutputType | null
  }

  type GetCertificacionGroupByPayload<T extends certificacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificacionGroupByOutputType[P]>
            : GetScalarType<T[P], CertificacionGroupByOutputType[P]>
        }
      >
    >


  export type certificacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exportadora?: boolean
    productor?: boolean
    ggn?: boolean
    fecha_emision?: boolean
    fecha_caducidad?: boolean
    vigencia?: boolean
    especie?: boolean
    mercados?: boolean
  }, ExtArgs["result"]["certificacion"]>


  export type certificacionSelectScalar = {
    id?: boolean
    exportadora?: boolean
    productor?: boolean
    ggn?: boolean
    fecha_emision?: boolean
    fecha_caducidad?: boolean
    vigencia?: boolean
    especie?: boolean
    mercados?: boolean
  }


  export type $certificacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "certificacion"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      exportadora: string
      productor: string
      ggn: string
      fecha_emision: Date
      fecha_caducidad: Date
      vigencia: string
      especie: string
      mercados: string
    }, ExtArgs["result"]["certificacion"]>
    composites: {}
  }

  type certificacionGetPayload<S extends boolean | null | undefined | certificacionDefaultArgs> = $Result.GetResult<Prisma.$certificacionPayload, S>

  type certificacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<certificacionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CertificacionCountAggregateInputType | true
    }

  export interface certificacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['certificacion'], meta: { name: 'certificacion' } }
    /**
     * Find zero or one Certificacion that matches the filter.
     * @param {certificacionFindUniqueArgs} args - Arguments to find a Certificacion
     * @example
     * // Get one Certificacion
     * const certificacion = await prisma.certificacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends certificacionFindUniqueArgs>(args: SelectSubset<T, certificacionFindUniqueArgs<ExtArgs>>): Prisma__certificacionClient<$Result.GetResult<Prisma.$certificacionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Certificacion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {certificacionFindUniqueOrThrowArgs} args - Arguments to find a Certificacion
     * @example
     * // Get one Certificacion
     * const certificacion = await prisma.certificacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends certificacionFindUniqueOrThrowArgs>(args: SelectSubset<T, certificacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__certificacionClient<$Result.GetResult<Prisma.$certificacionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Certificacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificacionFindFirstArgs} args - Arguments to find a Certificacion
     * @example
     * // Get one Certificacion
     * const certificacion = await prisma.certificacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends certificacionFindFirstArgs>(args?: SelectSubset<T, certificacionFindFirstArgs<ExtArgs>>): Prisma__certificacionClient<$Result.GetResult<Prisma.$certificacionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Certificacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificacionFindFirstOrThrowArgs} args - Arguments to find a Certificacion
     * @example
     * // Get one Certificacion
     * const certificacion = await prisma.certificacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends certificacionFindFirstOrThrowArgs>(args?: SelectSubset<T, certificacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__certificacionClient<$Result.GetResult<Prisma.$certificacionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Certificacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificacions
     * const certificacions = await prisma.certificacion.findMany()
     * 
     * // Get first 10 Certificacions
     * const certificacions = await prisma.certificacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificacionWithIdOnly = await prisma.certificacion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends certificacionFindManyArgs>(args?: SelectSubset<T, certificacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificacionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Certificacion.
     * @param {certificacionCreateArgs} args - Arguments to create a Certificacion.
     * @example
     * // Create one Certificacion
     * const Certificacion = await prisma.certificacion.create({
     *   data: {
     *     // ... data to create a Certificacion
     *   }
     * })
     * 
     */
    create<T extends certificacionCreateArgs>(args: SelectSubset<T, certificacionCreateArgs<ExtArgs>>): Prisma__certificacionClient<$Result.GetResult<Prisma.$certificacionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Certificacions.
     * @param {certificacionCreateManyArgs} args - Arguments to create many Certificacions.
     * @example
     * // Create many Certificacions
     * const certificacion = await prisma.certificacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends certificacionCreateManyArgs>(args?: SelectSubset<T, certificacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Certificacion.
     * @param {certificacionDeleteArgs} args - Arguments to delete one Certificacion.
     * @example
     * // Delete one Certificacion
     * const Certificacion = await prisma.certificacion.delete({
     *   where: {
     *     // ... filter to delete one Certificacion
     *   }
     * })
     * 
     */
    delete<T extends certificacionDeleteArgs>(args: SelectSubset<T, certificacionDeleteArgs<ExtArgs>>): Prisma__certificacionClient<$Result.GetResult<Prisma.$certificacionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Certificacion.
     * @param {certificacionUpdateArgs} args - Arguments to update one Certificacion.
     * @example
     * // Update one Certificacion
     * const certificacion = await prisma.certificacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends certificacionUpdateArgs>(args: SelectSubset<T, certificacionUpdateArgs<ExtArgs>>): Prisma__certificacionClient<$Result.GetResult<Prisma.$certificacionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Certificacions.
     * @param {certificacionDeleteManyArgs} args - Arguments to filter Certificacions to delete.
     * @example
     * // Delete a few Certificacions
     * const { count } = await prisma.certificacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends certificacionDeleteManyArgs>(args?: SelectSubset<T, certificacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificacions
     * const certificacion = await prisma.certificacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends certificacionUpdateManyArgs>(args: SelectSubset<T, certificacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Certificacion.
     * @param {certificacionUpsertArgs} args - Arguments to update or create a Certificacion.
     * @example
     * // Update or create a Certificacion
     * const certificacion = await prisma.certificacion.upsert({
     *   create: {
     *     // ... data to create a Certificacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificacion we want to update
     *   }
     * })
     */
    upsert<T extends certificacionUpsertArgs>(args: SelectSubset<T, certificacionUpsertArgs<ExtArgs>>): Prisma__certificacionClient<$Result.GetResult<Prisma.$certificacionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Certificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificacionCountArgs} args - Arguments to filter Certificacions to count.
     * @example
     * // Count the number of Certificacions
     * const count = await prisma.certificacion.count({
     *   where: {
     *     // ... the filter for the Certificacions we want to count
     *   }
     * })
    **/
    count<T extends certificacionCountArgs>(
      args?: Subset<T, certificacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificacionAggregateArgs>(args: Subset<T, CertificacionAggregateArgs>): Prisma.PrismaPromise<GetCertificacionAggregateType<T>>

    /**
     * Group by Certificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends certificacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: certificacionGroupByArgs['orderBy'] }
        : { orderBy?: certificacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, certificacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the certificacion model
   */
  readonly fields: certificacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for certificacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__certificacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the certificacion model
   */ 
  interface certificacionFieldRefs {
    readonly id: FieldRef<"certificacion", 'Int'>
    readonly exportadora: FieldRef<"certificacion", 'String'>
    readonly productor: FieldRef<"certificacion", 'String'>
    readonly ggn: FieldRef<"certificacion", 'String'>
    readonly fecha_emision: FieldRef<"certificacion", 'DateTime'>
    readonly fecha_caducidad: FieldRef<"certificacion", 'DateTime'>
    readonly vigencia: FieldRef<"certificacion", 'String'>
    readonly especie: FieldRef<"certificacion", 'String'>
    readonly mercados: FieldRef<"certificacion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * certificacion findUnique
   */
  export type certificacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificacion
     */
    select?: certificacionSelect<ExtArgs> | null
    /**
     * Filter, which certificacion to fetch.
     */
    where: certificacionWhereUniqueInput
  }

  /**
   * certificacion findUniqueOrThrow
   */
  export type certificacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificacion
     */
    select?: certificacionSelect<ExtArgs> | null
    /**
     * Filter, which certificacion to fetch.
     */
    where: certificacionWhereUniqueInput
  }

  /**
   * certificacion findFirst
   */
  export type certificacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificacion
     */
    select?: certificacionSelect<ExtArgs> | null
    /**
     * Filter, which certificacion to fetch.
     */
    where?: certificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificacions to fetch.
     */
    orderBy?: certificacionOrderByWithRelationInput | certificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certificacions.
     */
    cursor?: certificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certificacions.
     */
    distinct?: CertificacionScalarFieldEnum | CertificacionScalarFieldEnum[]
  }

  /**
   * certificacion findFirstOrThrow
   */
  export type certificacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificacion
     */
    select?: certificacionSelect<ExtArgs> | null
    /**
     * Filter, which certificacion to fetch.
     */
    where?: certificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificacions to fetch.
     */
    orderBy?: certificacionOrderByWithRelationInput | certificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certificacions.
     */
    cursor?: certificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certificacions.
     */
    distinct?: CertificacionScalarFieldEnum | CertificacionScalarFieldEnum[]
  }

  /**
   * certificacion findMany
   */
  export type certificacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificacion
     */
    select?: certificacionSelect<ExtArgs> | null
    /**
     * Filter, which certificacions to fetch.
     */
    where?: certificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificacions to fetch.
     */
    orderBy?: certificacionOrderByWithRelationInput | certificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing certificacions.
     */
    cursor?: certificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificacions.
     */
    skip?: number
    distinct?: CertificacionScalarFieldEnum | CertificacionScalarFieldEnum[]
  }

  /**
   * certificacion create
   */
  export type certificacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificacion
     */
    select?: certificacionSelect<ExtArgs> | null
    /**
     * The data needed to create a certificacion.
     */
    data: XOR<certificacionCreateInput, certificacionUncheckedCreateInput>
  }

  /**
   * certificacion createMany
   */
  export type certificacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many certificacions.
     */
    data: certificacionCreateManyInput | certificacionCreateManyInput[]
  }

  /**
   * certificacion update
   */
  export type certificacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificacion
     */
    select?: certificacionSelect<ExtArgs> | null
    /**
     * The data needed to update a certificacion.
     */
    data: XOR<certificacionUpdateInput, certificacionUncheckedUpdateInput>
    /**
     * Choose, which certificacion to update.
     */
    where: certificacionWhereUniqueInput
  }

  /**
   * certificacion updateMany
   */
  export type certificacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update certificacions.
     */
    data: XOR<certificacionUpdateManyMutationInput, certificacionUncheckedUpdateManyInput>
    /**
     * Filter which certificacions to update
     */
    where?: certificacionWhereInput
  }

  /**
   * certificacion upsert
   */
  export type certificacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificacion
     */
    select?: certificacionSelect<ExtArgs> | null
    /**
     * The filter to search for the certificacion to update in case it exists.
     */
    where: certificacionWhereUniqueInput
    /**
     * In case the certificacion found by the `where` argument doesn't exist, create a new certificacion with this data.
     */
    create: XOR<certificacionCreateInput, certificacionUncheckedCreateInput>
    /**
     * In case the certificacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<certificacionUpdateInput, certificacionUncheckedUpdateInput>
  }

  /**
   * certificacion delete
   */
  export type certificacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificacion
     */
    select?: certificacionSelect<ExtArgs> | null
    /**
     * Filter which certificacion to delete.
     */
    where: certificacionWhereUniqueInput
  }

  /**
   * certificacion deleteMany
   */
  export type certificacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which certificacions to delete
     */
    where?: certificacionWhereInput
  }

  /**
   * certificacion without action
   */
  export type certificacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificacion
     */
    select?: certificacionSelect<ExtArgs> | null
  }


  /**
   * Model correlativo
   */

  export type AggregateCorrelativo = {
    _count: CorrelativoCountAggregateOutputType | null
    _avg: CorrelativoAvgAggregateOutputType | null
    _sum: CorrelativoSumAggregateOutputType | null
    _min: CorrelativoMinAggregateOutputType | null
    _max: CorrelativoMaxAggregateOutputType | null
  }

  export type CorrelativoAvgAggregateOutputType = {
    id_cor: number | null
    id_tip_ins: number | null
    nro_sag: number | null
  }

  export type CorrelativoSumAggregateOutputType = {
    id_cor: number | null
    id_tip_ins: number | null
    nro_sag: number | null
  }

  export type CorrelativoMinAggregateOutputType = {
    id_cor: number | null
    id_tip_ins: number | null
    nro_sag: number | null
    cod_sdp: string | null
  }

  export type CorrelativoMaxAggregateOutputType = {
    id_cor: number | null
    id_tip_ins: number | null
    nro_sag: number | null
    cod_sdp: string | null
  }

  export type CorrelativoCountAggregateOutputType = {
    id_cor: number
    id_tip_ins: number
    nro_sag: number
    cod_sdp: number
    _all: number
  }


  export type CorrelativoAvgAggregateInputType = {
    id_cor?: true
    id_tip_ins?: true
    nro_sag?: true
  }

  export type CorrelativoSumAggregateInputType = {
    id_cor?: true
    id_tip_ins?: true
    nro_sag?: true
  }

  export type CorrelativoMinAggregateInputType = {
    id_cor?: true
    id_tip_ins?: true
    nro_sag?: true
    cod_sdp?: true
  }

  export type CorrelativoMaxAggregateInputType = {
    id_cor?: true
    id_tip_ins?: true
    nro_sag?: true
    cod_sdp?: true
  }

  export type CorrelativoCountAggregateInputType = {
    id_cor?: true
    id_tip_ins?: true
    nro_sag?: true
    cod_sdp?: true
    _all?: true
  }

  export type CorrelativoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which correlativo to aggregate.
     */
    where?: correlativoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of correlativos to fetch.
     */
    orderBy?: correlativoOrderByWithRelationInput | correlativoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: correlativoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` correlativos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` correlativos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned correlativos
    **/
    _count?: true | CorrelativoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CorrelativoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CorrelativoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CorrelativoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CorrelativoMaxAggregateInputType
  }

  export type GetCorrelativoAggregateType<T extends CorrelativoAggregateArgs> = {
        [P in keyof T & keyof AggregateCorrelativo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCorrelativo[P]>
      : GetScalarType<T[P], AggregateCorrelativo[P]>
  }




  export type correlativoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: correlativoWhereInput
    orderBy?: correlativoOrderByWithAggregationInput | correlativoOrderByWithAggregationInput[]
    by: CorrelativoScalarFieldEnum[] | CorrelativoScalarFieldEnum
    having?: correlativoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CorrelativoCountAggregateInputType | true
    _avg?: CorrelativoAvgAggregateInputType
    _sum?: CorrelativoSumAggregateInputType
    _min?: CorrelativoMinAggregateInputType
    _max?: CorrelativoMaxAggregateInputType
  }

  export type CorrelativoGroupByOutputType = {
    id_cor: number
    id_tip_ins: number | null
    nro_sag: number | null
    cod_sdp: string | null
    _count: CorrelativoCountAggregateOutputType | null
    _avg: CorrelativoAvgAggregateOutputType | null
    _sum: CorrelativoSumAggregateOutputType | null
    _min: CorrelativoMinAggregateOutputType | null
    _max: CorrelativoMaxAggregateOutputType | null
  }

  type GetCorrelativoGroupByPayload<T extends correlativoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CorrelativoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CorrelativoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CorrelativoGroupByOutputType[P]>
            : GetScalarType<T[P], CorrelativoGroupByOutputType[P]>
        }
      >
    >


  export type correlativoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_cor?: boolean
    id_tip_ins?: boolean
    nro_sag?: boolean
    cod_sdp?: boolean
  }, ExtArgs["result"]["correlativo"]>


  export type correlativoSelectScalar = {
    id_cor?: boolean
    id_tip_ins?: boolean
    nro_sag?: boolean
    cod_sdp?: boolean
  }


  export type $correlativoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "correlativo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_cor: number
      id_tip_ins: number | null
      nro_sag: number | null
      cod_sdp: string | null
    }, ExtArgs["result"]["correlativo"]>
    composites: {}
  }

  type correlativoGetPayload<S extends boolean | null | undefined | correlativoDefaultArgs> = $Result.GetResult<Prisma.$correlativoPayload, S>

  type correlativoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<correlativoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CorrelativoCountAggregateInputType | true
    }

  export interface correlativoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['correlativo'], meta: { name: 'correlativo' } }
    /**
     * Find zero or one Correlativo that matches the filter.
     * @param {correlativoFindUniqueArgs} args - Arguments to find a Correlativo
     * @example
     * // Get one Correlativo
     * const correlativo = await prisma.correlativo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends correlativoFindUniqueArgs>(args: SelectSubset<T, correlativoFindUniqueArgs<ExtArgs>>): Prisma__correlativoClient<$Result.GetResult<Prisma.$correlativoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Correlativo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {correlativoFindUniqueOrThrowArgs} args - Arguments to find a Correlativo
     * @example
     * // Get one Correlativo
     * const correlativo = await prisma.correlativo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends correlativoFindUniqueOrThrowArgs>(args: SelectSubset<T, correlativoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__correlativoClient<$Result.GetResult<Prisma.$correlativoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Correlativo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {correlativoFindFirstArgs} args - Arguments to find a Correlativo
     * @example
     * // Get one Correlativo
     * const correlativo = await prisma.correlativo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends correlativoFindFirstArgs>(args?: SelectSubset<T, correlativoFindFirstArgs<ExtArgs>>): Prisma__correlativoClient<$Result.GetResult<Prisma.$correlativoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Correlativo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {correlativoFindFirstOrThrowArgs} args - Arguments to find a Correlativo
     * @example
     * // Get one Correlativo
     * const correlativo = await prisma.correlativo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends correlativoFindFirstOrThrowArgs>(args?: SelectSubset<T, correlativoFindFirstOrThrowArgs<ExtArgs>>): Prisma__correlativoClient<$Result.GetResult<Prisma.$correlativoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Correlativos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {correlativoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Correlativos
     * const correlativos = await prisma.correlativo.findMany()
     * 
     * // Get first 10 Correlativos
     * const correlativos = await prisma.correlativo.findMany({ take: 10 })
     * 
     * // Only select the `id_cor`
     * const correlativoWithId_corOnly = await prisma.correlativo.findMany({ select: { id_cor: true } })
     * 
     */
    findMany<T extends correlativoFindManyArgs>(args?: SelectSubset<T, correlativoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$correlativoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Correlativo.
     * @param {correlativoCreateArgs} args - Arguments to create a Correlativo.
     * @example
     * // Create one Correlativo
     * const Correlativo = await prisma.correlativo.create({
     *   data: {
     *     // ... data to create a Correlativo
     *   }
     * })
     * 
     */
    create<T extends correlativoCreateArgs>(args: SelectSubset<T, correlativoCreateArgs<ExtArgs>>): Prisma__correlativoClient<$Result.GetResult<Prisma.$correlativoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Correlativos.
     * @param {correlativoCreateManyArgs} args - Arguments to create many Correlativos.
     * @example
     * // Create many Correlativos
     * const correlativo = await prisma.correlativo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends correlativoCreateManyArgs>(args?: SelectSubset<T, correlativoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Correlativo.
     * @param {correlativoDeleteArgs} args - Arguments to delete one Correlativo.
     * @example
     * // Delete one Correlativo
     * const Correlativo = await prisma.correlativo.delete({
     *   where: {
     *     // ... filter to delete one Correlativo
     *   }
     * })
     * 
     */
    delete<T extends correlativoDeleteArgs>(args: SelectSubset<T, correlativoDeleteArgs<ExtArgs>>): Prisma__correlativoClient<$Result.GetResult<Prisma.$correlativoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Correlativo.
     * @param {correlativoUpdateArgs} args - Arguments to update one Correlativo.
     * @example
     * // Update one Correlativo
     * const correlativo = await prisma.correlativo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends correlativoUpdateArgs>(args: SelectSubset<T, correlativoUpdateArgs<ExtArgs>>): Prisma__correlativoClient<$Result.GetResult<Prisma.$correlativoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Correlativos.
     * @param {correlativoDeleteManyArgs} args - Arguments to filter Correlativos to delete.
     * @example
     * // Delete a few Correlativos
     * const { count } = await prisma.correlativo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends correlativoDeleteManyArgs>(args?: SelectSubset<T, correlativoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Correlativos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {correlativoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Correlativos
     * const correlativo = await prisma.correlativo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends correlativoUpdateManyArgs>(args: SelectSubset<T, correlativoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Correlativo.
     * @param {correlativoUpsertArgs} args - Arguments to update or create a Correlativo.
     * @example
     * // Update or create a Correlativo
     * const correlativo = await prisma.correlativo.upsert({
     *   create: {
     *     // ... data to create a Correlativo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Correlativo we want to update
     *   }
     * })
     */
    upsert<T extends correlativoUpsertArgs>(args: SelectSubset<T, correlativoUpsertArgs<ExtArgs>>): Prisma__correlativoClient<$Result.GetResult<Prisma.$correlativoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Correlativos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {correlativoCountArgs} args - Arguments to filter Correlativos to count.
     * @example
     * // Count the number of Correlativos
     * const count = await prisma.correlativo.count({
     *   where: {
     *     // ... the filter for the Correlativos we want to count
     *   }
     * })
    **/
    count<T extends correlativoCountArgs>(
      args?: Subset<T, correlativoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CorrelativoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Correlativo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrelativoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CorrelativoAggregateArgs>(args: Subset<T, CorrelativoAggregateArgs>): Prisma.PrismaPromise<GetCorrelativoAggregateType<T>>

    /**
     * Group by Correlativo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {correlativoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends correlativoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: correlativoGroupByArgs['orderBy'] }
        : { orderBy?: correlativoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, correlativoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCorrelativoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the correlativo model
   */
  readonly fields: correlativoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for correlativo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__correlativoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the correlativo model
   */ 
  interface correlativoFieldRefs {
    readonly id_cor: FieldRef<"correlativo", 'Int'>
    readonly id_tip_ins: FieldRef<"correlativo", 'Int'>
    readonly nro_sag: FieldRef<"correlativo", 'Int'>
    readonly cod_sdp: FieldRef<"correlativo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * correlativo findUnique
   */
  export type correlativoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the correlativo
     */
    select?: correlativoSelect<ExtArgs> | null
    /**
     * Filter, which correlativo to fetch.
     */
    where: correlativoWhereUniqueInput
  }

  /**
   * correlativo findUniqueOrThrow
   */
  export type correlativoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the correlativo
     */
    select?: correlativoSelect<ExtArgs> | null
    /**
     * Filter, which correlativo to fetch.
     */
    where: correlativoWhereUniqueInput
  }

  /**
   * correlativo findFirst
   */
  export type correlativoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the correlativo
     */
    select?: correlativoSelect<ExtArgs> | null
    /**
     * Filter, which correlativo to fetch.
     */
    where?: correlativoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of correlativos to fetch.
     */
    orderBy?: correlativoOrderByWithRelationInput | correlativoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for correlativos.
     */
    cursor?: correlativoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` correlativos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` correlativos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of correlativos.
     */
    distinct?: CorrelativoScalarFieldEnum | CorrelativoScalarFieldEnum[]
  }

  /**
   * correlativo findFirstOrThrow
   */
  export type correlativoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the correlativo
     */
    select?: correlativoSelect<ExtArgs> | null
    /**
     * Filter, which correlativo to fetch.
     */
    where?: correlativoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of correlativos to fetch.
     */
    orderBy?: correlativoOrderByWithRelationInput | correlativoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for correlativos.
     */
    cursor?: correlativoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` correlativos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` correlativos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of correlativos.
     */
    distinct?: CorrelativoScalarFieldEnum | CorrelativoScalarFieldEnum[]
  }

  /**
   * correlativo findMany
   */
  export type correlativoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the correlativo
     */
    select?: correlativoSelect<ExtArgs> | null
    /**
     * Filter, which correlativos to fetch.
     */
    where?: correlativoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of correlativos to fetch.
     */
    orderBy?: correlativoOrderByWithRelationInput | correlativoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing correlativos.
     */
    cursor?: correlativoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` correlativos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` correlativos.
     */
    skip?: number
    distinct?: CorrelativoScalarFieldEnum | CorrelativoScalarFieldEnum[]
  }

  /**
   * correlativo create
   */
  export type correlativoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the correlativo
     */
    select?: correlativoSelect<ExtArgs> | null
    /**
     * The data needed to create a correlativo.
     */
    data?: XOR<correlativoCreateInput, correlativoUncheckedCreateInput>
  }

  /**
   * correlativo createMany
   */
  export type correlativoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many correlativos.
     */
    data: correlativoCreateManyInput | correlativoCreateManyInput[]
  }

  /**
   * correlativo update
   */
  export type correlativoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the correlativo
     */
    select?: correlativoSelect<ExtArgs> | null
    /**
     * The data needed to update a correlativo.
     */
    data: XOR<correlativoUpdateInput, correlativoUncheckedUpdateInput>
    /**
     * Choose, which correlativo to update.
     */
    where: correlativoWhereUniqueInput
  }

  /**
   * correlativo updateMany
   */
  export type correlativoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update correlativos.
     */
    data: XOR<correlativoUpdateManyMutationInput, correlativoUncheckedUpdateManyInput>
    /**
     * Filter which correlativos to update
     */
    where?: correlativoWhereInput
  }

  /**
   * correlativo upsert
   */
  export type correlativoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the correlativo
     */
    select?: correlativoSelect<ExtArgs> | null
    /**
     * The filter to search for the correlativo to update in case it exists.
     */
    where: correlativoWhereUniqueInput
    /**
     * In case the correlativo found by the `where` argument doesn't exist, create a new correlativo with this data.
     */
    create: XOR<correlativoCreateInput, correlativoUncheckedCreateInput>
    /**
     * In case the correlativo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<correlativoUpdateInput, correlativoUncheckedUpdateInput>
  }

  /**
   * correlativo delete
   */
  export type correlativoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the correlativo
     */
    select?: correlativoSelect<ExtArgs> | null
    /**
     * Filter which correlativo to delete.
     */
    where: correlativoWhereUniqueInput
  }

  /**
   * correlativo deleteMany
   */
  export type correlativoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which correlativos to delete
     */
    where?: correlativoWhereInput
  }

  /**
   * correlativo without action
   */
  export type correlativoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the correlativo
     */
    select?: correlativoSelect<ExtArgs> | null
  }


  /**
   * Model env_x_sellar
   */

  export type AggregateEnv_x_sellar = {
    _count: Env_x_sellarCountAggregateOutputType | null
    _avg: Env_x_sellarAvgAggregateOutputType | null
    _sum: Env_x_sellarSumAggregateOutputType | null
    _min: Env_x_sellarMinAggregateOutputType | null
    _max: Env_x_sellarMaxAggregateOutputType | null
  }

  export type Env_x_sellarAvgAggregateOutputType = {
    id: number | null
  }

  export type Env_x_sellarSumAggregateOutputType = {
    id: number | null
  }

  export type Env_x_sellarMinAggregateOutputType = {
    id: number | null
    cod_envop: string | null
    cod_esp: string | null
    cod_exp: string | null
  }

  export type Env_x_sellarMaxAggregateOutputType = {
    id: number | null
    cod_envop: string | null
    cod_esp: string | null
    cod_exp: string | null
  }

  export type Env_x_sellarCountAggregateOutputType = {
    id: number
    cod_envop: number
    cod_esp: number
    cod_exp: number
    _all: number
  }


  export type Env_x_sellarAvgAggregateInputType = {
    id?: true
  }

  export type Env_x_sellarSumAggregateInputType = {
    id?: true
  }

  export type Env_x_sellarMinAggregateInputType = {
    id?: true
    cod_envop?: true
    cod_esp?: true
    cod_exp?: true
  }

  export type Env_x_sellarMaxAggregateInputType = {
    id?: true
    cod_envop?: true
    cod_esp?: true
    cod_exp?: true
  }

  export type Env_x_sellarCountAggregateInputType = {
    id?: true
    cod_envop?: true
    cod_esp?: true
    cod_exp?: true
    _all?: true
  }

  export type Env_x_sellarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which env_x_sellar to aggregate.
     */
    where?: env_x_sellarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of env_x_sellars to fetch.
     */
    orderBy?: env_x_sellarOrderByWithRelationInput | env_x_sellarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: env_x_sellarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` env_x_sellars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` env_x_sellars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned env_x_sellars
    **/
    _count?: true | Env_x_sellarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Env_x_sellarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Env_x_sellarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Env_x_sellarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Env_x_sellarMaxAggregateInputType
  }

  export type GetEnv_x_sellarAggregateType<T extends Env_x_sellarAggregateArgs> = {
        [P in keyof T & keyof AggregateEnv_x_sellar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnv_x_sellar[P]>
      : GetScalarType<T[P], AggregateEnv_x_sellar[P]>
  }




  export type env_x_sellarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: env_x_sellarWhereInput
    orderBy?: env_x_sellarOrderByWithAggregationInput | env_x_sellarOrderByWithAggregationInput[]
    by: Env_x_sellarScalarFieldEnum[] | Env_x_sellarScalarFieldEnum
    having?: env_x_sellarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Env_x_sellarCountAggregateInputType | true
    _avg?: Env_x_sellarAvgAggregateInputType
    _sum?: Env_x_sellarSumAggregateInputType
    _min?: Env_x_sellarMinAggregateInputType
    _max?: Env_x_sellarMaxAggregateInputType
  }

  export type Env_x_sellarGroupByOutputType = {
    id: number
    cod_envop: string
    cod_esp: string
    cod_exp: string
    _count: Env_x_sellarCountAggregateOutputType | null
    _avg: Env_x_sellarAvgAggregateOutputType | null
    _sum: Env_x_sellarSumAggregateOutputType | null
    _min: Env_x_sellarMinAggregateOutputType | null
    _max: Env_x_sellarMaxAggregateOutputType | null
  }

  type GetEnv_x_sellarGroupByPayload<T extends env_x_sellarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Env_x_sellarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Env_x_sellarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Env_x_sellarGroupByOutputType[P]>
            : GetScalarType<T[P], Env_x_sellarGroupByOutputType[P]>
        }
      >
    >


  export type env_x_sellarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cod_envop?: boolean
    cod_esp?: boolean
    cod_exp?: boolean
  }, ExtArgs["result"]["env_x_sellar"]>


  export type env_x_sellarSelectScalar = {
    id?: boolean
    cod_envop?: boolean
    cod_esp?: boolean
    cod_exp?: boolean
  }


  export type $env_x_sellarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "env_x_sellar"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cod_envop: string
      cod_esp: string
      cod_exp: string
    }, ExtArgs["result"]["env_x_sellar"]>
    composites: {}
  }

  type env_x_sellarGetPayload<S extends boolean | null | undefined | env_x_sellarDefaultArgs> = $Result.GetResult<Prisma.$env_x_sellarPayload, S>

  type env_x_sellarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<env_x_sellarFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Env_x_sellarCountAggregateInputType | true
    }

  export interface env_x_sellarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['env_x_sellar'], meta: { name: 'env_x_sellar' } }
    /**
     * Find zero or one Env_x_sellar that matches the filter.
     * @param {env_x_sellarFindUniqueArgs} args - Arguments to find a Env_x_sellar
     * @example
     * // Get one Env_x_sellar
     * const env_x_sellar = await prisma.env_x_sellar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends env_x_sellarFindUniqueArgs>(args: SelectSubset<T, env_x_sellarFindUniqueArgs<ExtArgs>>): Prisma__env_x_sellarClient<$Result.GetResult<Prisma.$env_x_sellarPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Env_x_sellar that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {env_x_sellarFindUniqueOrThrowArgs} args - Arguments to find a Env_x_sellar
     * @example
     * // Get one Env_x_sellar
     * const env_x_sellar = await prisma.env_x_sellar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends env_x_sellarFindUniqueOrThrowArgs>(args: SelectSubset<T, env_x_sellarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__env_x_sellarClient<$Result.GetResult<Prisma.$env_x_sellarPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Env_x_sellar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {env_x_sellarFindFirstArgs} args - Arguments to find a Env_x_sellar
     * @example
     * // Get one Env_x_sellar
     * const env_x_sellar = await prisma.env_x_sellar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends env_x_sellarFindFirstArgs>(args?: SelectSubset<T, env_x_sellarFindFirstArgs<ExtArgs>>): Prisma__env_x_sellarClient<$Result.GetResult<Prisma.$env_x_sellarPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Env_x_sellar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {env_x_sellarFindFirstOrThrowArgs} args - Arguments to find a Env_x_sellar
     * @example
     * // Get one Env_x_sellar
     * const env_x_sellar = await prisma.env_x_sellar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends env_x_sellarFindFirstOrThrowArgs>(args?: SelectSubset<T, env_x_sellarFindFirstOrThrowArgs<ExtArgs>>): Prisma__env_x_sellarClient<$Result.GetResult<Prisma.$env_x_sellarPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Env_x_sellars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {env_x_sellarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Env_x_sellars
     * const env_x_sellars = await prisma.env_x_sellar.findMany()
     * 
     * // Get first 10 Env_x_sellars
     * const env_x_sellars = await prisma.env_x_sellar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const env_x_sellarWithIdOnly = await prisma.env_x_sellar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends env_x_sellarFindManyArgs>(args?: SelectSubset<T, env_x_sellarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$env_x_sellarPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Env_x_sellar.
     * @param {env_x_sellarCreateArgs} args - Arguments to create a Env_x_sellar.
     * @example
     * // Create one Env_x_sellar
     * const Env_x_sellar = await prisma.env_x_sellar.create({
     *   data: {
     *     // ... data to create a Env_x_sellar
     *   }
     * })
     * 
     */
    create<T extends env_x_sellarCreateArgs>(args: SelectSubset<T, env_x_sellarCreateArgs<ExtArgs>>): Prisma__env_x_sellarClient<$Result.GetResult<Prisma.$env_x_sellarPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Env_x_sellars.
     * @param {env_x_sellarCreateManyArgs} args - Arguments to create many Env_x_sellars.
     * @example
     * // Create many Env_x_sellars
     * const env_x_sellar = await prisma.env_x_sellar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends env_x_sellarCreateManyArgs>(args?: SelectSubset<T, env_x_sellarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Env_x_sellar.
     * @param {env_x_sellarDeleteArgs} args - Arguments to delete one Env_x_sellar.
     * @example
     * // Delete one Env_x_sellar
     * const Env_x_sellar = await prisma.env_x_sellar.delete({
     *   where: {
     *     // ... filter to delete one Env_x_sellar
     *   }
     * })
     * 
     */
    delete<T extends env_x_sellarDeleteArgs>(args: SelectSubset<T, env_x_sellarDeleteArgs<ExtArgs>>): Prisma__env_x_sellarClient<$Result.GetResult<Prisma.$env_x_sellarPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Env_x_sellar.
     * @param {env_x_sellarUpdateArgs} args - Arguments to update one Env_x_sellar.
     * @example
     * // Update one Env_x_sellar
     * const env_x_sellar = await prisma.env_x_sellar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends env_x_sellarUpdateArgs>(args: SelectSubset<T, env_x_sellarUpdateArgs<ExtArgs>>): Prisma__env_x_sellarClient<$Result.GetResult<Prisma.$env_x_sellarPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Env_x_sellars.
     * @param {env_x_sellarDeleteManyArgs} args - Arguments to filter Env_x_sellars to delete.
     * @example
     * // Delete a few Env_x_sellars
     * const { count } = await prisma.env_x_sellar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends env_x_sellarDeleteManyArgs>(args?: SelectSubset<T, env_x_sellarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Env_x_sellars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {env_x_sellarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Env_x_sellars
     * const env_x_sellar = await prisma.env_x_sellar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends env_x_sellarUpdateManyArgs>(args: SelectSubset<T, env_x_sellarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Env_x_sellar.
     * @param {env_x_sellarUpsertArgs} args - Arguments to update or create a Env_x_sellar.
     * @example
     * // Update or create a Env_x_sellar
     * const env_x_sellar = await prisma.env_x_sellar.upsert({
     *   create: {
     *     // ... data to create a Env_x_sellar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Env_x_sellar we want to update
     *   }
     * })
     */
    upsert<T extends env_x_sellarUpsertArgs>(args: SelectSubset<T, env_x_sellarUpsertArgs<ExtArgs>>): Prisma__env_x_sellarClient<$Result.GetResult<Prisma.$env_x_sellarPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Env_x_sellars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {env_x_sellarCountArgs} args - Arguments to filter Env_x_sellars to count.
     * @example
     * // Count the number of Env_x_sellars
     * const count = await prisma.env_x_sellar.count({
     *   where: {
     *     // ... the filter for the Env_x_sellars we want to count
     *   }
     * })
    **/
    count<T extends env_x_sellarCountArgs>(
      args?: Subset<T, env_x_sellarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Env_x_sellarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Env_x_sellar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Env_x_sellarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Env_x_sellarAggregateArgs>(args: Subset<T, Env_x_sellarAggregateArgs>): Prisma.PrismaPromise<GetEnv_x_sellarAggregateType<T>>

    /**
     * Group by Env_x_sellar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {env_x_sellarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends env_x_sellarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: env_x_sellarGroupByArgs['orderBy'] }
        : { orderBy?: env_x_sellarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, env_x_sellarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnv_x_sellarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the env_x_sellar model
   */
  readonly fields: env_x_sellarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for env_x_sellar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__env_x_sellarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the env_x_sellar model
   */ 
  interface env_x_sellarFieldRefs {
    readonly id: FieldRef<"env_x_sellar", 'Int'>
    readonly cod_envop: FieldRef<"env_x_sellar", 'String'>
    readonly cod_esp: FieldRef<"env_x_sellar", 'String'>
    readonly cod_exp: FieldRef<"env_x_sellar", 'String'>
  }
    

  // Custom InputTypes
  /**
   * env_x_sellar findUnique
   */
  export type env_x_sellarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_x_sellar
     */
    select?: env_x_sellarSelect<ExtArgs> | null
    /**
     * Filter, which env_x_sellar to fetch.
     */
    where: env_x_sellarWhereUniqueInput
  }

  /**
   * env_x_sellar findUniqueOrThrow
   */
  export type env_x_sellarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_x_sellar
     */
    select?: env_x_sellarSelect<ExtArgs> | null
    /**
     * Filter, which env_x_sellar to fetch.
     */
    where: env_x_sellarWhereUniqueInput
  }

  /**
   * env_x_sellar findFirst
   */
  export type env_x_sellarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_x_sellar
     */
    select?: env_x_sellarSelect<ExtArgs> | null
    /**
     * Filter, which env_x_sellar to fetch.
     */
    where?: env_x_sellarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of env_x_sellars to fetch.
     */
    orderBy?: env_x_sellarOrderByWithRelationInput | env_x_sellarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for env_x_sellars.
     */
    cursor?: env_x_sellarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` env_x_sellars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` env_x_sellars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of env_x_sellars.
     */
    distinct?: Env_x_sellarScalarFieldEnum | Env_x_sellarScalarFieldEnum[]
  }

  /**
   * env_x_sellar findFirstOrThrow
   */
  export type env_x_sellarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_x_sellar
     */
    select?: env_x_sellarSelect<ExtArgs> | null
    /**
     * Filter, which env_x_sellar to fetch.
     */
    where?: env_x_sellarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of env_x_sellars to fetch.
     */
    orderBy?: env_x_sellarOrderByWithRelationInput | env_x_sellarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for env_x_sellars.
     */
    cursor?: env_x_sellarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` env_x_sellars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` env_x_sellars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of env_x_sellars.
     */
    distinct?: Env_x_sellarScalarFieldEnum | Env_x_sellarScalarFieldEnum[]
  }

  /**
   * env_x_sellar findMany
   */
  export type env_x_sellarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_x_sellar
     */
    select?: env_x_sellarSelect<ExtArgs> | null
    /**
     * Filter, which env_x_sellars to fetch.
     */
    where?: env_x_sellarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of env_x_sellars to fetch.
     */
    orderBy?: env_x_sellarOrderByWithRelationInput | env_x_sellarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing env_x_sellars.
     */
    cursor?: env_x_sellarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` env_x_sellars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` env_x_sellars.
     */
    skip?: number
    distinct?: Env_x_sellarScalarFieldEnum | Env_x_sellarScalarFieldEnum[]
  }

  /**
   * env_x_sellar create
   */
  export type env_x_sellarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_x_sellar
     */
    select?: env_x_sellarSelect<ExtArgs> | null
    /**
     * The data needed to create a env_x_sellar.
     */
    data: XOR<env_x_sellarCreateInput, env_x_sellarUncheckedCreateInput>
  }

  /**
   * env_x_sellar createMany
   */
  export type env_x_sellarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many env_x_sellars.
     */
    data: env_x_sellarCreateManyInput | env_x_sellarCreateManyInput[]
  }

  /**
   * env_x_sellar update
   */
  export type env_x_sellarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_x_sellar
     */
    select?: env_x_sellarSelect<ExtArgs> | null
    /**
     * The data needed to update a env_x_sellar.
     */
    data: XOR<env_x_sellarUpdateInput, env_x_sellarUncheckedUpdateInput>
    /**
     * Choose, which env_x_sellar to update.
     */
    where: env_x_sellarWhereUniqueInput
  }

  /**
   * env_x_sellar updateMany
   */
  export type env_x_sellarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update env_x_sellars.
     */
    data: XOR<env_x_sellarUpdateManyMutationInput, env_x_sellarUncheckedUpdateManyInput>
    /**
     * Filter which env_x_sellars to update
     */
    where?: env_x_sellarWhereInput
  }

  /**
   * env_x_sellar upsert
   */
  export type env_x_sellarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_x_sellar
     */
    select?: env_x_sellarSelect<ExtArgs> | null
    /**
     * The filter to search for the env_x_sellar to update in case it exists.
     */
    where: env_x_sellarWhereUniqueInput
    /**
     * In case the env_x_sellar found by the `where` argument doesn't exist, create a new env_x_sellar with this data.
     */
    create: XOR<env_x_sellarCreateInput, env_x_sellarUncheckedCreateInput>
    /**
     * In case the env_x_sellar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<env_x_sellarUpdateInput, env_x_sellarUncheckedUpdateInput>
  }

  /**
   * env_x_sellar delete
   */
  export type env_x_sellarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_x_sellar
     */
    select?: env_x_sellarSelect<ExtArgs> | null
    /**
     * Filter which env_x_sellar to delete.
     */
    where: env_x_sellarWhereUniqueInput
  }

  /**
   * env_x_sellar deleteMany
   */
  export type env_x_sellarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which env_x_sellars to delete
     */
    where?: env_x_sellarWhereInput
  }

  /**
   * env_x_sellar without action
   */
  export type env_x_sellarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_x_sellar
     */
    select?: env_x_sellarSelect<ExtArgs> | null
  }


  /**
   * Model estados
   */

  export type AggregateEstados = {
    _count: EstadosCountAggregateOutputType | null
    _avg: EstadosAvgAggregateOutputType | null
    _sum: EstadosSumAggregateOutputType | null
    _min: EstadosMinAggregateOutputType | null
    _max: EstadosMaxAggregateOutputType | null
  }

  export type EstadosAvgAggregateOutputType = {
    id_est_ins: number | null
    id_tip_ins: number | null
  }

  export type EstadosSumAggregateOutputType = {
    id_est_ins: number | null
    id_tip_ins: number | null
  }

  export type EstadosMinAggregateOutputType = {
    id_est_ins: number | null
    des_est_ins: string | null
    tip_sdt: string | null
    id_tip_ins: number | null
  }

  export type EstadosMaxAggregateOutputType = {
    id_est_ins: number | null
    des_est_ins: string | null
    tip_sdt: string | null
    id_tip_ins: number | null
  }

  export type EstadosCountAggregateOutputType = {
    id_est_ins: number
    des_est_ins: number
    tip_sdt: number
    id_tip_ins: number
    _all: number
  }


  export type EstadosAvgAggregateInputType = {
    id_est_ins?: true
    id_tip_ins?: true
  }

  export type EstadosSumAggregateInputType = {
    id_est_ins?: true
    id_tip_ins?: true
  }

  export type EstadosMinAggregateInputType = {
    id_est_ins?: true
    des_est_ins?: true
    tip_sdt?: true
    id_tip_ins?: true
  }

  export type EstadosMaxAggregateInputType = {
    id_est_ins?: true
    des_est_ins?: true
    tip_sdt?: true
    id_tip_ins?: true
  }

  export type EstadosCountAggregateInputType = {
    id_est_ins?: true
    des_est_ins?: true
    tip_sdt?: true
    id_tip_ins?: true
    _all?: true
  }

  export type EstadosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estados to aggregate.
     */
    where?: estadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estados to fetch.
     */
    orderBy?: estadosOrderByWithRelationInput | estadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: estadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned estados
    **/
    _count?: true | EstadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstadosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstadosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstadosMaxAggregateInputType
  }

  export type GetEstadosAggregateType<T extends EstadosAggregateArgs> = {
        [P in keyof T & keyof AggregateEstados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstados[P]>
      : GetScalarType<T[P], AggregateEstados[P]>
  }




  export type estadosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estadosWhereInput
    orderBy?: estadosOrderByWithAggregationInput | estadosOrderByWithAggregationInput[]
    by: EstadosScalarFieldEnum[] | EstadosScalarFieldEnum
    having?: estadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstadosCountAggregateInputType | true
    _avg?: EstadosAvgAggregateInputType
    _sum?: EstadosSumAggregateInputType
    _min?: EstadosMinAggregateInputType
    _max?: EstadosMaxAggregateInputType
  }

  export type EstadosGroupByOutputType = {
    id_est_ins: number
    des_est_ins: string | null
    tip_sdt: string | null
    id_tip_ins: number | null
    _count: EstadosCountAggregateOutputType | null
    _avg: EstadosAvgAggregateOutputType | null
    _sum: EstadosSumAggregateOutputType | null
    _min: EstadosMinAggregateOutputType | null
    _max: EstadosMaxAggregateOutputType | null
  }

  type GetEstadosGroupByPayload<T extends estadosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstadosGroupByOutputType[P]>
            : GetScalarType<T[P], EstadosGroupByOutputType[P]>
        }
      >
    >


  export type estadosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_est_ins?: boolean
    des_est_ins?: boolean
    tip_sdt?: boolean
    id_tip_ins?: boolean
  }, ExtArgs["result"]["estados"]>


  export type estadosSelectScalar = {
    id_est_ins?: boolean
    des_est_ins?: boolean
    tip_sdt?: boolean
    id_tip_ins?: boolean
  }


  export type $estadosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "estados"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_est_ins: number
      des_est_ins: string | null
      tip_sdt: string | null
      id_tip_ins: number | null
    }, ExtArgs["result"]["estados"]>
    composites: {}
  }

  type estadosGetPayload<S extends boolean | null | undefined | estadosDefaultArgs> = $Result.GetResult<Prisma.$estadosPayload, S>

  type estadosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<estadosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EstadosCountAggregateInputType | true
    }

  export interface estadosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['estados'], meta: { name: 'estados' } }
    /**
     * Find zero or one Estados that matches the filter.
     * @param {estadosFindUniqueArgs} args - Arguments to find a Estados
     * @example
     * // Get one Estados
     * const estados = await prisma.estados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends estadosFindUniqueArgs>(args: SelectSubset<T, estadosFindUniqueArgs<ExtArgs>>): Prisma__estadosClient<$Result.GetResult<Prisma.$estadosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Estados that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {estadosFindUniqueOrThrowArgs} args - Arguments to find a Estados
     * @example
     * // Get one Estados
     * const estados = await prisma.estados.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends estadosFindUniqueOrThrowArgs>(args: SelectSubset<T, estadosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__estadosClient<$Result.GetResult<Prisma.$estadosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Estados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadosFindFirstArgs} args - Arguments to find a Estados
     * @example
     * // Get one Estados
     * const estados = await prisma.estados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends estadosFindFirstArgs>(args?: SelectSubset<T, estadosFindFirstArgs<ExtArgs>>): Prisma__estadosClient<$Result.GetResult<Prisma.$estadosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Estados that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadosFindFirstOrThrowArgs} args - Arguments to find a Estados
     * @example
     * // Get one Estados
     * const estados = await prisma.estados.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends estadosFindFirstOrThrowArgs>(args?: SelectSubset<T, estadosFindFirstOrThrowArgs<ExtArgs>>): Prisma__estadosClient<$Result.GetResult<Prisma.$estadosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Estados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estados
     * const estados = await prisma.estados.findMany()
     * 
     * // Get first 10 Estados
     * const estados = await prisma.estados.findMany({ take: 10 })
     * 
     * // Only select the `id_est_ins`
     * const estadosWithId_est_insOnly = await prisma.estados.findMany({ select: { id_est_ins: true } })
     * 
     */
    findMany<T extends estadosFindManyArgs>(args?: SelectSubset<T, estadosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estadosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Estados.
     * @param {estadosCreateArgs} args - Arguments to create a Estados.
     * @example
     * // Create one Estados
     * const Estados = await prisma.estados.create({
     *   data: {
     *     // ... data to create a Estados
     *   }
     * })
     * 
     */
    create<T extends estadosCreateArgs>(args: SelectSubset<T, estadosCreateArgs<ExtArgs>>): Prisma__estadosClient<$Result.GetResult<Prisma.$estadosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Estados.
     * @param {estadosCreateManyArgs} args - Arguments to create many Estados.
     * @example
     * // Create many Estados
     * const estados = await prisma.estados.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends estadosCreateManyArgs>(args?: SelectSubset<T, estadosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Estados.
     * @param {estadosDeleteArgs} args - Arguments to delete one Estados.
     * @example
     * // Delete one Estados
     * const Estados = await prisma.estados.delete({
     *   where: {
     *     // ... filter to delete one Estados
     *   }
     * })
     * 
     */
    delete<T extends estadosDeleteArgs>(args: SelectSubset<T, estadosDeleteArgs<ExtArgs>>): Prisma__estadosClient<$Result.GetResult<Prisma.$estadosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Estados.
     * @param {estadosUpdateArgs} args - Arguments to update one Estados.
     * @example
     * // Update one Estados
     * const estados = await prisma.estados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends estadosUpdateArgs>(args: SelectSubset<T, estadosUpdateArgs<ExtArgs>>): Prisma__estadosClient<$Result.GetResult<Prisma.$estadosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Estados.
     * @param {estadosDeleteManyArgs} args - Arguments to filter Estados to delete.
     * @example
     * // Delete a few Estados
     * const { count } = await prisma.estados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends estadosDeleteManyArgs>(args?: SelectSubset<T, estadosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estados
     * const estados = await prisma.estados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends estadosUpdateManyArgs>(args: SelectSubset<T, estadosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Estados.
     * @param {estadosUpsertArgs} args - Arguments to update or create a Estados.
     * @example
     * // Update or create a Estados
     * const estados = await prisma.estados.upsert({
     *   create: {
     *     // ... data to create a Estados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estados we want to update
     *   }
     * })
     */
    upsert<T extends estadosUpsertArgs>(args: SelectSubset<T, estadosUpsertArgs<ExtArgs>>): Prisma__estadosClient<$Result.GetResult<Prisma.$estadosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Estados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadosCountArgs} args - Arguments to filter Estados to count.
     * @example
     * // Count the number of Estados
     * const count = await prisma.estados.count({
     *   where: {
     *     // ... the filter for the Estados we want to count
     *   }
     * })
    **/
    count<T extends estadosCountArgs>(
      args?: Subset<T, estadosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstadosAggregateArgs>(args: Subset<T, EstadosAggregateArgs>): Prisma.PrismaPromise<GetEstadosAggregateType<T>>

    /**
     * Group by Estados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends estadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: estadosGroupByArgs['orderBy'] }
        : { orderBy?: estadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, estadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstadosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the estados model
   */
  readonly fields: estadosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for estados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__estadosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the estados model
   */ 
  interface estadosFieldRefs {
    readonly id_est_ins: FieldRef<"estados", 'Int'>
    readonly des_est_ins: FieldRef<"estados", 'String'>
    readonly tip_sdt: FieldRef<"estados", 'String'>
    readonly id_tip_ins: FieldRef<"estados", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * estados findUnique
   */
  export type estadosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
    /**
     * Filter, which estados to fetch.
     */
    where: estadosWhereUniqueInput
  }

  /**
   * estados findUniqueOrThrow
   */
  export type estadosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
    /**
     * Filter, which estados to fetch.
     */
    where: estadosWhereUniqueInput
  }

  /**
   * estados findFirst
   */
  export type estadosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
    /**
     * Filter, which estados to fetch.
     */
    where?: estadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estados to fetch.
     */
    orderBy?: estadosOrderByWithRelationInput | estadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estados.
     */
    cursor?: estadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estados.
     */
    distinct?: EstadosScalarFieldEnum | EstadosScalarFieldEnum[]
  }

  /**
   * estados findFirstOrThrow
   */
  export type estadosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
    /**
     * Filter, which estados to fetch.
     */
    where?: estadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estados to fetch.
     */
    orderBy?: estadosOrderByWithRelationInput | estadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estados.
     */
    cursor?: estadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estados.
     */
    distinct?: EstadosScalarFieldEnum | EstadosScalarFieldEnum[]
  }

  /**
   * estados findMany
   */
  export type estadosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
    /**
     * Filter, which estados to fetch.
     */
    where?: estadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estados to fetch.
     */
    orderBy?: estadosOrderByWithRelationInput | estadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing estados.
     */
    cursor?: estadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estados.
     */
    skip?: number
    distinct?: EstadosScalarFieldEnum | EstadosScalarFieldEnum[]
  }

  /**
   * estados create
   */
  export type estadosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
    /**
     * The data needed to create a estados.
     */
    data?: XOR<estadosCreateInput, estadosUncheckedCreateInput>
  }

  /**
   * estados createMany
   */
  export type estadosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many estados.
     */
    data: estadosCreateManyInput | estadosCreateManyInput[]
  }

  /**
   * estados update
   */
  export type estadosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
    /**
     * The data needed to update a estados.
     */
    data: XOR<estadosUpdateInput, estadosUncheckedUpdateInput>
    /**
     * Choose, which estados to update.
     */
    where: estadosWhereUniqueInput
  }

  /**
   * estados updateMany
   */
  export type estadosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update estados.
     */
    data: XOR<estadosUpdateManyMutationInput, estadosUncheckedUpdateManyInput>
    /**
     * Filter which estados to update
     */
    where?: estadosWhereInput
  }

  /**
   * estados upsert
   */
  export type estadosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
    /**
     * The filter to search for the estados to update in case it exists.
     */
    where: estadosWhereUniqueInput
    /**
     * In case the estados found by the `where` argument doesn't exist, create a new estados with this data.
     */
    create: XOR<estadosCreateInput, estadosUncheckedCreateInput>
    /**
     * In case the estados was found with the provided `where` argument, update it with this data.
     */
    update: XOR<estadosUpdateInput, estadosUncheckedUpdateInput>
  }

  /**
   * estados delete
   */
  export type estadosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
    /**
     * Filter which estados to delete.
     */
    where: estadosWhereUniqueInput
  }

  /**
   * estados deleteMany
   */
  export type estadosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estados to delete
     */
    where?: estadosWhereInput
  }

  /**
   * estados without action
   */
  export type estadosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
  }


  /**
   * Model folios
   */

  export type AggregateFolios = {
    _count: FoliosCountAggregateOutputType | null
    _avg: FoliosAvgAggregateOutputType | null
    _sum: FoliosSumAggregateOutputType | null
    _min: FoliosMinAggregateOutputType | null
    _max: FoliosMaxAggregateOutputType | null
  }

  export type FoliosAvgAggregateOutputType = {
    cajas: number | null
  }

  export type FoliosSumAggregateOutputType = {
    cajas: number | null
  }

  export type FoliosMinAggregateOutputType = {
    folio: string | null
    nom_var: string | null
    cod_var: string | null
    cajas: number | null
    fecha: Date | null
    calibre: string | null
    embalaje: string | null
  }

  export type FoliosMaxAggregateOutputType = {
    folio: string | null
    nom_var: string | null
    cod_var: string | null
    cajas: number | null
    fecha: Date | null
    calibre: string | null
    embalaje: string | null
  }

  export type FoliosCountAggregateOutputType = {
    folio: number
    nom_var: number
    cod_var: number
    cajas: number
    fecha: number
    calibre: number
    embalaje: number
    _all: number
  }


  export type FoliosAvgAggregateInputType = {
    cajas?: true
  }

  export type FoliosSumAggregateInputType = {
    cajas?: true
  }

  export type FoliosMinAggregateInputType = {
    folio?: true
    nom_var?: true
    cod_var?: true
    cajas?: true
    fecha?: true
    calibre?: true
    embalaje?: true
  }

  export type FoliosMaxAggregateInputType = {
    folio?: true
    nom_var?: true
    cod_var?: true
    cajas?: true
    fecha?: true
    calibre?: true
    embalaje?: true
  }

  export type FoliosCountAggregateInputType = {
    folio?: true
    nom_var?: true
    cod_var?: true
    cajas?: true
    fecha?: true
    calibre?: true
    embalaje?: true
    _all?: true
  }

  export type FoliosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which folios to aggregate.
     */
    where?: foliosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of folios to fetch.
     */
    orderBy?: foliosOrderByWithRelationInput | foliosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: foliosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` folios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` folios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned folios
    **/
    _count?: true | FoliosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoliosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoliosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoliosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoliosMaxAggregateInputType
  }

  export type GetFoliosAggregateType<T extends FoliosAggregateArgs> = {
        [P in keyof T & keyof AggregateFolios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFolios[P]>
      : GetScalarType<T[P], AggregateFolios[P]>
  }




  export type foliosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: foliosWhereInput
    orderBy?: foliosOrderByWithAggregationInput | foliosOrderByWithAggregationInput[]
    by: FoliosScalarFieldEnum[] | FoliosScalarFieldEnum
    having?: foliosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoliosCountAggregateInputType | true
    _avg?: FoliosAvgAggregateInputType
    _sum?: FoliosSumAggregateInputType
    _min?: FoliosMinAggregateInputType
    _max?: FoliosMaxAggregateInputType
  }

  export type FoliosGroupByOutputType = {
    folio: string
    nom_var: string | null
    cod_var: string | null
    cajas: number | null
    fecha: Date | null
    calibre: string | null
    embalaje: string | null
    _count: FoliosCountAggregateOutputType | null
    _avg: FoliosAvgAggregateOutputType | null
    _sum: FoliosSumAggregateOutputType | null
    _min: FoliosMinAggregateOutputType | null
    _max: FoliosMaxAggregateOutputType | null
  }

  type GetFoliosGroupByPayload<T extends foliosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoliosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoliosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoliosGroupByOutputType[P]>
            : GetScalarType<T[P], FoliosGroupByOutputType[P]>
        }
      >
    >


  export type foliosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    folio?: boolean
    nom_var?: boolean
    cod_var?: boolean
    cajas?: boolean
    fecha?: boolean
    calibre?: boolean
    embalaje?: boolean
  }, ExtArgs["result"]["folios"]>


  export type foliosSelectScalar = {
    folio?: boolean
    nom_var?: boolean
    cod_var?: boolean
    cajas?: boolean
    fecha?: boolean
    calibre?: boolean
    embalaje?: boolean
  }


  export type $foliosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "folios"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      folio: string
      nom_var: string | null
      cod_var: string | null
      cajas: number | null
      fecha: Date | null
      calibre: string | null
      embalaje: string | null
    }, ExtArgs["result"]["folios"]>
    composites: {}
  }

  type foliosGetPayload<S extends boolean | null | undefined | foliosDefaultArgs> = $Result.GetResult<Prisma.$foliosPayload, S>

  type foliosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<foliosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FoliosCountAggregateInputType | true
    }

  export interface foliosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['folios'], meta: { name: 'folios' } }
    /**
     * Find zero or one Folios that matches the filter.
     * @param {foliosFindUniqueArgs} args - Arguments to find a Folios
     * @example
     * // Get one Folios
     * const folios = await prisma.folios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends foliosFindUniqueArgs>(args: SelectSubset<T, foliosFindUniqueArgs<ExtArgs>>): Prisma__foliosClient<$Result.GetResult<Prisma.$foliosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Folios that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {foliosFindUniqueOrThrowArgs} args - Arguments to find a Folios
     * @example
     * // Get one Folios
     * const folios = await prisma.folios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends foliosFindUniqueOrThrowArgs>(args: SelectSubset<T, foliosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__foliosClient<$Result.GetResult<Prisma.$foliosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Folios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foliosFindFirstArgs} args - Arguments to find a Folios
     * @example
     * // Get one Folios
     * const folios = await prisma.folios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends foliosFindFirstArgs>(args?: SelectSubset<T, foliosFindFirstArgs<ExtArgs>>): Prisma__foliosClient<$Result.GetResult<Prisma.$foliosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Folios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foliosFindFirstOrThrowArgs} args - Arguments to find a Folios
     * @example
     * // Get one Folios
     * const folios = await prisma.folios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends foliosFindFirstOrThrowArgs>(args?: SelectSubset<T, foliosFindFirstOrThrowArgs<ExtArgs>>): Prisma__foliosClient<$Result.GetResult<Prisma.$foliosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Folios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foliosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Folios
     * const folios = await prisma.folios.findMany()
     * 
     * // Get first 10 Folios
     * const folios = await prisma.folios.findMany({ take: 10 })
     * 
     * // Only select the `folio`
     * const foliosWithFolioOnly = await prisma.folios.findMany({ select: { folio: true } })
     * 
     */
    findMany<T extends foliosFindManyArgs>(args?: SelectSubset<T, foliosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$foliosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Folios.
     * @param {foliosCreateArgs} args - Arguments to create a Folios.
     * @example
     * // Create one Folios
     * const Folios = await prisma.folios.create({
     *   data: {
     *     // ... data to create a Folios
     *   }
     * })
     * 
     */
    create<T extends foliosCreateArgs>(args: SelectSubset<T, foliosCreateArgs<ExtArgs>>): Prisma__foliosClient<$Result.GetResult<Prisma.$foliosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Folios.
     * @param {foliosCreateManyArgs} args - Arguments to create many Folios.
     * @example
     * // Create many Folios
     * const folios = await prisma.folios.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends foliosCreateManyArgs>(args?: SelectSubset<T, foliosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Folios.
     * @param {foliosDeleteArgs} args - Arguments to delete one Folios.
     * @example
     * // Delete one Folios
     * const Folios = await prisma.folios.delete({
     *   where: {
     *     // ... filter to delete one Folios
     *   }
     * })
     * 
     */
    delete<T extends foliosDeleteArgs>(args: SelectSubset<T, foliosDeleteArgs<ExtArgs>>): Prisma__foliosClient<$Result.GetResult<Prisma.$foliosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Folios.
     * @param {foliosUpdateArgs} args - Arguments to update one Folios.
     * @example
     * // Update one Folios
     * const folios = await prisma.folios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends foliosUpdateArgs>(args: SelectSubset<T, foliosUpdateArgs<ExtArgs>>): Prisma__foliosClient<$Result.GetResult<Prisma.$foliosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Folios.
     * @param {foliosDeleteManyArgs} args - Arguments to filter Folios to delete.
     * @example
     * // Delete a few Folios
     * const { count } = await prisma.folios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends foliosDeleteManyArgs>(args?: SelectSubset<T, foliosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foliosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Folios
     * const folios = await prisma.folios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends foliosUpdateManyArgs>(args: SelectSubset<T, foliosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Folios.
     * @param {foliosUpsertArgs} args - Arguments to update or create a Folios.
     * @example
     * // Update or create a Folios
     * const folios = await prisma.folios.upsert({
     *   create: {
     *     // ... data to create a Folios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Folios we want to update
     *   }
     * })
     */
    upsert<T extends foliosUpsertArgs>(args: SelectSubset<T, foliosUpsertArgs<ExtArgs>>): Prisma__foliosClient<$Result.GetResult<Prisma.$foliosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Folios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foliosCountArgs} args - Arguments to filter Folios to count.
     * @example
     * // Count the number of Folios
     * const count = await prisma.folios.count({
     *   where: {
     *     // ... the filter for the Folios we want to count
     *   }
     * })
    **/
    count<T extends foliosCountArgs>(
      args?: Subset<T, foliosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoliosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Folios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoliosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoliosAggregateArgs>(args: Subset<T, FoliosAggregateArgs>): Prisma.PrismaPromise<GetFoliosAggregateType<T>>

    /**
     * Group by Folios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foliosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends foliosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: foliosGroupByArgs['orderBy'] }
        : { orderBy?: foliosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, foliosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoliosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the folios model
   */
  readonly fields: foliosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for folios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__foliosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the folios model
   */ 
  interface foliosFieldRefs {
    readonly folio: FieldRef<"folios", 'String'>
    readonly nom_var: FieldRef<"folios", 'String'>
    readonly cod_var: FieldRef<"folios", 'String'>
    readonly cajas: FieldRef<"folios", 'Int'>
    readonly fecha: FieldRef<"folios", 'DateTime'>
    readonly calibre: FieldRef<"folios", 'String'>
    readonly embalaje: FieldRef<"folios", 'String'>
  }
    

  // Custom InputTypes
  /**
   * folios findUnique
   */
  export type foliosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios
     */
    select?: foliosSelect<ExtArgs> | null
    /**
     * Filter, which folios to fetch.
     */
    where: foliosWhereUniqueInput
  }

  /**
   * folios findUniqueOrThrow
   */
  export type foliosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios
     */
    select?: foliosSelect<ExtArgs> | null
    /**
     * Filter, which folios to fetch.
     */
    where: foliosWhereUniqueInput
  }

  /**
   * folios findFirst
   */
  export type foliosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios
     */
    select?: foliosSelect<ExtArgs> | null
    /**
     * Filter, which folios to fetch.
     */
    where?: foliosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of folios to fetch.
     */
    orderBy?: foliosOrderByWithRelationInput | foliosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for folios.
     */
    cursor?: foliosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` folios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` folios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of folios.
     */
    distinct?: FoliosScalarFieldEnum | FoliosScalarFieldEnum[]
  }

  /**
   * folios findFirstOrThrow
   */
  export type foliosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios
     */
    select?: foliosSelect<ExtArgs> | null
    /**
     * Filter, which folios to fetch.
     */
    where?: foliosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of folios to fetch.
     */
    orderBy?: foliosOrderByWithRelationInput | foliosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for folios.
     */
    cursor?: foliosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` folios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` folios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of folios.
     */
    distinct?: FoliosScalarFieldEnum | FoliosScalarFieldEnum[]
  }

  /**
   * folios findMany
   */
  export type foliosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios
     */
    select?: foliosSelect<ExtArgs> | null
    /**
     * Filter, which folios to fetch.
     */
    where?: foliosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of folios to fetch.
     */
    orderBy?: foliosOrderByWithRelationInput | foliosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing folios.
     */
    cursor?: foliosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` folios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` folios.
     */
    skip?: number
    distinct?: FoliosScalarFieldEnum | FoliosScalarFieldEnum[]
  }

  /**
   * folios create
   */
  export type foliosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios
     */
    select?: foliosSelect<ExtArgs> | null
    /**
     * The data needed to create a folios.
     */
    data: XOR<foliosCreateInput, foliosUncheckedCreateInput>
  }

  /**
   * folios createMany
   */
  export type foliosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many folios.
     */
    data: foliosCreateManyInput | foliosCreateManyInput[]
  }

  /**
   * folios update
   */
  export type foliosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios
     */
    select?: foliosSelect<ExtArgs> | null
    /**
     * The data needed to update a folios.
     */
    data: XOR<foliosUpdateInput, foliosUncheckedUpdateInput>
    /**
     * Choose, which folios to update.
     */
    where: foliosWhereUniqueInput
  }

  /**
   * folios updateMany
   */
  export type foliosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update folios.
     */
    data: XOR<foliosUpdateManyMutationInput, foliosUncheckedUpdateManyInput>
    /**
     * Filter which folios to update
     */
    where?: foliosWhereInput
  }

  /**
   * folios upsert
   */
  export type foliosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios
     */
    select?: foliosSelect<ExtArgs> | null
    /**
     * The filter to search for the folios to update in case it exists.
     */
    where: foliosWhereUniqueInput
    /**
     * In case the folios found by the `where` argument doesn't exist, create a new folios with this data.
     */
    create: XOR<foliosCreateInput, foliosUncheckedCreateInput>
    /**
     * In case the folios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<foliosUpdateInput, foliosUncheckedUpdateInput>
  }

  /**
   * folios delete
   */
  export type foliosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios
     */
    select?: foliosSelect<ExtArgs> | null
    /**
     * Filter which folios to delete.
     */
    where: foliosWhereUniqueInput
  }

  /**
   * folios deleteMany
   */
  export type foliosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which folios to delete
     */
    where?: foliosWhereInput
  }

  /**
   * folios without action
   */
  export type foliosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios
     */
    select?: foliosSelect<ExtArgs> | null
  }


  /**
   * Model folios_frio
   */

  export type AggregateFolios_frio = {
    _count: Folios_frioCountAggregateOutputType | null
    _avg: Folios_frioAvgAggregateOutputType | null
    _sum: Folios_frioSumAggregateOutputType | null
    _min: Folios_frioMinAggregateOutputType | null
    _max: Folios_frioMaxAggregateOutputType | null
  }

  export type Folios_frioAvgAggregateOutputType = {
    cajas: number | null
  }

  export type Folios_frioSumAggregateOutputType = {
    cajas: number | null
  }

  export type Folios_frioMinAggregateOutputType = {
    folio: string | null
    nom_var: string | null
    cod_var: string | null
    cajas: number | null
    fecha: Date | null
    calibre: string | null
    embalaje: string | null
  }

  export type Folios_frioMaxAggregateOutputType = {
    folio: string | null
    nom_var: string | null
    cod_var: string | null
    cajas: number | null
    fecha: Date | null
    calibre: string | null
    embalaje: string | null
  }

  export type Folios_frioCountAggregateOutputType = {
    folio: number
    nom_var: number
    cod_var: number
    cajas: number
    fecha: number
    calibre: number
    embalaje: number
    _all: number
  }


  export type Folios_frioAvgAggregateInputType = {
    cajas?: true
  }

  export type Folios_frioSumAggregateInputType = {
    cajas?: true
  }

  export type Folios_frioMinAggregateInputType = {
    folio?: true
    nom_var?: true
    cod_var?: true
    cajas?: true
    fecha?: true
    calibre?: true
    embalaje?: true
  }

  export type Folios_frioMaxAggregateInputType = {
    folio?: true
    nom_var?: true
    cod_var?: true
    cajas?: true
    fecha?: true
    calibre?: true
    embalaje?: true
  }

  export type Folios_frioCountAggregateInputType = {
    folio?: true
    nom_var?: true
    cod_var?: true
    cajas?: true
    fecha?: true
    calibre?: true
    embalaje?: true
    _all?: true
  }

  export type Folios_frioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which folios_frio to aggregate.
     */
    where?: folios_frioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of folios_frios to fetch.
     */
    orderBy?: folios_frioOrderByWithRelationInput | folios_frioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: folios_frioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` folios_frios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` folios_frios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned folios_frios
    **/
    _count?: true | Folios_frioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Folios_frioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Folios_frioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Folios_frioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Folios_frioMaxAggregateInputType
  }

  export type GetFolios_frioAggregateType<T extends Folios_frioAggregateArgs> = {
        [P in keyof T & keyof AggregateFolios_frio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFolios_frio[P]>
      : GetScalarType<T[P], AggregateFolios_frio[P]>
  }




  export type folios_frioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: folios_frioWhereInput
    orderBy?: folios_frioOrderByWithAggregationInput | folios_frioOrderByWithAggregationInput[]
    by: Folios_frioScalarFieldEnum[] | Folios_frioScalarFieldEnum
    having?: folios_frioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Folios_frioCountAggregateInputType | true
    _avg?: Folios_frioAvgAggregateInputType
    _sum?: Folios_frioSumAggregateInputType
    _min?: Folios_frioMinAggregateInputType
    _max?: Folios_frioMaxAggregateInputType
  }

  export type Folios_frioGroupByOutputType = {
    folio: string
    nom_var: string | null
    cod_var: string | null
    cajas: number | null
    fecha: Date | null
    calibre: string | null
    embalaje: string | null
    _count: Folios_frioCountAggregateOutputType | null
    _avg: Folios_frioAvgAggregateOutputType | null
    _sum: Folios_frioSumAggregateOutputType | null
    _min: Folios_frioMinAggregateOutputType | null
    _max: Folios_frioMaxAggregateOutputType | null
  }

  type GetFolios_frioGroupByPayload<T extends folios_frioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Folios_frioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Folios_frioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Folios_frioGroupByOutputType[P]>
            : GetScalarType<T[P], Folios_frioGroupByOutputType[P]>
        }
      >
    >


  export type folios_frioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    folio?: boolean
    nom_var?: boolean
    cod_var?: boolean
    cajas?: boolean
    fecha?: boolean
    calibre?: boolean
    embalaje?: boolean
  }, ExtArgs["result"]["folios_frio"]>


  export type folios_frioSelectScalar = {
    folio?: boolean
    nom_var?: boolean
    cod_var?: boolean
    cajas?: boolean
    fecha?: boolean
    calibre?: boolean
    embalaje?: boolean
  }


  export type $folios_frioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "folios_frio"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      folio: string
      nom_var: string | null
      cod_var: string | null
      cajas: number | null
      fecha: Date | null
      calibre: string | null
      embalaje: string | null
    }, ExtArgs["result"]["folios_frio"]>
    composites: {}
  }

  type folios_frioGetPayload<S extends boolean | null | undefined | folios_frioDefaultArgs> = $Result.GetResult<Prisma.$folios_frioPayload, S>

  type folios_frioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<folios_frioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Folios_frioCountAggregateInputType | true
    }

  export interface folios_frioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['folios_frio'], meta: { name: 'folios_frio' } }
    /**
     * Find zero or one Folios_frio that matches the filter.
     * @param {folios_frioFindUniqueArgs} args - Arguments to find a Folios_frio
     * @example
     * // Get one Folios_frio
     * const folios_frio = await prisma.folios_frio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends folios_frioFindUniqueArgs>(args: SelectSubset<T, folios_frioFindUniqueArgs<ExtArgs>>): Prisma__folios_frioClient<$Result.GetResult<Prisma.$folios_frioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Folios_frio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {folios_frioFindUniqueOrThrowArgs} args - Arguments to find a Folios_frio
     * @example
     * // Get one Folios_frio
     * const folios_frio = await prisma.folios_frio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends folios_frioFindUniqueOrThrowArgs>(args: SelectSubset<T, folios_frioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__folios_frioClient<$Result.GetResult<Prisma.$folios_frioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Folios_frio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {folios_frioFindFirstArgs} args - Arguments to find a Folios_frio
     * @example
     * // Get one Folios_frio
     * const folios_frio = await prisma.folios_frio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends folios_frioFindFirstArgs>(args?: SelectSubset<T, folios_frioFindFirstArgs<ExtArgs>>): Prisma__folios_frioClient<$Result.GetResult<Prisma.$folios_frioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Folios_frio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {folios_frioFindFirstOrThrowArgs} args - Arguments to find a Folios_frio
     * @example
     * // Get one Folios_frio
     * const folios_frio = await prisma.folios_frio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends folios_frioFindFirstOrThrowArgs>(args?: SelectSubset<T, folios_frioFindFirstOrThrowArgs<ExtArgs>>): Prisma__folios_frioClient<$Result.GetResult<Prisma.$folios_frioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Folios_frios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {folios_frioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Folios_frios
     * const folios_frios = await prisma.folios_frio.findMany()
     * 
     * // Get first 10 Folios_frios
     * const folios_frios = await prisma.folios_frio.findMany({ take: 10 })
     * 
     * // Only select the `folio`
     * const folios_frioWithFolioOnly = await prisma.folios_frio.findMany({ select: { folio: true } })
     * 
     */
    findMany<T extends folios_frioFindManyArgs>(args?: SelectSubset<T, folios_frioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$folios_frioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Folios_frio.
     * @param {folios_frioCreateArgs} args - Arguments to create a Folios_frio.
     * @example
     * // Create one Folios_frio
     * const Folios_frio = await prisma.folios_frio.create({
     *   data: {
     *     // ... data to create a Folios_frio
     *   }
     * })
     * 
     */
    create<T extends folios_frioCreateArgs>(args: SelectSubset<T, folios_frioCreateArgs<ExtArgs>>): Prisma__folios_frioClient<$Result.GetResult<Prisma.$folios_frioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Folios_frios.
     * @param {folios_frioCreateManyArgs} args - Arguments to create many Folios_frios.
     * @example
     * // Create many Folios_frios
     * const folios_frio = await prisma.folios_frio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends folios_frioCreateManyArgs>(args?: SelectSubset<T, folios_frioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Folios_frio.
     * @param {folios_frioDeleteArgs} args - Arguments to delete one Folios_frio.
     * @example
     * // Delete one Folios_frio
     * const Folios_frio = await prisma.folios_frio.delete({
     *   where: {
     *     // ... filter to delete one Folios_frio
     *   }
     * })
     * 
     */
    delete<T extends folios_frioDeleteArgs>(args: SelectSubset<T, folios_frioDeleteArgs<ExtArgs>>): Prisma__folios_frioClient<$Result.GetResult<Prisma.$folios_frioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Folios_frio.
     * @param {folios_frioUpdateArgs} args - Arguments to update one Folios_frio.
     * @example
     * // Update one Folios_frio
     * const folios_frio = await prisma.folios_frio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends folios_frioUpdateArgs>(args: SelectSubset<T, folios_frioUpdateArgs<ExtArgs>>): Prisma__folios_frioClient<$Result.GetResult<Prisma.$folios_frioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Folios_frios.
     * @param {folios_frioDeleteManyArgs} args - Arguments to filter Folios_frios to delete.
     * @example
     * // Delete a few Folios_frios
     * const { count } = await prisma.folios_frio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends folios_frioDeleteManyArgs>(args?: SelectSubset<T, folios_frioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folios_frios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {folios_frioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Folios_frios
     * const folios_frio = await prisma.folios_frio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends folios_frioUpdateManyArgs>(args: SelectSubset<T, folios_frioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Folios_frio.
     * @param {folios_frioUpsertArgs} args - Arguments to update or create a Folios_frio.
     * @example
     * // Update or create a Folios_frio
     * const folios_frio = await prisma.folios_frio.upsert({
     *   create: {
     *     // ... data to create a Folios_frio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Folios_frio we want to update
     *   }
     * })
     */
    upsert<T extends folios_frioUpsertArgs>(args: SelectSubset<T, folios_frioUpsertArgs<ExtArgs>>): Prisma__folios_frioClient<$Result.GetResult<Prisma.$folios_frioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Folios_frios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {folios_frioCountArgs} args - Arguments to filter Folios_frios to count.
     * @example
     * // Count the number of Folios_frios
     * const count = await prisma.folios_frio.count({
     *   where: {
     *     // ... the filter for the Folios_frios we want to count
     *   }
     * })
    **/
    count<T extends folios_frioCountArgs>(
      args?: Subset<T, folios_frioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Folios_frioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Folios_frio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Folios_frioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Folios_frioAggregateArgs>(args: Subset<T, Folios_frioAggregateArgs>): Prisma.PrismaPromise<GetFolios_frioAggregateType<T>>

    /**
     * Group by Folios_frio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {folios_frioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends folios_frioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: folios_frioGroupByArgs['orderBy'] }
        : { orderBy?: folios_frioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, folios_frioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFolios_frioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the folios_frio model
   */
  readonly fields: folios_frioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for folios_frio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__folios_frioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the folios_frio model
   */ 
  interface folios_frioFieldRefs {
    readonly folio: FieldRef<"folios_frio", 'String'>
    readonly nom_var: FieldRef<"folios_frio", 'String'>
    readonly cod_var: FieldRef<"folios_frio", 'String'>
    readonly cajas: FieldRef<"folios_frio", 'Int'>
    readonly fecha: FieldRef<"folios_frio", 'DateTime'>
    readonly calibre: FieldRef<"folios_frio", 'String'>
    readonly embalaje: FieldRef<"folios_frio", 'String'>
  }
    

  // Custom InputTypes
  /**
   * folios_frio findUnique
   */
  export type folios_frioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_frio
     */
    select?: folios_frioSelect<ExtArgs> | null
    /**
     * Filter, which folios_frio to fetch.
     */
    where: folios_frioWhereUniqueInput
  }

  /**
   * folios_frio findUniqueOrThrow
   */
  export type folios_frioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_frio
     */
    select?: folios_frioSelect<ExtArgs> | null
    /**
     * Filter, which folios_frio to fetch.
     */
    where: folios_frioWhereUniqueInput
  }

  /**
   * folios_frio findFirst
   */
  export type folios_frioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_frio
     */
    select?: folios_frioSelect<ExtArgs> | null
    /**
     * Filter, which folios_frio to fetch.
     */
    where?: folios_frioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of folios_frios to fetch.
     */
    orderBy?: folios_frioOrderByWithRelationInput | folios_frioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for folios_frios.
     */
    cursor?: folios_frioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` folios_frios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` folios_frios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of folios_frios.
     */
    distinct?: Folios_frioScalarFieldEnum | Folios_frioScalarFieldEnum[]
  }

  /**
   * folios_frio findFirstOrThrow
   */
  export type folios_frioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_frio
     */
    select?: folios_frioSelect<ExtArgs> | null
    /**
     * Filter, which folios_frio to fetch.
     */
    where?: folios_frioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of folios_frios to fetch.
     */
    orderBy?: folios_frioOrderByWithRelationInput | folios_frioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for folios_frios.
     */
    cursor?: folios_frioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` folios_frios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` folios_frios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of folios_frios.
     */
    distinct?: Folios_frioScalarFieldEnum | Folios_frioScalarFieldEnum[]
  }

  /**
   * folios_frio findMany
   */
  export type folios_frioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_frio
     */
    select?: folios_frioSelect<ExtArgs> | null
    /**
     * Filter, which folios_frios to fetch.
     */
    where?: folios_frioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of folios_frios to fetch.
     */
    orderBy?: folios_frioOrderByWithRelationInput | folios_frioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing folios_frios.
     */
    cursor?: folios_frioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` folios_frios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` folios_frios.
     */
    skip?: number
    distinct?: Folios_frioScalarFieldEnum | Folios_frioScalarFieldEnum[]
  }

  /**
   * folios_frio create
   */
  export type folios_frioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_frio
     */
    select?: folios_frioSelect<ExtArgs> | null
    /**
     * The data needed to create a folios_frio.
     */
    data: XOR<folios_frioCreateInput, folios_frioUncheckedCreateInput>
  }

  /**
   * folios_frio createMany
   */
  export type folios_frioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many folios_frios.
     */
    data: folios_frioCreateManyInput | folios_frioCreateManyInput[]
  }

  /**
   * folios_frio update
   */
  export type folios_frioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_frio
     */
    select?: folios_frioSelect<ExtArgs> | null
    /**
     * The data needed to update a folios_frio.
     */
    data: XOR<folios_frioUpdateInput, folios_frioUncheckedUpdateInput>
    /**
     * Choose, which folios_frio to update.
     */
    where: folios_frioWhereUniqueInput
  }

  /**
   * folios_frio updateMany
   */
  export type folios_frioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update folios_frios.
     */
    data: XOR<folios_frioUpdateManyMutationInput, folios_frioUncheckedUpdateManyInput>
    /**
     * Filter which folios_frios to update
     */
    where?: folios_frioWhereInput
  }

  /**
   * folios_frio upsert
   */
  export type folios_frioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_frio
     */
    select?: folios_frioSelect<ExtArgs> | null
    /**
     * The filter to search for the folios_frio to update in case it exists.
     */
    where: folios_frioWhereUniqueInput
    /**
     * In case the folios_frio found by the `where` argument doesn't exist, create a new folios_frio with this data.
     */
    create: XOR<folios_frioCreateInput, folios_frioUncheckedCreateInput>
    /**
     * In case the folios_frio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<folios_frioUpdateInput, folios_frioUncheckedUpdateInput>
  }

  /**
   * folios_frio delete
   */
  export type folios_frioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_frio
     */
    select?: folios_frioSelect<ExtArgs> | null
    /**
     * Filter which folios_frio to delete.
     */
    where: folios_frioWhereUniqueInput
  }

  /**
   * folios_frio deleteMany
   */
  export type folios_frioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which folios_frios to delete
     */
    where?: folios_frioWhereInput
  }

  /**
   * folios_frio without action
   */
  export type folios_frioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_frio
     */
    select?: folios_frioSelect<ExtArgs> | null
  }


  /**
   * Model folios_pack
   */

  export type AggregateFolios_pack = {
    _count: Folios_packCountAggregateOutputType | null
    _avg: Folios_packAvgAggregateOutputType | null
    _sum: Folios_packSumAggregateOutputType | null
    _min: Folios_packMinAggregateOutputType | null
    _max: Folios_packMaxAggregateOutputType | null
  }

  export type Folios_packAvgAggregateOutputType = {
    cajas: number | null
  }

  export type Folios_packSumAggregateOutputType = {
    cajas: number | null
  }

  export type Folios_packMinAggregateOutputType = {
    folio: string | null
    nom_var: string | null
    cod_var: string | null
    cajas: number | null
    fecha: Date | null
    calibre: string | null
    embalaje: string | null
  }

  export type Folios_packMaxAggregateOutputType = {
    folio: string | null
    nom_var: string | null
    cod_var: string | null
    cajas: number | null
    fecha: Date | null
    calibre: string | null
    embalaje: string | null
  }

  export type Folios_packCountAggregateOutputType = {
    folio: number
    nom_var: number
    cod_var: number
    cajas: number
    fecha: number
    calibre: number
    embalaje: number
    _all: number
  }


  export type Folios_packAvgAggregateInputType = {
    cajas?: true
  }

  export type Folios_packSumAggregateInputType = {
    cajas?: true
  }

  export type Folios_packMinAggregateInputType = {
    folio?: true
    nom_var?: true
    cod_var?: true
    cajas?: true
    fecha?: true
    calibre?: true
    embalaje?: true
  }

  export type Folios_packMaxAggregateInputType = {
    folio?: true
    nom_var?: true
    cod_var?: true
    cajas?: true
    fecha?: true
    calibre?: true
    embalaje?: true
  }

  export type Folios_packCountAggregateInputType = {
    folio?: true
    nom_var?: true
    cod_var?: true
    cajas?: true
    fecha?: true
    calibre?: true
    embalaje?: true
    _all?: true
  }

  export type Folios_packAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which folios_pack to aggregate.
     */
    where?: folios_packWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of folios_packs to fetch.
     */
    orderBy?: folios_packOrderByWithRelationInput | folios_packOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: folios_packWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` folios_packs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` folios_packs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned folios_packs
    **/
    _count?: true | Folios_packCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Folios_packAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Folios_packSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Folios_packMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Folios_packMaxAggregateInputType
  }

  export type GetFolios_packAggregateType<T extends Folios_packAggregateArgs> = {
        [P in keyof T & keyof AggregateFolios_pack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFolios_pack[P]>
      : GetScalarType<T[P], AggregateFolios_pack[P]>
  }




  export type folios_packGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: folios_packWhereInput
    orderBy?: folios_packOrderByWithAggregationInput | folios_packOrderByWithAggregationInput[]
    by: Folios_packScalarFieldEnum[] | Folios_packScalarFieldEnum
    having?: folios_packScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Folios_packCountAggregateInputType | true
    _avg?: Folios_packAvgAggregateInputType
    _sum?: Folios_packSumAggregateInputType
    _min?: Folios_packMinAggregateInputType
    _max?: Folios_packMaxAggregateInputType
  }

  export type Folios_packGroupByOutputType = {
    folio: string
    nom_var: string | null
    cod_var: string | null
    cajas: number | null
    fecha: Date | null
    calibre: string | null
    embalaje: string | null
    _count: Folios_packCountAggregateOutputType | null
    _avg: Folios_packAvgAggregateOutputType | null
    _sum: Folios_packSumAggregateOutputType | null
    _min: Folios_packMinAggregateOutputType | null
    _max: Folios_packMaxAggregateOutputType | null
  }

  type GetFolios_packGroupByPayload<T extends folios_packGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Folios_packGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Folios_packGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Folios_packGroupByOutputType[P]>
            : GetScalarType<T[P], Folios_packGroupByOutputType[P]>
        }
      >
    >


  export type folios_packSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    folio?: boolean
    nom_var?: boolean
    cod_var?: boolean
    cajas?: boolean
    fecha?: boolean
    calibre?: boolean
    embalaje?: boolean
  }, ExtArgs["result"]["folios_pack"]>


  export type folios_packSelectScalar = {
    folio?: boolean
    nom_var?: boolean
    cod_var?: boolean
    cajas?: boolean
    fecha?: boolean
    calibre?: boolean
    embalaje?: boolean
  }


  export type $folios_packPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "folios_pack"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      folio: string
      nom_var: string | null
      cod_var: string | null
      cajas: number | null
      fecha: Date | null
      calibre: string | null
      embalaje: string | null
    }, ExtArgs["result"]["folios_pack"]>
    composites: {}
  }

  type folios_packGetPayload<S extends boolean | null | undefined | folios_packDefaultArgs> = $Result.GetResult<Prisma.$folios_packPayload, S>

  type folios_packCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<folios_packFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Folios_packCountAggregateInputType | true
    }

  export interface folios_packDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['folios_pack'], meta: { name: 'folios_pack' } }
    /**
     * Find zero or one Folios_pack that matches the filter.
     * @param {folios_packFindUniqueArgs} args - Arguments to find a Folios_pack
     * @example
     * // Get one Folios_pack
     * const folios_pack = await prisma.folios_pack.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends folios_packFindUniqueArgs>(args: SelectSubset<T, folios_packFindUniqueArgs<ExtArgs>>): Prisma__folios_packClient<$Result.GetResult<Prisma.$folios_packPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Folios_pack that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {folios_packFindUniqueOrThrowArgs} args - Arguments to find a Folios_pack
     * @example
     * // Get one Folios_pack
     * const folios_pack = await prisma.folios_pack.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends folios_packFindUniqueOrThrowArgs>(args: SelectSubset<T, folios_packFindUniqueOrThrowArgs<ExtArgs>>): Prisma__folios_packClient<$Result.GetResult<Prisma.$folios_packPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Folios_pack that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {folios_packFindFirstArgs} args - Arguments to find a Folios_pack
     * @example
     * // Get one Folios_pack
     * const folios_pack = await prisma.folios_pack.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends folios_packFindFirstArgs>(args?: SelectSubset<T, folios_packFindFirstArgs<ExtArgs>>): Prisma__folios_packClient<$Result.GetResult<Prisma.$folios_packPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Folios_pack that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {folios_packFindFirstOrThrowArgs} args - Arguments to find a Folios_pack
     * @example
     * // Get one Folios_pack
     * const folios_pack = await prisma.folios_pack.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends folios_packFindFirstOrThrowArgs>(args?: SelectSubset<T, folios_packFindFirstOrThrowArgs<ExtArgs>>): Prisma__folios_packClient<$Result.GetResult<Prisma.$folios_packPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Folios_packs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {folios_packFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Folios_packs
     * const folios_packs = await prisma.folios_pack.findMany()
     * 
     * // Get first 10 Folios_packs
     * const folios_packs = await prisma.folios_pack.findMany({ take: 10 })
     * 
     * // Only select the `folio`
     * const folios_packWithFolioOnly = await prisma.folios_pack.findMany({ select: { folio: true } })
     * 
     */
    findMany<T extends folios_packFindManyArgs>(args?: SelectSubset<T, folios_packFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$folios_packPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Folios_pack.
     * @param {folios_packCreateArgs} args - Arguments to create a Folios_pack.
     * @example
     * // Create one Folios_pack
     * const Folios_pack = await prisma.folios_pack.create({
     *   data: {
     *     // ... data to create a Folios_pack
     *   }
     * })
     * 
     */
    create<T extends folios_packCreateArgs>(args: SelectSubset<T, folios_packCreateArgs<ExtArgs>>): Prisma__folios_packClient<$Result.GetResult<Prisma.$folios_packPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Folios_packs.
     * @param {folios_packCreateManyArgs} args - Arguments to create many Folios_packs.
     * @example
     * // Create many Folios_packs
     * const folios_pack = await prisma.folios_pack.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends folios_packCreateManyArgs>(args?: SelectSubset<T, folios_packCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Folios_pack.
     * @param {folios_packDeleteArgs} args - Arguments to delete one Folios_pack.
     * @example
     * // Delete one Folios_pack
     * const Folios_pack = await prisma.folios_pack.delete({
     *   where: {
     *     // ... filter to delete one Folios_pack
     *   }
     * })
     * 
     */
    delete<T extends folios_packDeleteArgs>(args: SelectSubset<T, folios_packDeleteArgs<ExtArgs>>): Prisma__folios_packClient<$Result.GetResult<Prisma.$folios_packPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Folios_pack.
     * @param {folios_packUpdateArgs} args - Arguments to update one Folios_pack.
     * @example
     * // Update one Folios_pack
     * const folios_pack = await prisma.folios_pack.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends folios_packUpdateArgs>(args: SelectSubset<T, folios_packUpdateArgs<ExtArgs>>): Prisma__folios_packClient<$Result.GetResult<Prisma.$folios_packPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Folios_packs.
     * @param {folios_packDeleteManyArgs} args - Arguments to filter Folios_packs to delete.
     * @example
     * // Delete a few Folios_packs
     * const { count } = await prisma.folios_pack.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends folios_packDeleteManyArgs>(args?: SelectSubset<T, folios_packDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folios_packs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {folios_packUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Folios_packs
     * const folios_pack = await prisma.folios_pack.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends folios_packUpdateManyArgs>(args: SelectSubset<T, folios_packUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Folios_pack.
     * @param {folios_packUpsertArgs} args - Arguments to update or create a Folios_pack.
     * @example
     * // Update or create a Folios_pack
     * const folios_pack = await prisma.folios_pack.upsert({
     *   create: {
     *     // ... data to create a Folios_pack
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Folios_pack we want to update
     *   }
     * })
     */
    upsert<T extends folios_packUpsertArgs>(args: SelectSubset<T, folios_packUpsertArgs<ExtArgs>>): Prisma__folios_packClient<$Result.GetResult<Prisma.$folios_packPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Folios_packs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {folios_packCountArgs} args - Arguments to filter Folios_packs to count.
     * @example
     * // Count the number of Folios_packs
     * const count = await prisma.folios_pack.count({
     *   where: {
     *     // ... the filter for the Folios_packs we want to count
     *   }
     * })
    **/
    count<T extends folios_packCountArgs>(
      args?: Subset<T, folios_packCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Folios_packCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Folios_pack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Folios_packAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Folios_packAggregateArgs>(args: Subset<T, Folios_packAggregateArgs>): Prisma.PrismaPromise<GetFolios_packAggregateType<T>>

    /**
     * Group by Folios_pack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {folios_packGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends folios_packGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: folios_packGroupByArgs['orderBy'] }
        : { orderBy?: folios_packGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, folios_packGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFolios_packGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the folios_pack model
   */
  readonly fields: folios_packFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for folios_pack.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__folios_packClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the folios_pack model
   */ 
  interface folios_packFieldRefs {
    readonly folio: FieldRef<"folios_pack", 'String'>
    readonly nom_var: FieldRef<"folios_pack", 'String'>
    readonly cod_var: FieldRef<"folios_pack", 'String'>
    readonly cajas: FieldRef<"folios_pack", 'Int'>
    readonly fecha: FieldRef<"folios_pack", 'DateTime'>
    readonly calibre: FieldRef<"folios_pack", 'String'>
    readonly embalaje: FieldRef<"folios_pack", 'String'>
  }
    

  // Custom InputTypes
  /**
   * folios_pack findUnique
   */
  export type folios_packFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_pack
     */
    select?: folios_packSelect<ExtArgs> | null
    /**
     * Filter, which folios_pack to fetch.
     */
    where: folios_packWhereUniqueInput
  }

  /**
   * folios_pack findUniqueOrThrow
   */
  export type folios_packFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_pack
     */
    select?: folios_packSelect<ExtArgs> | null
    /**
     * Filter, which folios_pack to fetch.
     */
    where: folios_packWhereUniqueInput
  }

  /**
   * folios_pack findFirst
   */
  export type folios_packFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_pack
     */
    select?: folios_packSelect<ExtArgs> | null
    /**
     * Filter, which folios_pack to fetch.
     */
    where?: folios_packWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of folios_packs to fetch.
     */
    orderBy?: folios_packOrderByWithRelationInput | folios_packOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for folios_packs.
     */
    cursor?: folios_packWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` folios_packs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` folios_packs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of folios_packs.
     */
    distinct?: Folios_packScalarFieldEnum | Folios_packScalarFieldEnum[]
  }

  /**
   * folios_pack findFirstOrThrow
   */
  export type folios_packFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_pack
     */
    select?: folios_packSelect<ExtArgs> | null
    /**
     * Filter, which folios_pack to fetch.
     */
    where?: folios_packWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of folios_packs to fetch.
     */
    orderBy?: folios_packOrderByWithRelationInput | folios_packOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for folios_packs.
     */
    cursor?: folios_packWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` folios_packs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` folios_packs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of folios_packs.
     */
    distinct?: Folios_packScalarFieldEnum | Folios_packScalarFieldEnum[]
  }

  /**
   * folios_pack findMany
   */
  export type folios_packFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_pack
     */
    select?: folios_packSelect<ExtArgs> | null
    /**
     * Filter, which folios_packs to fetch.
     */
    where?: folios_packWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of folios_packs to fetch.
     */
    orderBy?: folios_packOrderByWithRelationInput | folios_packOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing folios_packs.
     */
    cursor?: folios_packWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` folios_packs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` folios_packs.
     */
    skip?: number
    distinct?: Folios_packScalarFieldEnum | Folios_packScalarFieldEnum[]
  }

  /**
   * folios_pack create
   */
  export type folios_packCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_pack
     */
    select?: folios_packSelect<ExtArgs> | null
    /**
     * The data needed to create a folios_pack.
     */
    data: XOR<folios_packCreateInput, folios_packUncheckedCreateInput>
  }

  /**
   * folios_pack createMany
   */
  export type folios_packCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many folios_packs.
     */
    data: folios_packCreateManyInput | folios_packCreateManyInput[]
  }

  /**
   * folios_pack update
   */
  export type folios_packUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_pack
     */
    select?: folios_packSelect<ExtArgs> | null
    /**
     * The data needed to update a folios_pack.
     */
    data: XOR<folios_packUpdateInput, folios_packUncheckedUpdateInput>
    /**
     * Choose, which folios_pack to update.
     */
    where: folios_packWhereUniqueInput
  }

  /**
   * folios_pack updateMany
   */
  export type folios_packUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update folios_packs.
     */
    data: XOR<folios_packUpdateManyMutationInput, folios_packUncheckedUpdateManyInput>
    /**
     * Filter which folios_packs to update
     */
    where?: folios_packWhereInput
  }

  /**
   * folios_pack upsert
   */
  export type folios_packUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_pack
     */
    select?: folios_packSelect<ExtArgs> | null
    /**
     * The filter to search for the folios_pack to update in case it exists.
     */
    where: folios_packWhereUniqueInput
    /**
     * In case the folios_pack found by the `where` argument doesn't exist, create a new folios_pack with this data.
     */
    create: XOR<folios_packCreateInput, folios_packUncheckedCreateInput>
    /**
     * In case the folios_pack was found with the provided `where` argument, update it with this data.
     */
    update: XOR<folios_packUpdateInput, folios_packUncheckedUpdateInput>
  }

  /**
   * folios_pack delete
   */
  export type folios_packDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_pack
     */
    select?: folios_packSelect<ExtArgs> | null
    /**
     * Filter which folios_pack to delete.
     */
    where: folios_packWhereUniqueInput
  }

  /**
   * folios_pack deleteMany
   */
  export type folios_packDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which folios_packs to delete
     */
    where?: folios_packWhereInput
  }

  /**
   * folios_pack without action
   */
  export type folios_packDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_pack
     */
    select?: folios_packSelect<ExtArgs> | null
  }


  /**
   * Model folios_se
   */

  export type AggregateFolios_se = {
    _count: Folios_seCountAggregateOutputType | null
    _avg: Folios_seAvgAggregateOutputType | null
    _sum: Folios_seSumAggregateOutputType | null
    _min: Folios_seMinAggregateOutputType | null
    _max: Folios_seMaxAggregateOutputType | null
  }

  export type Folios_seAvgAggregateOutputType = {
    cajas: number | null
  }

  export type Folios_seSumAggregateOutputType = {
    cajas: number | null
  }

  export type Folios_seMinAggregateOutputType = {
    folio: string | null
    nom_var: string | null
    cod_var: string | null
    cajas: number | null
    fecha: Date | null
    calibre: string | null
    embalaje: string | null
  }

  export type Folios_seMaxAggregateOutputType = {
    folio: string | null
    nom_var: string | null
    cod_var: string | null
    cajas: number | null
    fecha: Date | null
    calibre: string | null
    embalaje: string | null
  }

  export type Folios_seCountAggregateOutputType = {
    folio: number
    nom_var: number
    cod_var: number
    cajas: number
    fecha: number
    calibre: number
    embalaje: number
    _all: number
  }


  export type Folios_seAvgAggregateInputType = {
    cajas?: true
  }

  export type Folios_seSumAggregateInputType = {
    cajas?: true
  }

  export type Folios_seMinAggregateInputType = {
    folio?: true
    nom_var?: true
    cod_var?: true
    cajas?: true
    fecha?: true
    calibre?: true
    embalaje?: true
  }

  export type Folios_seMaxAggregateInputType = {
    folio?: true
    nom_var?: true
    cod_var?: true
    cajas?: true
    fecha?: true
    calibre?: true
    embalaje?: true
  }

  export type Folios_seCountAggregateInputType = {
    folio?: true
    nom_var?: true
    cod_var?: true
    cajas?: true
    fecha?: true
    calibre?: true
    embalaje?: true
    _all?: true
  }

  export type Folios_seAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which folios_se to aggregate.
     */
    where?: folios_seWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of folios_ses to fetch.
     */
    orderBy?: folios_seOrderByWithRelationInput | folios_seOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: folios_seWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` folios_ses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` folios_ses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned folios_ses
    **/
    _count?: true | Folios_seCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Folios_seAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Folios_seSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Folios_seMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Folios_seMaxAggregateInputType
  }

  export type GetFolios_seAggregateType<T extends Folios_seAggregateArgs> = {
        [P in keyof T & keyof AggregateFolios_se]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFolios_se[P]>
      : GetScalarType<T[P], AggregateFolios_se[P]>
  }




  export type folios_seGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: folios_seWhereInput
    orderBy?: folios_seOrderByWithAggregationInput | folios_seOrderByWithAggregationInput[]
    by: Folios_seScalarFieldEnum[] | Folios_seScalarFieldEnum
    having?: folios_seScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Folios_seCountAggregateInputType | true
    _avg?: Folios_seAvgAggregateInputType
    _sum?: Folios_seSumAggregateInputType
    _min?: Folios_seMinAggregateInputType
    _max?: Folios_seMaxAggregateInputType
  }

  export type Folios_seGroupByOutputType = {
    folio: string
    nom_var: string | null
    cod_var: string | null
    cajas: number | null
    fecha: Date | null
    calibre: string | null
    embalaje: string | null
    _count: Folios_seCountAggregateOutputType | null
    _avg: Folios_seAvgAggregateOutputType | null
    _sum: Folios_seSumAggregateOutputType | null
    _min: Folios_seMinAggregateOutputType | null
    _max: Folios_seMaxAggregateOutputType | null
  }

  type GetFolios_seGroupByPayload<T extends folios_seGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Folios_seGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Folios_seGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Folios_seGroupByOutputType[P]>
            : GetScalarType<T[P], Folios_seGroupByOutputType[P]>
        }
      >
    >


  export type folios_seSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    folio?: boolean
    nom_var?: boolean
    cod_var?: boolean
    cajas?: boolean
    fecha?: boolean
    calibre?: boolean
    embalaje?: boolean
  }, ExtArgs["result"]["folios_se"]>


  export type folios_seSelectScalar = {
    folio?: boolean
    nom_var?: boolean
    cod_var?: boolean
    cajas?: boolean
    fecha?: boolean
    calibre?: boolean
    embalaje?: boolean
  }


  export type $folios_sePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "folios_se"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      folio: string
      nom_var: string | null
      cod_var: string | null
      cajas: number | null
      fecha: Date | null
      calibre: string | null
      embalaje: string | null
    }, ExtArgs["result"]["folios_se"]>
    composites: {}
  }

  type folios_seGetPayload<S extends boolean | null | undefined | folios_seDefaultArgs> = $Result.GetResult<Prisma.$folios_sePayload, S>

  type folios_seCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<folios_seFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Folios_seCountAggregateInputType | true
    }

  export interface folios_seDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['folios_se'], meta: { name: 'folios_se' } }
    /**
     * Find zero or one Folios_se that matches the filter.
     * @param {folios_seFindUniqueArgs} args - Arguments to find a Folios_se
     * @example
     * // Get one Folios_se
     * const folios_se = await prisma.folios_se.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends folios_seFindUniqueArgs>(args: SelectSubset<T, folios_seFindUniqueArgs<ExtArgs>>): Prisma__folios_seClient<$Result.GetResult<Prisma.$folios_sePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Folios_se that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {folios_seFindUniqueOrThrowArgs} args - Arguments to find a Folios_se
     * @example
     * // Get one Folios_se
     * const folios_se = await prisma.folios_se.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends folios_seFindUniqueOrThrowArgs>(args: SelectSubset<T, folios_seFindUniqueOrThrowArgs<ExtArgs>>): Prisma__folios_seClient<$Result.GetResult<Prisma.$folios_sePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Folios_se that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {folios_seFindFirstArgs} args - Arguments to find a Folios_se
     * @example
     * // Get one Folios_se
     * const folios_se = await prisma.folios_se.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends folios_seFindFirstArgs>(args?: SelectSubset<T, folios_seFindFirstArgs<ExtArgs>>): Prisma__folios_seClient<$Result.GetResult<Prisma.$folios_sePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Folios_se that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {folios_seFindFirstOrThrowArgs} args - Arguments to find a Folios_se
     * @example
     * // Get one Folios_se
     * const folios_se = await prisma.folios_se.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends folios_seFindFirstOrThrowArgs>(args?: SelectSubset<T, folios_seFindFirstOrThrowArgs<ExtArgs>>): Prisma__folios_seClient<$Result.GetResult<Prisma.$folios_sePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Folios_ses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {folios_seFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Folios_ses
     * const folios_ses = await prisma.folios_se.findMany()
     * 
     * // Get first 10 Folios_ses
     * const folios_ses = await prisma.folios_se.findMany({ take: 10 })
     * 
     * // Only select the `folio`
     * const folios_seWithFolioOnly = await prisma.folios_se.findMany({ select: { folio: true } })
     * 
     */
    findMany<T extends folios_seFindManyArgs>(args?: SelectSubset<T, folios_seFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$folios_sePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Folios_se.
     * @param {folios_seCreateArgs} args - Arguments to create a Folios_se.
     * @example
     * // Create one Folios_se
     * const Folios_se = await prisma.folios_se.create({
     *   data: {
     *     // ... data to create a Folios_se
     *   }
     * })
     * 
     */
    create<T extends folios_seCreateArgs>(args: SelectSubset<T, folios_seCreateArgs<ExtArgs>>): Prisma__folios_seClient<$Result.GetResult<Prisma.$folios_sePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Folios_ses.
     * @param {folios_seCreateManyArgs} args - Arguments to create many Folios_ses.
     * @example
     * // Create many Folios_ses
     * const folios_se = await prisma.folios_se.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends folios_seCreateManyArgs>(args?: SelectSubset<T, folios_seCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Folios_se.
     * @param {folios_seDeleteArgs} args - Arguments to delete one Folios_se.
     * @example
     * // Delete one Folios_se
     * const Folios_se = await prisma.folios_se.delete({
     *   where: {
     *     // ... filter to delete one Folios_se
     *   }
     * })
     * 
     */
    delete<T extends folios_seDeleteArgs>(args: SelectSubset<T, folios_seDeleteArgs<ExtArgs>>): Prisma__folios_seClient<$Result.GetResult<Prisma.$folios_sePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Folios_se.
     * @param {folios_seUpdateArgs} args - Arguments to update one Folios_se.
     * @example
     * // Update one Folios_se
     * const folios_se = await prisma.folios_se.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends folios_seUpdateArgs>(args: SelectSubset<T, folios_seUpdateArgs<ExtArgs>>): Prisma__folios_seClient<$Result.GetResult<Prisma.$folios_sePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Folios_ses.
     * @param {folios_seDeleteManyArgs} args - Arguments to filter Folios_ses to delete.
     * @example
     * // Delete a few Folios_ses
     * const { count } = await prisma.folios_se.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends folios_seDeleteManyArgs>(args?: SelectSubset<T, folios_seDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folios_ses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {folios_seUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Folios_ses
     * const folios_se = await prisma.folios_se.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends folios_seUpdateManyArgs>(args: SelectSubset<T, folios_seUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Folios_se.
     * @param {folios_seUpsertArgs} args - Arguments to update or create a Folios_se.
     * @example
     * // Update or create a Folios_se
     * const folios_se = await prisma.folios_se.upsert({
     *   create: {
     *     // ... data to create a Folios_se
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Folios_se we want to update
     *   }
     * })
     */
    upsert<T extends folios_seUpsertArgs>(args: SelectSubset<T, folios_seUpsertArgs<ExtArgs>>): Prisma__folios_seClient<$Result.GetResult<Prisma.$folios_sePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Folios_ses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {folios_seCountArgs} args - Arguments to filter Folios_ses to count.
     * @example
     * // Count the number of Folios_ses
     * const count = await prisma.folios_se.count({
     *   where: {
     *     // ... the filter for the Folios_ses we want to count
     *   }
     * })
    **/
    count<T extends folios_seCountArgs>(
      args?: Subset<T, folios_seCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Folios_seCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Folios_se.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Folios_seAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Folios_seAggregateArgs>(args: Subset<T, Folios_seAggregateArgs>): Prisma.PrismaPromise<GetFolios_seAggregateType<T>>

    /**
     * Group by Folios_se.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {folios_seGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends folios_seGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: folios_seGroupByArgs['orderBy'] }
        : { orderBy?: folios_seGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, folios_seGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFolios_seGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the folios_se model
   */
  readonly fields: folios_seFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for folios_se.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__folios_seClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the folios_se model
   */ 
  interface folios_seFieldRefs {
    readonly folio: FieldRef<"folios_se", 'String'>
    readonly nom_var: FieldRef<"folios_se", 'String'>
    readonly cod_var: FieldRef<"folios_se", 'String'>
    readonly cajas: FieldRef<"folios_se", 'Int'>
    readonly fecha: FieldRef<"folios_se", 'DateTime'>
    readonly calibre: FieldRef<"folios_se", 'String'>
    readonly embalaje: FieldRef<"folios_se", 'String'>
  }
    

  // Custom InputTypes
  /**
   * folios_se findUnique
   */
  export type folios_seFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_se
     */
    select?: folios_seSelect<ExtArgs> | null
    /**
     * Filter, which folios_se to fetch.
     */
    where: folios_seWhereUniqueInput
  }

  /**
   * folios_se findUniqueOrThrow
   */
  export type folios_seFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_se
     */
    select?: folios_seSelect<ExtArgs> | null
    /**
     * Filter, which folios_se to fetch.
     */
    where: folios_seWhereUniqueInput
  }

  /**
   * folios_se findFirst
   */
  export type folios_seFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_se
     */
    select?: folios_seSelect<ExtArgs> | null
    /**
     * Filter, which folios_se to fetch.
     */
    where?: folios_seWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of folios_ses to fetch.
     */
    orderBy?: folios_seOrderByWithRelationInput | folios_seOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for folios_ses.
     */
    cursor?: folios_seWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` folios_ses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` folios_ses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of folios_ses.
     */
    distinct?: Folios_seScalarFieldEnum | Folios_seScalarFieldEnum[]
  }

  /**
   * folios_se findFirstOrThrow
   */
  export type folios_seFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_se
     */
    select?: folios_seSelect<ExtArgs> | null
    /**
     * Filter, which folios_se to fetch.
     */
    where?: folios_seWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of folios_ses to fetch.
     */
    orderBy?: folios_seOrderByWithRelationInput | folios_seOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for folios_ses.
     */
    cursor?: folios_seWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` folios_ses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` folios_ses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of folios_ses.
     */
    distinct?: Folios_seScalarFieldEnum | Folios_seScalarFieldEnum[]
  }

  /**
   * folios_se findMany
   */
  export type folios_seFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_se
     */
    select?: folios_seSelect<ExtArgs> | null
    /**
     * Filter, which folios_ses to fetch.
     */
    where?: folios_seWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of folios_ses to fetch.
     */
    orderBy?: folios_seOrderByWithRelationInput | folios_seOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing folios_ses.
     */
    cursor?: folios_seWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` folios_ses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` folios_ses.
     */
    skip?: number
    distinct?: Folios_seScalarFieldEnum | Folios_seScalarFieldEnum[]
  }

  /**
   * folios_se create
   */
  export type folios_seCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_se
     */
    select?: folios_seSelect<ExtArgs> | null
    /**
     * The data needed to create a folios_se.
     */
    data: XOR<folios_seCreateInput, folios_seUncheckedCreateInput>
  }

  /**
   * folios_se createMany
   */
  export type folios_seCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many folios_ses.
     */
    data: folios_seCreateManyInput | folios_seCreateManyInput[]
  }

  /**
   * folios_se update
   */
  export type folios_seUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_se
     */
    select?: folios_seSelect<ExtArgs> | null
    /**
     * The data needed to update a folios_se.
     */
    data: XOR<folios_seUpdateInput, folios_seUncheckedUpdateInput>
    /**
     * Choose, which folios_se to update.
     */
    where: folios_seWhereUniqueInput
  }

  /**
   * folios_se updateMany
   */
  export type folios_seUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update folios_ses.
     */
    data: XOR<folios_seUpdateManyMutationInput, folios_seUncheckedUpdateManyInput>
    /**
     * Filter which folios_ses to update
     */
    where?: folios_seWhereInput
  }

  /**
   * folios_se upsert
   */
  export type folios_seUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_se
     */
    select?: folios_seSelect<ExtArgs> | null
    /**
     * The filter to search for the folios_se to update in case it exists.
     */
    where: folios_seWhereUniqueInput
    /**
     * In case the folios_se found by the `where` argument doesn't exist, create a new folios_se with this data.
     */
    create: XOR<folios_seCreateInput, folios_seUncheckedCreateInput>
    /**
     * In case the folios_se was found with the provided `where` argument, update it with this data.
     */
    update: XOR<folios_seUpdateInput, folios_seUncheckedUpdateInput>
  }

  /**
   * folios_se delete
   */
  export type folios_seDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_se
     */
    select?: folios_seSelect<ExtArgs> | null
    /**
     * Filter which folios_se to delete.
     */
    where: folios_seWhereUniqueInput
  }

  /**
   * folios_se deleteMany
   */
  export type folios_seDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which folios_ses to delete
     */
    where?: folios_seWhereInput
  }

  /**
   * folios_se without action
   */
  export type folios_seDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the folios_se
     */
    select?: folios_seSelect<ExtArgs> | null
  }


  /**
   * Model fr_repa_cab
   */

  export type AggregateFr_repa_cab = {
    _count: Fr_repa_cabCountAggregateOutputType | null
    _avg: Fr_repa_cabAvgAggregateOutputType | null
    _sum: Fr_repa_cabSumAggregateOutputType | null
    _min: Fr_repa_cabMinAggregateOutputType | null
    _max: Fr_repa_cabMaxAggregateOutputType | null
  }

  export type Fr_repa_cabAvgAggregateOutputType = {
    id: number | null
    id_tip_rep: number | null
    fr_nro_rep: number | null
  }

  export type Fr_repa_cabSumAggregateOutputType = {
    id: number | null
    id_tip_rep: number | null
    fr_nro_rep: number | null
  }

  export type Fr_repa_cabMinAggregateOutputType = {
    id: number | null
    fec_rep: Date | null
    id_tip_rep: number | null
    fr_cod_pac: string | null
    fr_cod_fri: string | null
    fr_usu: string | null
    fr_rep_sag: Buffer | null
    fr_cod_tem: string | null
    fr_cod_emp: string | null
    fr_tra_sdt: string | null
    fr_nro_rep: number | null
    fr_cod_esp: string | null
  }

  export type Fr_repa_cabMaxAggregateOutputType = {
    id: number | null
    fec_rep: Date | null
    id_tip_rep: number | null
    fr_cod_pac: string | null
    fr_cod_fri: string | null
    fr_usu: string | null
    fr_rep_sag: Buffer | null
    fr_cod_tem: string | null
    fr_cod_emp: string | null
    fr_tra_sdt: string | null
    fr_nro_rep: number | null
    fr_cod_esp: string | null
  }

  export type Fr_repa_cabCountAggregateOutputType = {
    id: number
    fec_rep: number
    id_tip_rep: number
    fr_cod_pac: number
    fr_cod_fri: number
    fr_usu: number
    fr_rep_sag: number
    fr_cod_tem: number
    fr_cod_emp: number
    fr_tra_sdt: number
    fr_nro_rep: number
    fr_cod_esp: number
    _all: number
  }


  export type Fr_repa_cabAvgAggregateInputType = {
    id?: true
    id_tip_rep?: true
    fr_nro_rep?: true
  }

  export type Fr_repa_cabSumAggregateInputType = {
    id?: true
    id_tip_rep?: true
    fr_nro_rep?: true
  }

  export type Fr_repa_cabMinAggregateInputType = {
    id?: true
    fec_rep?: true
    id_tip_rep?: true
    fr_cod_pac?: true
    fr_cod_fri?: true
    fr_usu?: true
    fr_rep_sag?: true
    fr_cod_tem?: true
    fr_cod_emp?: true
    fr_tra_sdt?: true
    fr_nro_rep?: true
    fr_cod_esp?: true
  }

  export type Fr_repa_cabMaxAggregateInputType = {
    id?: true
    fec_rep?: true
    id_tip_rep?: true
    fr_cod_pac?: true
    fr_cod_fri?: true
    fr_usu?: true
    fr_rep_sag?: true
    fr_cod_tem?: true
    fr_cod_emp?: true
    fr_tra_sdt?: true
    fr_nro_rep?: true
    fr_cod_esp?: true
  }

  export type Fr_repa_cabCountAggregateInputType = {
    id?: true
    fec_rep?: true
    id_tip_rep?: true
    fr_cod_pac?: true
    fr_cod_fri?: true
    fr_usu?: true
    fr_rep_sag?: true
    fr_cod_tem?: true
    fr_cod_emp?: true
    fr_tra_sdt?: true
    fr_nro_rep?: true
    fr_cod_esp?: true
    _all?: true
  }

  export type Fr_repa_cabAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fr_repa_cab to aggregate.
     */
    where?: fr_repa_cabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fr_repa_cabs to fetch.
     */
    orderBy?: fr_repa_cabOrderByWithRelationInput | fr_repa_cabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fr_repa_cabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fr_repa_cabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fr_repa_cabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fr_repa_cabs
    **/
    _count?: true | Fr_repa_cabCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fr_repa_cabAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fr_repa_cabSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fr_repa_cabMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fr_repa_cabMaxAggregateInputType
  }

  export type GetFr_repa_cabAggregateType<T extends Fr_repa_cabAggregateArgs> = {
        [P in keyof T & keyof AggregateFr_repa_cab]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFr_repa_cab[P]>
      : GetScalarType<T[P], AggregateFr_repa_cab[P]>
  }




  export type fr_repa_cabGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fr_repa_cabWhereInput
    orderBy?: fr_repa_cabOrderByWithAggregationInput | fr_repa_cabOrderByWithAggregationInput[]
    by: Fr_repa_cabScalarFieldEnum[] | Fr_repa_cabScalarFieldEnum
    having?: fr_repa_cabScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fr_repa_cabCountAggregateInputType | true
    _avg?: Fr_repa_cabAvgAggregateInputType
    _sum?: Fr_repa_cabSumAggregateInputType
    _min?: Fr_repa_cabMinAggregateInputType
    _max?: Fr_repa_cabMaxAggregateInputType
  }

  export type Fr_repa_cabGroupByOutputType = {
    id: number
    fec_rep: Date | null
    id_tip_rep: number | null
    fr_cod_pac: string | null
    fr_cod_fri: string | null
    fr_usu: string | null
    fr_rep_sag: Buffer | null
    fr_cod_tem: string | null
    fr_cod_emp: string | null
    fr_tra_sdt: string | null
    fr_nro_rep: number | null
    fr_cod_esp: string | null
    _count: Fr_repa_cabCountAggregateOutputType | null
    _avg: Fr_repa_cabAvgAggregateOutputType | null
    _sum: Fr_repa_cabSumAggregateOutputType | null
    _min: Fr_repa_cabMinAggregateOutputType | null
    _max: Fr_repa_cabMaxAggregateOutputType | null
  }

  type GetFr_repa_cabGroupByPayload<T extends fr_repa_cabGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Fr_repa_cabGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fr_repa_cabGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fr_repa_cabGroupByOutputType[P]>
            : GetScalarType<T[P], Fr_repa_cabGroupByOutputType[P]>
        }
      >
    >


  export type fr_repa_cabSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fec_rep?: boolean
    id_tip_rep?: boolean
    fr_cod_pac?: boolean
    fr_cod_fri?: boolean
    fr_usu?: boolean
    fr_rep_sag?: boolean
    fr_cod_tem?: boolean
    fr_cod_emp?: boolean
    fr_tra_sdt?: boolean
    fr_nro_rep?: boolean
    fr_cod_esp?: boolean
  }, ExtArgs["result"]["fr_repa_cab"]>


  export type fr_repa_cabSelectScalar = {
    id?: boolean
    fec_rep?: boolean
    id_tip_rep?: boolean
    fr_cod_pac?: boolean
    fr_cod_fri?: boolean
    fr_usu?: boolean
    fr_rep_sag?: boolean
    fr_cod_tem?: boolean
    fr_cod_emp?: boolean
    fr_tra_sdt?: boolean
    fr_nro_rep?: boolean
    fr_cod_esp?: boolean
  }


  export type $fr_repa_cabPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "fr_repa_cab"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fec_rep: Date | null
      id_tip_rep: number | null
      fr_cod_pac: string | null
      fr_cod_fri: string | null
      fr_usu: string | null
      fr_rep_sag: Buffer | null
      fr_cod_tem: string | null
      fr_cod_emp: string | null
      fr_tra_sdt: string | null
      fr_nro_rep: number | null
      fr_cod_esp: string | null
    }, ExtArgs["result"]["fr_repa_cab"]>
    composites: {}
  }

  type fr_repa_cabGetPayload<S extends boolean | null | undefined | fr_repa_cabDefaultArgs> = $Result.GetResult<Prisma.$fr_repa_cabPayload, S>

  type fr_repa_cabCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<fr_repa_cabFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Fr_repa_cabCountAggregateInputType | true
    }

  export interface fr_repa_cabDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fr_repa_cab'], meta: { name: 'fr_repa_cab' } }
    /**
     * Find zero or one Fr_repa_cab that matches the filter.
     * @param {fr_repa_cabFindUniqueArgs} args - Arguments to find a Fr_repa_cab
     * @example
     * // Get one Fr_repa_cab
     * const fr_repa_cab = await prisma.fr_repa_cab.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends fr_repa_cabFindUniqueArgs>(args: SelectSubset<T, fr_repa_cabFindUniqueArgs<ExtArgs>>): Prisma__fr_repa_cabClient<$Result.GetResult<Prisma.$fr_repa_cabPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Fr_repa_cab that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {fr_repa_cabFindUniqueOrThrowArgs} args - Arguments to find a Fr_repa_cab
     * @example
     * // Get one Fr_repa_cab
     * const fr_repa_cab = await prisma.fr_repa_cab.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends fr_repa_cabFindUniqueOrThrowArgs>(args: SelectSubset<T, fr_repa_cabFindUniqueOrThrowArgs<ExtArgs>>): Prisma__fr_repa_cabClient<$Result.GetResult<Prisma.$fr_repa_cabPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Fr_repa_cab that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fr_repa_cabFindFirstArgs} args - Arguments to find a Fr_repa_cab
     * @example
     * // Get one Fr_repa_cab
     * const fr_repa_cab = await prisma.fr_repa_cab.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends fr_repa_cabFindFirstArgs>(args?: SelectSubset<T, fr_repa_cabFindFirstArgs<ExtArgs>>): Prisma__fr_repa_cabClient<$Result.GetResult<Prisma.$fr_repa_cabPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Fr_repa_cab that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fr_repa_cabFindFirstOrThrowArgs} args - Arguments to find a Fr_repa_cab
     * @example
     * // Get one Fr_repa_cab
     * const fr_repa_cab = await prisma.fr_repa_cab.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends fr_repa_cabFindFirstOrThrowArgs>(args?: SelectSubset<T, fr_repa_cabFindFirstOrThrowArgs<ExtArgs>>): Prisma__fr_repa_cabClient<$Result.GetResult<Prisma.$fr_repa_cabPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Fr_repa_cabs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fr_repa_cabFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fr_repa_cabs
     * const fr_repa_cabs = await prisma.fr_repa_cab.findMany()
     * 
     * // Get first 10 Fr_repa_cabs
     * const fr_repa_cabs = await prisma.fr_repa_cab.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fr_repa_cabWithIdOnly = await prisma.fr_repa_cab.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends fr_repa_cabFindManyArgs>(args?: SelectSubset<T, fr_repa_cabFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fr_repa_cabPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Fr_repa_cab.
     * @param {fr_repa_cabCreateArgs} args - Arguments to create a Fr_repa_cab.
     * @example
     * // Create one Fr_repa_cab
     * const Fr_repa_cab = await prisma.fr_repa_cab.create({
     *   data: {
     *     // ... data to create a Fr_repa_cab
     *   }
     * })
     * 
     */
    create<T extends fr_repa_cabCreateArgs>(args: SelectSubset<T, fr_repa_cabCreateArgs<ExtArgs>>): Prisma__fr_repa_cabClient<$Result.GetResult<Prisma.$fr_repa_cabPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Fr_repa_cabs.
     * @param {fr_repa_cabCreateManyArgs} args - Arguments to create many Fr_repa_cabs.
     * @example
     * // Create many Fr_repa_cabs
     * const fr_repa_cab = await prisma.fr_repa_cab.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends fr_repa_cabCreateManyArgs>(args?: SelectSubset<T, fr_repa_cabCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fr_repa_cab.
     * @param {fr_repa_cabDeleteArgs} args - Arguments to delete one Fr_repa_cab.
     * @example
     * // Delete one Fr_repa_cab
     * const Fr_repa_cab = await prisma.fr_repa_cab.delete({
     *   where: {
     *     // ... filter to delete one Fr_repa_cab
     *   }
     * })
     * 
     */
    delete<T extends fr_repa_cabDeleteArgs>(args: SelectSubset<T, fr_repa_cabDeleteArgs<ExtArgs>>): Prisma__fr_repa_cabClient<$Result.GetResult<Prisma.$fr_repa_cabPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Fr_repa_cab.
     * @param {fr_repa_cabUpdateArgs} args - Arguments to update one Fr_repa_cab.
     * @example
     * // Update one Fr_repa_cab
     * const fr_repa_cab = await prisma.fr_repa_cab.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends fr_repa_cabUpdateArgs>(args: SelectSubset<T, fr_repa_cabUpdateArgs<ExtArgs>>): Prisma__fr_repa_cabClient<$Result.GetResult<Prisma.$fr_repa_cabPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Fr_repa_cabs.
     * @param {fr_repa_cabDeleteManyArgs} args - Arguments to filter Fr_repa_cabs to delete.
     * @example
     * // Delete a few Fr_repa_cabs
     * const { count } = await prisma.fr_repa_cab.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends fr_repa_cabDeleteManyArgs>(args?: SelectSubset<T, fr_repa_cabDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fr_repa_cabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fr_repa_cabUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fr_repa_cabs
     * const fr_repa_cab = await prisma.fr_repa_cab.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends fr_repa_cabUpdateManyArgs>(args: SelectSubset<T, fr_repa_cabUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fr_repa_cab.
     * @param {fr_repa_cabUpsertArgs} args - Arguments to update or create a Fr_repa_cab.
     * @example
     * // Update or create a Fr_repa_cab
     * const fr_repa_cab = await prisma.fr_repa_cab.upsert({
     *   create: {
     *     // ... data to create a Fr_repa_cab
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fr_repa_cab we want to update
     *   }
     * })
     */
    upsert<T extends fr_repa_cabUpsertArgs>(args: SelectSubset<T, fr_repa_cabUpsertArgs<ExtArgs>>): Prisma__fr_repa_cabClient<$Result.GetResult<Prisma.$fr_repa_cabPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Fr_repa_cabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fr_repa_cabCountArgs} args - Arguments to filter Fr_repa_cabs to count.
     * @example
     * // Count the number of Fr_repa_cabs
     * const count = await prisma.fr_repa_cab.count({
     *   where: {
     *     // ... the filter for the Fr_repa_cabs we want to count
     *   }
     * })
    **/
    count<T extends fr_repa_cabCountArgs>(
      args?: Subset<T, fr_repa_cabCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fr_repa_cabCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fr_repa_cab.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fr_repa_cabAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fr_repa_cabAggregateArgs>(args: Subset<T, Fr_repa_cabAggregateArgs>): Prisma.PrismaPromise<GetFr_repa_cabAggregateType<T>>

    /**
     * Group by Fr_repa_cab.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fr_repa_cabGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fr_repa_cabGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fr_repa_cabGroupByArgs['orderBy'] }
        : { orderBy?: fr_repa_cabGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fr_repa_cabGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFr_repa_cabGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the fr_repa_cab model
   */
  readonly fields: fr_repa_cabFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fr_repa_cab.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__fr_repa_cabClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the fr_repa_cab model
   */ 
  interface fr_repa_cabFieldRefs {
    readonly id: FieldRef<"fr_repa_cab", 'Int'>
    readonly fec_rep: FieldRef<"fr_repa_cab", 'DateTime'>
    readonly id_tip_rep: FieldRef<"fr_repa_cab", 'Int'>
    readonly fr_cod_pac: FieldRef<"fr_repa_cab", 'String'>
    readonly fr_cod_fri: FieldRef<"fr_repa_cab", 'String'>
    readonly fr_usu: FieldRef<"fr_repa_cab", 'String'>
    readonly fr_rep_sag: FieldRef<"fr_repa_cab", 'Bytes'>
    readonly fr_cod_tem: FieldRef<"fr_repa_cab", 'String'>
    readonly fr_cod_emp: FieldRef<"fr_repa_cab", 'String'>
    readonly fr_tra_sdt: FieldRef<"fr_repa_cab", 'String'>
    readonly fr_nro_rep: FieldRef<"fr_repa_cab", 'Int'>
    readonly fr_cod_esp: FieldRef<"fr_repa_cab", 'String'>
  }
    

  // Custom InputTypes
  /**
   * fr_repa_cab findUnique
   */
  export type fr_repa_cabFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_cab
     */
    select?: fr_repa_cabSelect<ExtArgs> | null
    /**
     * Filter, which fr_repa_cab to fetch.
     */
    where: fr_repa_cabWhereUniqueInput
  }

  /**
   * fr_repa_cab findUniqueOrThrow
   */
  export type fr_repa_cabFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_cab
     */
    select?: fr_repa_cabSelect<ExtArgs> | null
    /**
     * Filter, which fr_repa_cab to fetch.
     */
    where: fr_repa_cabWhereUniqueInput
  }

  /**
   * fr_repa_cab findFirst
   */
  export type fr_repa_cabFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_cab
     */
    select?: fr_repa_cabSelect<ExtArgs> | null
    /**
     * Filter, which fr_repa_cab to fetch.
     */
    where?: fr_repa_cabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fr_repa_cabs to fetch.
     */
    orderBy?: fr_repa_cabOrderByWithRelationInput | fr_repa_cabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fr_repa_cabs.
     */
    cursor?: fr_repa_cabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fr_repa_cabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fr_repa_cabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fr_repa_cabs.
     */
    distinct?: Fr_repa_cabScalarFieldEnum | Fr_repa_cabScalarFieldEnum[]
  }

  /**
   * fr_repa_cab findFirstOrThrow
   */
  export type fr_repa_cabFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_cab
     */
    select?: fr_repa_cabSelect<ExtArgs> | null
    /**
     * Filter, which fr_repa_cab to fetch.
     */
    where?: fr_repa_cabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fr_repa_cabs to fetch.
     */
    orderBy?: fr_repa_cabOrderByWithRelationInput | fr_repa_cabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fr_repa_cabs.
     */
    cursor?: fr_repa_cabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fr_repa_cabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fr_repa_cabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fr_repa_cabs.
     */
    distinct?: Fr_repa_cabScalarFieldEnum | Fr_repa_cabScalarFieldEnum[]
  }

  /**
   * fr_repa_cab findMany
   */
  export type fr_repa_cabFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_cab
     */
    select?: fr_repa_cabSelect<ExtArgs> | null
    /**
     * Filter, which fr_repa_cabs to fetch.
     */
    where?: fr_repa_cabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fr_repa_cabs to fetch.
     */
    orderBy?: fr_repa_cabOrderByWithRelationInput | fr_repa_cabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fr_repa_cabs.
     */
    cursor?: fr_repa_cabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fr_repa_cabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fr_repa_cabs.
     */
    skip?: number
    distinct?: Fr_repa_cabScalarFieldEnum | Fr_repa_cabScalarFieldEnum[]
  }

  /**
   * fr_repa_cab create
   */
  export type fr_repa_cabCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_cab
     */
    select?: fr_repa_cabSelect<ExtArgs> | null
    /**
     * The data needed to create a fr_repa_cab.
     */
    data?: XOR<fr_repa_cabCreateInput, fr_repa_cabUncheckedCreateInput>
  }

  /**
   * fr_repa_cab createMany
   */
  export type fr_repa_cabCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fr_repa_cabs.
     */
    data: fr_repa_cabCreateManyInput | fr_repa_cabCreateManyInput[]
  }

  /**
   * fr_repa_cab update
   */
  export type fr_repa_cabUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_cab
     */
    select?: fr_repa_cabSelect<ExtArgs> | null
    /**
     * The data needed to update a fr_repa_cab.
     */
    data: XOR<fr_repa_cabUpdateInput, fr_repa_cabUncheckedUpdateInput>
    /**
     * Choose, which fr_repa_cab to update.
     */
    where: fr_repa_cabWhereUniqueInput
  }

  /**
   * fr_repa_cab updateMany
   */
  export type fr_repa_cabUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fr_repa_cabs.
     */
    data: XOR<fr_repa_cabUpdateManyMutationInput, fr_repa_cabUncheckedUpdateManyInput>
    /**
     * Filter which fr_repa_cabs to update
     */
    where?: fr_repa_cabWhereInput
  }

  /**
   * fr_repa_cab upsert
   */
  export type fr_repa_cabUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_cab
     */
    select?: fr_repa_cabSelect<ExtArgs> | null
    /**
     * The filter to search for the fr_repa_cab to update in case it exists.
     */
    where: fr_repa_cabWhereUniqueInput
    /**
     * In case the fr_repa_cab found by the `where` argument doesn't exist, create a new fr_repa_cab with this data.
     */
    create: XOR<fr_repa_cabCreateInput, fr_repa_cabUncheckedCreateInput>
    /**
     * In case the fr_repa_cab was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fr_repa_cabUpdateInput, fr_repa_cabUncheckedUpdateInput>
  }

  /**
   * fr_repa_cab delete
   */
  export type fr_repa_cabDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_cab
     */
    select?: fr_repa_cabSelect<ExtArgs> | null
    /**
     * Filter which fr_repa_cab to delete.
     */
    where: fr_repa_cabWhereUniqueInput
  }

  /**
   * fr_repa_cab deleteMany
   */
  export type fr_repa_cabDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fr_repa_cabs to delete
     */
    where?: fr_repa_cabWhereInput
  }

  /**
   * fr_repa_cab without action
   */
  export type fr_repa_cabDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_cab
     */
    select?: fr_repa_cabSelect<ExtArgs> | null
  }


  /**
   * Model fr_repa_det
   */

  export type AggregateFr_repa_det = {
    _count: Fr_repa_detCountAggregateOutputType | null
    _avg: Fr_repa_detAvgAggregateOutputType | null
    _sum: Fr_repa_detSumAggregateOutputType | null
    _min: Fr_repa_detMinAggregateOutputType | null
    _max: Fr_repa_detMaxAggregateOutputType | null
  }

  export type Fr_repa_detAvgAggregateOutputType = {
    id: number | null
    id_rep_cab: number | null
    fr_cor_sdt: Decimal | null
    fr_pla_sdt: number | null
    fr_gui_sdt: number | null
    fr_caj: number | null
    fr_nro_mix: number | null
    fr_proceso: number | null
    fr_pk_ori: number | null
    id_tip_io: number | null
    fr_caj_usa: number | null
    fr_guia_sag: number | null
    fr_guia_fum: number | null
    fr_correlativo_rec: number | null
    fr_peso_original: Decimal | null
  }

  export type Fr_repa_detSumAggregateOutputType = {
    id: number | null
    id_rep_cab: number | null
    fr_cor_sdt: Decimal | null
    fr_pla_sdt: number | null
    fr_gui_sdt: number | null
    fr_caj: number | null
    fr_nro_mix: number | null
    fr_proceso: number | null
    fr_pk_ori: number | null
    id_tip_io: number | null
    fr_caj_usa: number | null
    fr_guia_sag: number | null
    fr_guia_fum: number | null
    fr_correlativo_rec: number | null
    fr_peso_original: Decimal | null
  }

  export type Fr_repa_detMinAggregateOutputType = {
    id: number | null
    id_rep_cab: number | null
    fr_lote: string | null
    fr_cor_sdt: Decimal | null
    fr_pla_sdt: number | null
    fr_est_sdt: string | null
    fr_fec_pac: Date | null
    fr_fec_rpa: Date | null
    fr_gui_sdt: number | null
    fr_cod_pro: string | null
    fr_cod_esp: string | null
    fr_cod_var: string | null
    fr_hor_rec: Date | null
    fr_con: string | null
    fr_tip_lot: string | null
    fr_alt_pal: string | null
    fr_cod_env: string | null
    fr_cod_eti: string | null
    fr_cod_emb: string | null
    fr_cod_envop: string | null
    fr_plu: string | null
    fr_caj: number | null
    fr_cod_cat: string | null
    fr_cod_cal: string | null
    fr_nro_mix: number | null
    fr_fec_sem: string | null
    fr_cod_bp: string | null
    fr_cod_pre: string | null
    fr_cod_cua: string | null
    fr_proceso: number | null
    fr_con_fri: string | null
    fr_fol_ori: string | null
    fr_cod_var_eti: string | null
    fr_cod_tip_tra: string | null
    fr_cod_pro_eti: string | null
    fr_cod_exp: string | null
    fr_pk_ori: number | null
    id_tip_io: number | null
    fr_caj_usa: number | null
    fr_tip_mov: string | null
    fr_fec_sag: Date | null
    fr_guia_sag: number | null
    fr_cer_sag: string | null
    fr_sol_sag: string | null
    fr_tip_sag: string | null
    fr_cod_mer: string | null
    fr_cod_mer1: string | null
    fr_cod_mer2: string | null
    fr_cod_mer3: string | null
    fr_cod_mer4: string | null
    fr_fec_fum: Date | null
    fr_guia_fum: number | null
    fr_cer_fum: string | null
    fr_cod_tipo_fum: string | null
    fr_pfrio: string | null
    fr_correlativo_rec: number | null
    fr_cod_linea: string | null
    fr_peso_original: Decimal | null
  }

  export type Fr_repa_detMaxAggregateOutputType = {
    id: number | null
    id_rep_cab: number | null
    fr_lote: string | null
    fr_cor_sdt: Decimal | null
    fr_pla_sdt: number | null
    fr_est_sdt: string | null
    fr_fec_pac: Date | null
    fr_fec_rpa: Date | null
    fr_gui_sdt: number | null
    fr_cod_pro: string | null
    fr_cod_esp: string | null
    fr_cod_var: string | null
    fr_hor_rec: Date | null
    fr_con: string | null
    fr_tip_lot: string | null
    fr_alt_pal: string | null
    fr_cod_env: string | null
    fr_cod_eti: string | null
    fr_cod_emb: string | null
    fr_cod_envop: string | null
    fr_plu: string | null
    fr_caj: number | null
    fr_cod_cat: string | null
    fr_cod_cal: string | null
    fr_nro_mix: number | null
    fr_fec_sem: string | null
    fr_cod_bp: string | null
    fr_cod_pre: string | null
    fr_cod_cua: string | null
    fr_proceso: number | null
    fr_con_fri: string | null
    fr_fol_ori: string | null
    fr_cod_var_eti: string | null
    fr_cod_tip_tra: string | null
    fr_cod_pro_eti: string | null
    fr_cod_exp: string | null
    fr_pk_ori: number | null
    id_tip_io: number | null
    fr_caj_usa: number | null
    fr_tip_mov: string | null
    fr_fec_sag: Date | null
    fr_guia_sag: number | null
    fr_cer_sag: string | null
    fr_sol_sag: string | null
    fr_tip_sag: string | null
    fr_cod_mer: string | null
    fr_cod_mer1: string | null
    fr_cod_mer2: string | null
    fr_cod_mer3: string | null
    fr_cod_mer4: string | null
    fr_fec_fum: Date | null
    fr_guia_fum: number | null
    fr_cer_fum: string | null
    fr_cod_tipo_fum: string | null
    fr_pfrio: string | null
    fr_correlativo_rec: number | null
    fr_cod_linea: string | null
    fr_peso_original: Decimal | null
  }

  export type Fr_repa_detCountAggregateOutputType = {
    id: number
    id_rep_cab: number
    fr_lote: number
    fr_cor_sdt: number
    fr_pla_sdt: number
    fr_est_sdt: number
    fr_fec_pac: number
    fr_fec_rpa: number
    fr_gui_sdt: number
    fr_cod_pro: number
    fr_cod_esp: number
    fr_cod_var: number
    fr_hor_rec: number
    fr_con: number
    fr_tip_lot: number
    fr_alt_pal: number
    fr_cod_env: number
    fr_cod_eti: number
    fr_cod_emb: number
    fr_cod_envop: number
    fr_plu: number
    fr_caj: number
    fr_cod_cat: number
    fr_cod_cal: number
    fr_nro_mix: number
    fr_fec_sem: number
    fr_cod_bp: number
    fr_cod_pre: number
    fr_cod_cua: number
    fr_proceso: number
    fr_con_fri: number
    fr_fol_ori: number
    fr_cod_var_eti: number
    fr_cod_tip_tra: number
    fr_cod_pro_eti: number
    fr_cod_exp: number
    fr_pk_ori: number
    id_tip_io: number
    fr_caj_usa: number
    fr_tip_mov: number
    fr_fec_sag: number
    fr_guia_sag: number
    fr_cer_sag: number
    fr_sol_sag: number
    fr_tip_sag: number
    fr_cod_mer: number
    fr_cod_mer1: number
    fr_cod_mer2: number
    fr_cod_mer3: number
    fr_cod_mer4: number
    fr_fec_fum: number
    fr_guia_fum: number
    fr_cer_fum: number
    fr_cod_tipo_fum: number
    fr_pfrio: number
    fr_correlativo_rec: number
    fr_cod_linea: number
    fr_peso_original: number
    _all: number
  }


  export type Fr_repa_detAvgAggregateInputType = {
    id?: true
    id_rep_cab?: true
    fr_cor_sdt?: true
    fr_pla_sdt?: true
    fr_gui_sdt?: true
    fr_caj?: true
    fr_nro_mix?: true
    fr_proceso?: true
    fr_pk_ori?: true
    id_tip_io?: true
    fr_caj_usa?: true
    fr_guia_sag?: true
    fr_guia_fum?: true
    fr_correlativo_rec?: true
    fr_peso_original?: true
  }

  export type Fr_repa_detSumAggregateInputType = {
    id?: true
    id_rep_cab?: true
    fr_cor_sdt?: true
    fr_pla_sdt?: true
    fr_gui_sdt?: true
    fr_caj?: true
    fr_nro_mix?: true
    fr_proceso?: true
    fr_pk_ori?: true
    id_tip_io?: true
    fr_caj_usa?: true
    fr_guia_sag?: true
    fr_guia_fum?: true
    fr_correlativo_rec?: true
    fr_peso_original?: true
  }

  export type Fr_repa_detMinAggregateInputType = {
    id?: true
    id_rep_cab?: true
    fr_lote?: true
    fr_cor_sdt?: true
    fr_pla_sdt?: true
    fr_est_sdt?: true
    fr_fec_pac?: true
    fr_fec_rpa?: true
    fr_gui_sdt?: true
    fr_cod_pro?: true
    fr_cod_esp?: true
    fr_cod_var?: true
    fr_hor_rec?: true
    fr_con?: true
    fr_tip_lot?: true
    fr_alt_pal?: true
    fr_cod_env?: true
    fr_cod_eti?: true
    fr_cod_emb?: true
    fr_cod_envop?: true
    fr_plu?: true
    fr_caj?: true
    fr_cod_cat?: true
    fr_cod_cal?: true
    fr_nro_mix?: true
    fr_fec_sem?: true
    fr_cod_bp?: true
    fr_cod_pre?: true
    fr_cod_cua?: true
    fr_proceso?: true
    fr_con_fri?: true
    fr_fol_ori?: true
    fr_cod_var_eti?: true
    fr_cod_tip_tra?: true
    fr_cod_pro_eti?: true
    fr_cod_exp?: true
    fr_pk_ori?: true
    id_tip_io?: true
    fr_caj_usa?: true
    fr_tip_mov?: true
    fr_fec_sag?: true
    fr_guia_sag?: true
    fr_cer_sag?: true
    fr_sol_sag?: true
    fr_tip_sag?: true
    fr_cod_mer?: true
    fr_cod_mer1?: true
    fr_cod_mer2?: true
    fr_cod_mer3?: true
    fr_cod_mer4?: true
    fr_fec_fum?: true
    fr_guia_fum?: true
    fr_cer_fum?: true
    fr_cod_tipo_fum?: true
    fr_pfrio?: true
    fr_correlativo_rec?: true
    fr_cod_linea?: true
    fr_peso_original?: true
  }

  export type Fr_repa_detMaxAggregateInputType = {
    id?: true
    id_rep_cab?: true
    fr_lote?: true
    fr_cor_sdt?: true
    fr_pla_sdt?: true
    fr_est_sdt?: true
    fr_fec_pac?: true
    fr_fec_rpa?: true
    fr_gui_sdt?: true
    fr_cod_pro?: true
    fr_cod_esp?: true
    fr_cod_var?: true
    fr_hor_rec?: true
    fr_con?: true
    fr_tip_lot?: true
    fr_alt_pal?: true
    fr_cod_env?: true
    fr_cod_eti?: true
    fr_cod_emb?: true
    fr_cod_envop?: true
    fr_plu?: true
    fr_caj?: true
    fr_cod_cat?: true
    fr_cod_cal?: true
    fr_nro_mix?: true
    fr_fec_sem?: true
    fr_cod_bp?: true
    fr_cod_pre?: true
    fr_cod_cua?: true
    fr_proceso?: true
    fr_con_fri?: true
    fr_fol_ori?: true
    fr_cod_var_eti?: true
    fr_cod_tip_tra?: true
    fr_cod_pro_eti?: true
    fr_cod_exp?: true
    fr_pk_ori?: true
    id_tip_io?: true
    fr_caj_usa?: true
    fr_tip_mov?: true
    fr_fec_sag?: true
    fr_guia_sag?: true
    fr_cer_sag?: true
    fr_sol_sag?: true
    fr_tip_sag?: true
    fr_cod_mer?: true
    fr_cod_mer1?: true
    fr_cod_mer2?: true
    fr_cod_mer3?: true
    fr_cod_mer4?: true
    fr_fec_fum?: true
    fr_guia_fum?: true
    fr_cer_fum?: true
    fr_cod_tipo_fum?: true
    fr_pfrio?: true
    fr_correlativo_rec?: true
    fr_cod_linea?: true
    fr_peso_original?: true
  }

  export type Fr_repa_detCountAggregateInputType = {
    id?: true
    id_rep_cab?: true
    fr_lote?: true
    fr_cor_sdt?: true
    fr_pla_sdt?: true
    fr_est_sdt?: true
    fr_fec_pac?: true
    fr_fec_rpa?: true
    fr_gui_sdt?: true
    fr_cod_pro?: true
    fr_cod_esp?: true
    fr_cod_var?: true
    fr_hor_rec?: true
    fr_con?: true
    fr_tip_lot?: true
    fr_alt_pal?: true
    fr_cod_env?: true
    fr_cod_eti?: true
    fr_cod_emb?: true
    fr_cod_envop?: true
    fr_plu?: true
    fr_caj?: true
    fr_cod_cat?: true
    fr_cod_cal?: true
    fr_nro_mix?: true
    fr_fec_sem?: true
    fr_cod_bp?: true
    fr_cod_pre?: true
    fr_cod_cua?: true
    fr_proceso?: true
    fr_con_fri?: true
    fr_fol_ori?: true
    fr_cod_var_eti?: true
    fr_cod_tip_tra?: true
    fr_cod_pro_eti?: true
    fr_cod_exp?: true
    fr_pk_ori?: true
    id_tip_io?: true
    fr_caj_usa?: true
    fr_tip_mov?: true
    fr_fec_sag?: true
    fr_guia_sag?: true
    fr_cer_sag?: true
    fr_sol_sag?: true
    fr_tip_sag?: true
    fr_cod_mer?: true
    fr_cod_mer1?: true
    fr_cod_mer2?: true
    fr_cod_mer3?: true
    fr_cod_mer4?: true
    fr_fec_fum?: true
    fr_guia_fum?: true
    fr_cer_fum?: true
    fr_cod_tipo_fum?: true
    fr_pfrio?: true
    fr_correlativo_rec?: true
    fr_cod_linea?: true
    fr_peso_original?: true
    _all?: true
  }

  export type Fr_repa_detAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fr_repa_det to aggregate.
     */
    where?: fr_repa_detWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fr_repa_dets to fetch.
     */
    orderBy?: fr_repa_detOrderByWithRelationInput | fr_repa_detOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fr_repa_detWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fr_repa_dets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fr_repa_dets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fr_repa_dets
    **/
    _count?: true | Fr_repa_detCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fr_repa_detAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fr_repa_detSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fr_repa_detMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fr_repa_detMaxAggregateInputType
  }

  export type GetFr_repa_detAggregateType<T extends Fr_repa_detAggregateArgs> = {
        [P in keyof T & keyof AggregateFr_repa_det]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFr_repa_det[P]>
      : GetScalarType<T[P], AggregateFr_repa_det[P]>
  }




  export type fr_repa_detGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fr_repa_detWhereInput
    orderBy?: fr_repa_detOrderByWithAggregationInput | fr_repa_detOrderByWithAggregationInput[]
    by: Fr_repa_detScalarFieldEnum[] | Fr_repa_detScalarFieldEnum
    having?: fr_repa_detScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fr_repa_detCountAggregateInputType | true
    _avg?: Fr_repa_detAvgAggregateInputType
    _sum?: Fr_repa_detSumAggregateInputType
    _min?: Fr_repa_detMinAggregateInputType
    _max?: Fr_repa_detMaxAggregateInputType
  }

  export type Fr_repa_detGroupByOutputType = {
    id: number
    id_rep_cab: number | null
    fr_lote: string | null
    fr_cor_sdt: Decimal | null
    fr_pla_sdt: number | null
    fr_est_sdt: string | null
    fr_fec_pac: Date | null
    fr_fec_rpa: Date | null
    fr_gui_sdt: number | null
    fr_cod_pro: string | null
    fr_cod_esp: string | null
    fr_cod_var: string | null
    fr_hor_rec: Date | null
    fr_con: string | null
    fr_tip_lot: string | null
    fr_alt_pal: string | null
    fr_cod_env: string | null
    fr_cod_eti: string | null
    fr_cod_emb: string | null
    fr_cod_envop: string | null
    fr_plu: string | null
    fr_caj: number | null
    fr_cod_cat: string | null
    fr_cod_cal: string | null
    fr_nro_mix: number | null
    fr_fec_sem: string | null
    fr_cod_bp: string | null
    fr_cod_pre: string | null
    fr_cod_cua: string | null
    fr_proceso: number | null
    fr_con_fri: string | null
    fr_fol_ori: string | null
    fr_cod_var_eti: string | null
    fr_cod_tip_tra: string | null
    fr_cod_pro_eti: string | null
    fr_cod_exp: string | null
    fr_pk_ori: number | null
    id_tip_io: number | null
    fr_caj_usa: number | null
    fr_tip_mov: string | null
    fr_fec_sag: Date | null
    fr_guia_sag: number | null
    fr_cer_sag: string | null
    fr_sol_sag: string | null
    fr_tip_sag: string | null
    fr_cod_mer: string | null
    fr_cod_mer1: string | null
    fr_cod_mer2: string | null
    fr_cod_mer3: string | null
    fr_cod_mer4: string | null
    fr_fec_fum: Date | null
    fr_guia_fum: number | null
    fr_cer_fum: string | null
    fr_cod_tipo_fum: string | null
    fr_pfrio: string | null
    fr_correlativo_rec: number | null
    fr_cod_linea: string | null
    fr_peso_original: Decimal | null
    _count: Fr_repa_detCountAggregateOutputType | null
    _avg: Fr_repa_detAvgAggregateOutputType | null
    _sum: Fr_repa_detSumAggregateOutputType | null
    _min: Fr_repa_detMinAggregateOutputType | null
    _max: Fr_repa_detMaxAggregateOutputType | null
  }

  type GetFr_repa_detGroupByPayload<T extends fr_repa_detGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Fr_repa_detGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fr_repa_detGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fr_repa_detGroupByOutputType[P]>
            : GetScalarType<T[P], Fr_repa_detGroupByOutputType[P]>
        }
      >
    >


  export type fr_repa_detSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_rep_cab?: boolean
    fr_lote?: boolean
    fr_cor_sdt?: boolean
    fr_pla_sdt?: boolean
    fr_est_sdt?: boolean
    fr_fec_pac?: boolean
    fr_fec_rpa?: boolean
    fr_gui_sdt?: boolean
    fr_cod_pro?: boolean
    fr_cod_esp?: boolean
    fr_cod_var?: boolean
    fr_hor_rec?: boolean
    fr_con?: boolean
    fr_tip_lot?: boolean
    fr_alt_pal?: boolean
    fr_cod_env?: boolean
    fr_cod_eti?: boolean
    fr_cod_emb?: boolean
    fr_cod_envop?: boolean
    fr_plu?: boolean
    fr_caj?: boolean
    fr_cod_cat?: boolean
    fr_cod_cal?: boolean
    fr_nro_mix?: boolean
    fr_fec_sem?: boolean
    fr_cod_bp?: boolean
    fr_cod_pre?: boolean
    fr_cod_cua?: boolean
    fr_proceso?: boolean
    fr_con_fri?: boolean
    fr_fol_ori?: boolean
    fr_cod_var_eti?: boolean
    fr_cod_tip_tra?: boolean
    fr_cod_pro_eti?: boolean
    fr_cod_exp?: boolean
    fr_pk_ori?: boolean
    id_tip_io?: boolean
    fr_caj_usa?: boolean
    fr_tip_mov?: boolean
    fr_fec_sag?: boolean
    fr_guia_sag?: boolean
    fr_cer_sag?: boolean
    fr_sol_sag?: boolean
    fr_tip_sag?: boolean
    fr_cod_mer?: boolean
    fr_cod_mer1?: boolean
    fr_cod_mer2?: boolean
    fr_cod_mer3?: boolean
    fr_cod_mer4?: boolean
    fr_fec_fum?: boolean
    fr_guia_fum?: boolean
    fr_cer_fum?: boolean
    fr_cod_tipo_fum?: boolean
    fr_pfrio?: boolean
    fr_correlativo_rec?: boolean
    fr_cod_linea?: boolean
    fr_peso_original?: boolean
  }, ExtArgs["result"]["fr_repa_det"]>


  export type fr_repa_detSelectScalar = {
    id?: boolean
    id_rep_cab?: boolean
    fr_lote?: boolean
    fr_cor_sdt?: boolean
    fr_pla_sdt?: boolean
    fr_est_sdt?: boolean
    fr_fec_pac?: boolean
    fr_fec_rpa?: boolean
    fr_gui_sdt?: boolean
    fr_cod_pro?: boolean
    fr_cod_esp?: boolean
    fr_cod_var?: boolean
    fr_hor_rec?: boolean
    fr_con?: boolean
    fr_tip_lot?: boolean
    fr_alt_pal?: boolean
    fr_cod_env?: boolean
    fr_cod_eti?: boolean
    fr_cod_emb?: boolean
    fr_cod_envop?: boolean
    fr_plu?: boolean
    fr_caj?: boolean
    fr_cod_cat?: boolean
    fr_cod_cal?: boolean
    fr_nro_mix?: boolean
    fr_fec_sem?: boolean
    fr_cod_bp?: boolean
    fr_cod_pre?: boolean
    fr_cod_cua?: boolean
    fr_proceso?: boolean
    fr_con_fri?: boolean
    fr_fol_ori?: boolean
    fr_cod_var_eti?: boolean
    fr_cod_tip_tra?: boolean
    fr_cod_pro_eti?: boolean
    fr_cod_exp?: boolean
    fr_pk_ori?: boolean
    id_tip_io?: boolean
    fr_caj_usa?: boolean
    fr_tip_mov?: boolean
    fr_fec_sag?: boolean
    fr_guia_sag?: boolean
    fr_cer_sag?: boolean
    fr_sol_sag?: boolean
    fr_tip_sag?: boolean
    fr_cod_mer?: boolean
    fr_cod_mer1?: boolean
    fr_cod_mer2?: boolean
    fr_cod_mer3?: boolean
    fr_cod_mer4?: boolean
    fr_fec_fum?: boolean
    fr_guia_fum?: boolean
    fr_cer_fum?: boolean
    fr_cod_tipo_fum?: boolean
    fr_pfrio?: boolean
    fr_correlativo_rec?: boolean
    fr_cod_linea?: boolean
    fr_peso_original?: boolean
  }


  export type $fr_repa_detPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "fr_repa_det"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      id_rep_cab: number | null
      fr_lote: string | null
      fr_cor_sdt: Prisma.Decimal | null
      fr_pla_sdt: number | null
      fr_est_sdt: string | null
      fr_fec_pac: Date | null
      fr_fec_rpa: Date | null
      fr_gui_sdt: number | null
      fr_cod_pro: string | null
      fr_cod_esp: string | null
      fr_cod_var: string | null
      fr_hor_rec: Date | null
      fr_con: string | null
      fr_tip_lot: string | null
      fr_alt_pal: string | null
      fr_cod_env: string | null
      fr_cod_eti: string | null
      fr_cod_emb: string | null
      fr_cod_envop: string | null
      fr_plu: string | null
      fr_caj: number | null
      fr_cod_cat: string | null
      fr_cod_cal: string | null
      fr_nro_mix: number | null
      fr_fec_sem: string | null
      fr_cod_bp: string | null
      fr_cod_pre: string | null
      fr_cod_cua: string | null
      fr_proceso: number | null
      fr_con_fri: string | null
      fr_fol_ori: string | null
      fr_cod_var_eti: string | null
      fr_cod_tip_tra: string | null
      fr_cod_pro_eti: string | null
      fr_cod_exp: string | null
      fr_pk_ori: number | null
      id_tip_io: number | null
      fr_caj_usa: number | null
      fr_tip_mov: string | null
      fr_fec_sag: Date | null
      fr_guia_sag: number | null
      fr_cer_sag: string | null
      fr_sol_sag: string | null
      fr_tip_sag: string | null
      fr_cod_mer: string | null
      fr_cod_mer1: string | null
      fr_cod_mer2: string | null
      fr_cod_mer3: string | null
      fr_cod_mer4: string | null
      fr_fec_fum: Date | null
      fr_guia_fum: number | null
      fr_cer_fum: string | null
      fr_cod_tipo_fum: string | null
      fr_pfrio: string | null
      fr_correlativo_rec: number | null
      fr_cod_linea: string | null
      fr_peso_original: Prisma.Decimal | null
    }, ExtArgs["result"]["fr_repa_det"]>
    composites: {}
  }

  type fr_repa_detGetPayload<S extends boolean | null | undefined | fr_repa_detDefaultArgs> = $Result.GetResult<Prisma.$fr_repa_detPayload, S>

  type fr_repa_detCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<fr_repa_detFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Fr_repa_detCountAggregateInputType | true
    }

  export interface fr_repa_detDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fr_repa_det'], meta: { name: 'fr_repa_det' } }
    /**
     * Find zero or one Fr_repa_det that matches the filter.
     * @param {fr_repa_detFindUniqueArgs} args - Arguments to find a Fr_repa_det
     * @example
     * // Get one Fr_repa_det
     * const fr_repa_det = await prisma.fr_repa_det.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends fr_repa_detFindUniqueArgs>(args: SelectSubset<T, fr_repa_detFindUniqueArgs<ExtArgs>>): Prisma__fr_repa_detClient<$Result.GetResult<Prisma.$fr_repa_detPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Fr_repa_det that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {fr_repa_detFindUniqueOrThrowArgs} args - Arguments to find a Fr_repa_det
     * @example
     * // Get one Fr_repa_det
     * const fr_repa_det = await prisma.fr_repa_det.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends fr_repa_detFindUniqueOrThrowArgs>(args: SelectSubset<T, fr_repa_detFindUniqueOrThrowArgs<ExtArgs>>): Prisma__fr_repa_detClient<$Result.GetResult<Prisma.$fr_repa_detPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Fr_repa_det that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fr_repa_detFindFirstArgs} args - Arguments to find a Fr_repa_det
     * @example
     * // Get one Fr_repa_det
     * const fr_repa_det = await prisma.fr_repa_det.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends fr_repa_detFindFirstArgs>(args?: SelectSubset<T, fr_repa_detFindFirstArgs<ExtArgs>>): Prisma__fr_repa_detClient<$Result.GetResult<Prisma.$fr_repa_detPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Fr_repa_det that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fr_repa_detFindFirstOrThrowArgs} args - Arguments to find a Fr_repa_det
     * @example
     * // Get one Fr_repa_det
     * const fr_repa_det = await prisma.fr_repa_det.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends fr_repa_detFindFirstOrThrowArgs>(args?: SelectSubset<T, fr_repa_detFindFirstOrThrowArgs<ExtArgs>>): Prisma__fr_repa_detClient<$Result.GetResult<Prisma.$fr_repa_detPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Fr_repa_dets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fr_repa_detFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fr_repa_dets
     * const fr_repa_dets = await prisma.fr_repa_det.findMany()
     * 
     * // Get first 10 Fr_repa_dets
     * const fr_repa_dets = await prisma.fr_repa_det.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fr_repa_detWithIdOnly = await prisma.fr_repa_det.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends fr_repa_detFindManyArgs>(args?: SelectSubset<T, fr_repa_detFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fr_repa_detPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Fr_repa_det.
     * @param {fr_repa_detCreateArgs} args - Arguments to create a Fr_repa_det.
     * @example
     * // Create one Fr_repa_det
     * const Fr_repa_det = await prisma.fr_repa_det.create({
     *   data: {
     *     // ... data to create a Fr_repa_det
     *   }
     * })
     * 
     */
    create<T extends fr_repa_detCreateArgs>(args: SelectSubset<T, fr_repa_detCreateArgs<ExtArgs>>): Prisma__fr_repa_detClient<$Result.GetResult<Prisma.$fr_repa_detPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Fr_repa_dets.
     * @param {fr_repa_detCreateManyArgs} args - Arguments to create many Fr_repa_dets.
     * @example
     * // Create many Fr_repa_dets
     * const fr_repa_det = await prisma.fr_repa_det.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends fr_repa_detCreateManyArgs>(args?: SelectSubset<T, fr_repa_detCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fr_repa_det.
     * @param {fr_repa_detDeleteArgs} args - Arguments to delete one Fr_repa_det.
     * @example
     * // Delete one Fr_repa_det
     * const Fr_repa_det = await prisma.fr_repa_det.delete({
     *   where: {
     *     // ... filter to delete one Fr_repa_det
     *   }
     * })
     * 
     */
    delete<T extends fr_repa_detDeleteArgs>(args: SelectSubset<T, fr_repa_detDeleteArgs<ExtArgs>>): Prisma__fr_repa_detClient<$Result.GetResult<Prisma.$fr_repa_detPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Fr_repa_det.
     * @param {fr_repa_detUpdateArgs} args - Arguments to update one Fr_repa_det.
     * @example
     * // Update one Fr_repa_det
     * const fr_repa_det = await prisma.fr_repa_det.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends fr_repa_detUpdateArgs>(args: SelectSubset<T, fr_repa_detUpdateArgs<ExtArgs>>): Prisma__fr_repa_detClient<$Result.GetResult<Prisma.$fr_repa_detPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Fr_repa_dets.
     * @param {fr_repa_detDeleteManyArgs} args - Arguments to filter Fr_repa_dets to delete.
     * @example
     * // Delete a few Fr_repa_dets
     * const { count } = await prisma.fr_repa_det.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends fr_repa_detDeleteManyArgs>(args?: SelectSubset<T, fr_repa_detDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fr_repa_dets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fr_repa_detUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fr_repa_dets
     * const fr_repa_det = await prisma.fr_repa_det.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends fr_repa_detUpdateManyArgs>(args: SelectSubset<T, fr_repa_detUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fr_repa_det.
     * @param {fr_repa_detUpsertArgs} args - Arguments to update or create a Fr_repa_det.
     * @example
     * // Update or create a Fr_repa_det
     * const fr_repa_det = await prisma.fr_repa_det.upsert({
     *   create: {
     *     // ... data to create a Fr_repa_det
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fr_repa_det we want to update
     *   }
     * })
     */
    upsert<T extends fr_repa_detUpsertArgs>(args: SelectSubset<T, fr_repa_detUpsertArgs<ExtArgs>>): Prisma__fr_repa_detClient<$Result.GetResult<Prisma.$fr_repa_detPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Fr_repa_dets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fr_repa_detCountArgs} args - Arguments to filter Fr_repa_dets to count.
     * @example
     * // Count the number of Fr_repa_dets
     * const count = await prisma.fr_repa_det.count({
     *   where: {
     *     // ... the filter for the Fr_repa_dets we want to count
     *   }
     * })
    **/
    count<T extends fr_repa_detCountArgs>(
      args?: Subset<T, fr_repa_detCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fr_repa_detCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fr_repa_det.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fr_repa_detAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fr_repa_detAggregateArgs>(args: Subset<T, Fr_repa_detAggregateArgs>): Prisma.PrismaPromise<GetFr_repa_detAggregateType<T>>

    /**
     * Group by Fr_repa_det.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fr_repa_detGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fr_repa_detGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fr_repa_detGroupByArgs['orderBy'] }
        : { orderBy?: fr_repa_detGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fr_repa_detGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFr_repa_detGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the fr_repa_det model
   */
  readonly fields: fr_repa_detFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fr_repa_det.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__fr_repa_detClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the fr_repa_det model
   */ 
  interface fr_repa_detFieldRefs {
    readonly id: FieldRef<"fr_repa_det", 'Int'>
    readonly id_rep_cab: FieldRef<"fr_repa_det", 'Int'>
    readonly fr_lote: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cor_sdt: FieldRef<"fr_repa_det", 'Decimal'>
    readonly fr_pla_sdt: FieldRef<"fr_repa_det", 'Int'>
    readonly fr_est_sdt: FieldRef<"fr_repa_det", 'String'>
    readonly fr_fec_pac: FieldRef<"fr_repa_det", 'DateTime'>
    readonly fr_fec_rpa: FieldRef<"fr_repa_det", 'DateTime'>
    readonly fr_gui_sdt: FieldRef<"fr_repa_det", 'Int'>
    readonly fr_cod_pro: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_esp: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_var: FieldRef<"fr_repa_det", 'String'>
    readonly fr_hor_rec: FieldRef<"fr_repa_det", 'DateTime'>
    readonly fr_con: FieldRef<"fr_repa_det", 'String'>
    readonly fr_tip_lot: FieldRef<"fr_repa_det", 'String'>
    readonly fr_alt_pal: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_env: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_eti: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_emb: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_envop: FieldRef<"fr_repa_det", 'String'>
    readonly fr_plu: FieldRef<"fr_repa_det", 'String'>
    readonly fr_caj: FieldRef<"fr_repa_det", 'Int'>
    readonly fr_cod_cat: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_cal: FieldRef<"fr_repa_det", 'String'>
    readonly fr_nro_mix: FieldRef<"fr_repa_det", 'Int'>
    readonly fr_fec_sem: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_bp: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_pre: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_cua: FieldRef<"fr_repa_det", 'String'>
    readonly fr_proceso: FieldRef<"fr_repa_det", 'Int'>
    readonly fr_con_fri: FieldRef<"fr_repa_det", 'String'>
    readonly fr_fol_ori: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_var_eti: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_tip_tra: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_pro_eti: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_exp: FieldRef<"fr_repa_det", 'String'>
    readonly fr_pk_ori: FieldRef<"fr_repa_det", 'Int'>
    readonly id_tip_io: FieldRef<"fr_repa_det", 'Int'>
    readonly fr_caj_usa: FieldRef<"fr_repa_det", 'Int'>
    readonly fr_tip_mov: FieldRef<"fr_repa_det", 'String'>
    readonly fr_fec_sag: FieldRef<"fr_repa_det", 'DateTime'>
    readonly fr_guia_sag: FieldRef<"fr_repa_det", 'Int'>
    readonly fr_cer_sag: FieldRef<"fr_repa_det", 'String'>
    readonly fr_sol_sag: FieldRef<"fr_repa_det", 'String'>
    readonly fr_tip_sag: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_mer: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_mer1: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_mer2: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_mer3: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_mer4: FieldRef<"fr_repa_det", 'String'>
    readonly fr_fec_fum: FieldRef<"fr_repa_det", 'DateTime'>
    readonly fr_guia_fum: FieldRef<"fr_repa_det", 'Int'>
    readonly fr_cer_fum: FieldRef<"fr_repa_det", 'String'>
    readonly fr_cod_tipo_fum: FieldRef<"fr_repa_det", 'String'>
    readonly fr_pfrio: FieldRef<"fr_repa_det", 'String'>
    readonly fr_correlativo_rec: FieldRef<"fr_repa_det", 'Int'>
    readonly fr_cod_linea: FieldRef<"fr_repa_det", 'String'>
    readonly fr_peso_original: FieldRef<"fr_repa_det", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * fr_repa_det findUnique
   */
  export type fr_repa_detFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_det
     */
    select?: fr_repa_detSelect<ExtArgs> | null
    /**
     * Filter, which fr_repa_det to fetch.
     */
    where: fr_repa_detWhereUniqueInput
  }

  /**
   * fr_repa_det findUniqueOrThrow
   */
  export type fr_repa_detFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_det
     */
    select?: fr_repa_detSelect<ExtArgs> | null
    /**
     * Filter, which fr_repa_det to fetch.
     */
    where: fr_repa_detWhereUniqueInput
  }

  /**
   * fr_repa_det findFirst
   */
  export type fr_repa_detFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_det
     */
    select?: fr_repa_detSelect<ExtArgs> | null
    /**
     * Filter, which fr_repa_det to fetch.
     */
    where?: fr_repa_detWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fr_repa_dets to fetch.
     */
    orderBy?: fr_repa_detOrderByWithRelationInput | fr_repa_detOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fr_repa_dets.
     */
    cursor?: fr_repa_detWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fr_repa_dets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fr_repa_dets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fr_repa_dets.
     */
    distinct?: Fr_repa_detScalarFieldEnum | Fr_repa_detScalarFieldEnum[]
  }

  /**
   * fr_repa_det findFirstOrThrow
   */
  export type fr_repa_detFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_det
     */
    select?: fr_repa_detSelect<ExtArgs> | null
    /**
     * Filter, which fr_repa_det to fetch.
     */
    where?: fr_repa_detWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fr_repa_dets to fetch.
     */
    orderBy?: fr_repa_detOrderByWithRelationInput | fr_repa_detOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fr_repa_dets.
     */
    cursor?: fr_repa_detWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fr_repa_dets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fr_repa_dets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fr_repa_dets.
     */
    distinct?: Fr_repa_detScalarFieldEnum | Fr_repa_detScalarFieldEnum[]
  }

  /**
   * fr_repa_det findMany
   */
  export type fr_repa_detFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_det
     */
    select?: fr_repa_detSelect<ExtArgs> | null
    /**
     * Filter, which fr_repa_dets to fetch.
     */
    where?: fr_repa_detWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fr_repa_dets to fetch.
     */
    orderBy?: fr_repa_detOrderByWithRelationInput | fr_repa_detOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fr_repa_dets.
     */
    cursor?: fr_repa_detWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fr_repa_dets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fr_repa_dets.
     */
    skip?: number
    distinct?: Fr_repa_detScalarFieldEnum | Fr_repa_detScalarFieldEnum[]
  }

  /**
   * fr_repa_det create
   */
  export type fr_repa_detCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_det
     */
    select?: fr_repa_detSelect<ExtArgs> | null
    /**
     * The data needed to create a fr_repa_det.
     */
    data?: XOR<fr_repa_detCreateInput, fr_repa_detUncheckedCreateInput>
  }

  /**
   * fr_repa_det createMany
   */
  export type fr_repa_detCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fr_repa_dets.
     */
    data: fr_repa_detCreateManyInput | fr_repa_detCreateManyInput[]
  }

  /**
   * fr_repa_det update
   */
  export type fr_repa_detUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_det
     */
    select?: fr_repa_detSelect<ExtArgs> | null
    /**
     * The data needed to update a fr_repa_det.
     */
    data: XOR<fr_repa_detUpdateInput, fr_repa_detUncheckedUpdateInput>
    /**
     * Choose, which fr_repa_det to update.
     */
    where: fr_repa_detWhereUniqueInput
  }

  /**
   * fr_repa_det updateMany
   */
  export type fr_repa_detUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fr_repa_dets.
     */
    data: XOR<fr_repa_detUpdateManyMutationInput, fr_repa_detUncheckedUpdateManyInput>
    /**
     * Filter which fr_repa_dets to update
     */
    where?: fr_repa_detWhereInput
  }

  /**
   * fr_repa_det upsert
   */
  export type fr_repa_detUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_det
     */
    select?: fr_repa_detSelect<ExtArgs> | null
    /**
     * The filter to search for the fr_repa_det to update in case it exists.
     */
    where: fr_repa_detWhereUniqueInput
    /**
     * In case the fr_repa_det found by the `where` argument doesn't exist, create a new fr_repa_det with this data.
     */
    create: XOR<fr_repa_detCreateInput, fr_repa_detUncheckedCreateInput>
    /**
     * In case the fr_repa_det was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fr_repa_detUpdateInput, fr_repa_detUncheckedUpdateInput>
  }

  /**
   * fr_repa_det delete
   */
  export type fr_repa_detDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_det
     */
    select?: fr_repa_detSelect<ExtArgs> | null
    /**
     * Filter which fr_repa_det to delete.
     */
    where: fr_repa_detWhereUniqueInput
  }

  /**
   * fr_repa_det deleteMany
   */
  export type fr_repa_detDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fr_repa_dets to delete
     */
    where?: fr_repa_detWhereInput
  }

  /**
   * fr_repa_det without action
   */
  export type fr_repa_detDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fr_repa_det
     */
    select?: fr_repa_detSelect<ExtArgs> | null
  }


  /**
   * Model Gr_Tipo_Cobro
   */

  export type AggregateGr_Tipo_Cobro = {
    _count: Gr_Tipo_CobroCountAggregateOutputType | null
    _avg: Gr_Tipo_CobroAvgAggregateOutputType | null
    _sum: Gr_Tipo_CobroSumAggregateOutputType | null
    _min: Gr_Tipo_CobroMinAggregateOutputType | null
    _max: Gr_Tipo_CobroMaxAggregateOutputType | null
  }

  export type Gr_Tipo_CobroAvgAggregateOutputType = {
    id: number | null
    tipo_c: number | null
  }

  export type Gr_Tipo_CobroSumAggregateOutputType = {
    id: number | null
    tipo_c: number | null
  }

  export type Gr_Tipo_CobroMinAggregateOutputType = {
    id: number | null
    Descripcion: string | null
    tipo_c: number | null
  }

  export type Gr_Tipo_CobroMaxAggregateOutputType = {
    id: number | null
    Descripcion: string | null
    tipo_c: number | null
  }

  export type Gr_Tipo_CobroCountAggregateOutputType = {
    id: number
    Descripcion: number
    tipo_c: number
    _all: number
  }


  export type Gr_Tipo_CobroAvgAggregateInputType = {
    id?: true
    tipo_c?: true
  }

  export type Gr_Tipo_CobroSumAggregateInputType = {
    id?: true
    tipo_c?: true
  }

  export type Gr_Tipo_CobroMinAggregateInputType = {
    id?: true
    Descripcion?: true
    tipo_c?: true
  }

  export type Gr_Tipo_CobroMaxAggregateInputType = {
    id?: true
    Descripcion?: true
    tipo_c?: true
  }

  export type Gr_Tipo_CobroCountAggregateInputType = {
    id?: true
    Descripcion?: true
    tipo_c?: true
    _all?: true
  }

  export type Gr_Tipo_CobroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gr_Tipo_Cobro to aggregate.
     */
    where?: Gr_Tipo_CobroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gr_Tipo_Cobros to fetch.
     */
    orderBy?: Gr_Tipo_CobroOrderByWithRelationInput | Gr_Tipo_CobroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Gr_Tipo_CobroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gr_Tipo_Cobros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gr_Tipo_Cobros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gr_Tipo_Cobros
    **/
    _count?: true | Gr_Tipo_CobroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Gr_Tipo_CobroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Gr_Tipo_CobroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gr_Tipo_CobroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gr_Tipo_CobroMaxAggregateInputType
  }

  export type GetGr_Tipo_CobroAggregateType<T extends Gr_Tipo_CobroAggregateArgs> = {
        [P in keyof T & keyof AggregateGr_Tipo_Cobro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGr_Tipo_Cobro[P]>
      : GetScalarType<T[P], AggregateGr_Tipo_Cobro[P]>
  }




  export type Gr_Tipo_CobroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Gr_Tipo_CobroWhereInput
    orderBy?: Gr_Tipo_CobroOrderByWithAggregationInput | Gr_Tipo_CobroOrderByWithAggregationInput[]
    by: Gr_Tipo_CobroScalarFieldEnum[] | Gr_Tipo_CobroScalarFieldEnum
    having?: Gr_Tipo_CobroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gr_Tipo_CobroCountAggregateInputType | true
    _avg?: Gr_Tipo_CobroAvgAggregateInputType
    _sum?: Gr_Tipo_CobroSumAggregateInputType
    _min?: Gr_Tipo_CobroMinAggregateInputType
    _max?: Gr_Tipo_CobroMaxAggregateInputType
  }

  export type Gr_Tipo_CobroGroupByOutputType = {
    id: number
    Descripcion: string | null
    tipo_c: number | null
    _count: Gr_Tipo_CobroCountAggregateOutputType | null
    _avg: Gr_Tipo_CobroAvgAggregateOutputType | null
    _sum: Gr_Tipo_CobroSumAggregateOutputType | null
    _min: Gr_Tipo_CobroMinAggregateOutputType | null
    _max: Gr_Tipo_CobroMaxAggregateOutputType | null
  }

  type GetGr_Tipo_CobroGroupByPayload<T extends Gr_Tipo_CobroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Gr_Tipo_CobroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gr_Tipo_CobroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gr_Tipo_CobroGroupByOutputType[P]>
            : GetScalarType<T[P], Gr_Tipo_CobroGroupByOutputType[P]>
        }
      >
    >


  export type Gr_Tipo_CobroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Descripcion?: boolean
    tipo_c?: boolean
  }, ExtArgs["result"]["gr_Tipo_Cobro"]>


  export type Gr_Tipo_CobroSelectScalar = {
    id?: boolean
    Descripcion?: boolean
    tipo_c?: boolean
  }


  export type $Gr_Tipo_CobroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gr_Tipo_Cobro"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      Descripcion: string | null
      tipo_c: number | null
    }, ExtArgs["result"]["gr_Tipo_Cobro"]>
    composites: {}
  }

  type Gr_Tipo_CobroGetPayload<S extends boolean | null | undefined | Gr_Tipo_CobroDefaultArgs> = $Result.GetResult<Prisma.$Gr_Tipo_CobroPayload, S>

  type Gr_Tipo_CobroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Gr_Tipo_CobroFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Gr_Tipo_CobroCountAggregateInputType | true
    }

  export interface Gr_Tipo_CobroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gr_Tipo_Cobro'], meta: { name: 'Gr_Tipo_Cobro' } }
    /**
     * Find zero or one Gr_Tipo_Cobro that matches the filter.
     * @param {Gr_Tipo_CobroFindUniqueArgs} args - Arguments to find a Gr_Tipo_Cobro
     * @example
     * // Get one Gr_Tipo_Cobro
     * const gr_Tipo_Cobro = await prisma.gr_Tipo_Cobro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Gr_Tipo_CobroFindUniqueArgs>(args: SelectSubset<T, Gr_Tipo_CobroFindUniqueArgs<ExtArgs>>): Prisma__Gr_Tipo_CobroClient<$Result.GetResult<Prisma.$Gr_Tipo_CobroPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Gr_Tipo_Cobro that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Gr_Tipo_CobroFindUniqueOrThrowArgs} args - Arguments to find a Gr_Tipo_Cobro
     * @example
     * // Get one Gr_Tipo_Cobro
     * const gr_Tipo_Cobro = await prisma.gr_Tipo_Cobro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Gr_Tipo_CobroFindUniqueOrThrowArgs>(args: SelectSubset<T, Gr_Tipo_CobroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Gr_Tipo_CobroClient<$Result.GetResult<Prisma.$Gr_Tipo_CobroPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Gr_Tipo_Cobro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gr_Tipo_CobroFindFirstArgs} args - Arguments to find a Gr_Tipo_Cobro
     * @example
     * // Get one Gr_Tipo_Cobro
     * const gr_Tipo_Cobro = await prisma.gr_Tipo_Cobro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Gr_Tipo_CobroFindFirstArgs>(args?: SelectSubset<T, Gr_Tipo_CobroFindFirstArgs<ExtArgs>>): Prisma__Gr_Tipo_CobroClient<$Result.GetResult<Prisma.$Gr_Tipo_CobroPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Gr_Tipo_Cobro that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gr_Tipo_CobroFindFirstOrThrowArgs} args - Arguments to find a Gr_Tipo_Cobro
     * @example
     * // Get one Gr_Tipo_Cobro
     * const gr_Tipo_Cobro = await prisma.gr_Tipo_Cobro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Gr_Tipo_CobroFindFirstOrThrowArgs>(args?: SelectSubset<T, Gr_Tipo_CobroFindFirstOrThrowArgs<ExtArgs>>): Prisma__Gr_Tipo_CobroClient<$Result.GetResult<Prisma.$Gr_Tipo_CobroPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Gr_Tipo_Cobros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gr_Tipo_CobroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gr_Tipo_Cobros
     * const gr_Tipo_Cobros = await prisma.gr_Tipo_Cobro.findMany()
     * 
     * // Get first 10 Gr_Tipo_Cobros
     * const gr_Tipo_Cobros = await prisma.gr_Tipo_Cobro.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gr_Tipo_CobroWithIdOnly = await prisma.gr_Tipo_Cobro.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Gr_Tipo_CobroFindManyArgs>(args?: SelectSubset<T, Gr_Tipo_CobroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Gr_Tipo_CobroPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Gr_Tipo_Cobro.
     * @param {Gr_Tipo_CobroCreateArgs} args - Arguments to create a Gr_Tipo_Cobro.
     * @example
     * // Create one Gr_Tipo_Cobro
     * const Gr_Tipo_Cobro = await prisma.gr_Tipo_Cobro.create({
     *   data: {
     *     // ... data to create a Gr_Tipo_Cobro
     *   }
     * })
     * 
     */
    create<T extends Gr_Tipo_CobroCreateArgs>(args: SelectSubset<T, Gr_Tipo_CobroCreateArgs<ExtArgs>>): Prisma__Gr_Tipo_CobroClient<$Result.GetResult<Prisma.$Gr_Tipo_CobroPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Gr_Tipo_Cobros.
     * @param {Gr_Tipo_CobroCreateManyArgs} args - Arguments to create many Gr_Tipo_Cobros.
     * @example
     * // Create many Gr_Tipo_Cobros
     * const gr_Tipo_Cobro = await prisma.gr_Tipo_Cobro.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Gr_Tipo_CobroCreateManyArgs>(args?: SelectSubset<T, Gr_Tipo_CobroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gr_Tipo_Cobro.
     * @param {Gr_Tipo_CobroDeleteArgs} args - Arguments to delete one Gr_Tipo_Cobro.
     * @example
     * // Delete one Gr_Tipo_Cobro
     * const Gr_Tipo_Cobro = await prisma.gr_Tipo_Cobro.delete({
     *   where: {
     *     // ... filter to delete one Gr_Tipo_Cobro
     *   }
     * })
     * 
     */
    delete<T extends Gr_Tipo_CobroDeleteArgs>(args: SelectSubset<T, Gr_Tipo_CobroDeleteArgs<ExtArgs>>): Prisma__Gr_Tipo_CobroClient<$Result.GetResult<Prisma.$Gr_Tipo_CobroPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Gr_Tipo_Cobro.
     * @param {Gr_Tipo_CobroUpdateArgs} args - Arguments to update one Gr_Tipo_Cobro.
     * @example
     * // Update one Gr_Tipo_Cobro
     * const gr_Tipo_Cobro = await prisma.gr_Tipo_Cobro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Gr_Tipo_CobroUpdateArgs>(args: SelectSubset<T, Gr_Tipo_CobroUpdateArgs<ExtArgs>>): Prisma__Gr_Tipo_CobroClient<$Result.GetResult<Prisma.$Gr_Tipo_CobroPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Gr_Tipo_Cobros.
     * @param {Gr_Tipo_CobroDeleteManyArgs} args - Arguments to filter Gr_Tipo_Cobros to delete.
     * @example
     * // Delete a few Gr_Tipo_Cobros
     * const { count } = await prisma.gr_Tipo_Cobro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Gr_Tipo_CobroDeleteManyArgs>(args?: SelectSubset<T, Gr_Tipo_CobroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gr_Tipo_Cobros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gr_Tipo_CobroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gr_Tipo_Cobros
     * const gr_Tipo_Cobro = await prisma.gr_Tipo_Cobro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Gr_Tipo_CobroUpdateManyArgs>(args: SelectSubset<T, Gr_Tipo_CobroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gr_Tipo_Cobro.
     * @param {Gr_Tipo_CobroUpsertArgs} args - Arguments to update or create a Gr_Tipo_Cobro.
     * @example
     * // Update or create a Gr_Tipo_Cobro
     * const gr_Tipo_Cobro = await prisma.gr_Tipo_Cobro.upsert({
     *   create: {
     *     // ... data to create a Gr_Tipo_Cobro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gr_Tipo_Cobro we want to update
     *   }
     * })
     */
    upsert<T extends Gr_Tipo_CobroUpsertArgs>(args: SelectSubset<T, Gr_Tipo_CobroUpsertArgs<ExtArgs>>): Prisma__Gr_Tipo_CobroClient<$Result.GetResult<Prisma.$Gr_Tipo_CobroPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Gr_Tipo_Cobros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gr_Tipo_CobroCountArgs} args - Arguments to filter Gr_Tipo_Cobros to count.
     * @example
     * // Count the number of Gr_Tipo_Cobros
     * const count = await prisma.gr_Tipo_Cobro.count({
     *   where: {
     *     // ... the filter for the Gr_Tipo_Cobros we want to count
     *   }
     * })
    **/
    count<T extends Gr_Tipo_CobroCountArgs>(
      args?: Subset<T, Gr_Tipo_CobroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gr_Tipo_CobroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gr_Tipo_Cobro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gr_Tipo_CobroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gr_Tipo_CobroAggregateArgs>(args: Subset<T, Gr_Tipo_CobroAggregateArgs>): Prisma.PrismaPromise<GetGr_Tipo_CobroAggregateType<T>>

    /**
     * Group by Gr_Tipo_Cobro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gr_Tipo_CobroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Gr_Tipo_CobroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Gr_Tipo_CobroGroupByArgs['orderBy'] }
        : { orderBy?: Gr_Tipo_CobroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Gr_Tipo_CobroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGr_Tipo_CobroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gr_Tipo_Cobro model
   */
  readonly fields: Gr_Tipo_CobroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gr_Tipo_Cobro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Gr_Tipo_CobroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gr_Tipo_Cobro model
   */ 
  interface Gr_Tipo_CobroFieldRefs {
    readonly id: FieldRef<"Gr_Tipo_Cobro", 'Int'>
    readonly Descripcion: FieldRef<"Gr_Tipo_Cobro", 'String'>
    readonly tipo_c: FieldRef<"Gr_Tipo_Cobro", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Gr_Tipo_Cobro findUnique
   */
  export type Gr_Tipo_CobroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gr_Tipo_Cobro
     */
    select?: Gr_Tipo_CobroSelect<ExtArgs> | null
    /**
     * Filter, which Gr_Tipo_Cobro to fetch.
     */
    where: Gr_Tipo_CobroWhereUniqueInput
  }

  /**
   * Gr_Tipo_Cobro findUniqueOrThrow
   */
  export type Gr_Tipo_CobroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gr_Tipo_Cobro
     */
    select?: Gr_Tipo_CobroSelect<ExtArgs> | null
    /**
     * Filter, which Gr_Tipo_Cobro to fetch.
     */
    where: Gr_Tipo_CobroWhereUniqueInput
  }

  /**
   * Gr_Tipo_Cobro findFirst
   */
  export type Gr_Tipo_CobroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gr_Tipo_Cobro
     */
    select?: Gr_Tipo_CobroSelect<ExtArgs> | null
    /**
     * Filter, which Gr_Tipo_Cobro to fetch.
     */
    where?: Gr_Tipo_CobroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gr_Tipo_Cobros to fetch.
     */
    orderBy?: Gr_Tipo_CobroOrderByWithRelationInput | Gr_Tipo_CobroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gr_Tipo_Cobros.
     */
    cursor?: Gr_Tipo_CobroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gr_Tipo_Cobros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gr_Tipo_Cobros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gr_Tipo_Cobros.
     */
    distinct?: Gr_Tipo_CobroScalarFieldEnum | Gr_Tipo_CobroScalarFieldEnum[]
  }

  /**
   * Gr_Tipo_Cobro findFirstOrThrow
   */
  export type Gr_Tipo_CobroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gr_Tipo_Cobro
     */
    select?: Gr_Tipo_CobroSelect<ExtArgs> | null
    /**
     * Filter, which Gr_Tipo_Cobro to fetch.
     */
    where?: Gr_Tipo_CobroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gr_Tipo_Cobros to fetch.
     */
    orderBy?: Gr_Tipo_CobroOrderByWithRelationInput | Gr_Tipo_CobroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gr_Tipo_Cobros.
     */
    cursor?: Gr_Tipo_CobroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gr_Tipo_Cobros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gr_Tipo_Cobros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gr_Tipo_Cobros.
     */
    distinct?: Gr_Tipo_CobroScalarFieldEnum | Gr_Tipo_CobroScalarFieldEnum[]
  }

  /**
   * Gr_Tipo_Cobro findMany
   */
  export type Gr_Tipo_CobroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gr_Tipo_Cobro
     */
    select?: Gr_Tipo_CobroSelect<ExtArgs> | null
    /**
     * Filter, which Gr_Tipo_Cobros to fetch.
     */
    where?: Gr_Tipo_CobroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gr_Tipo_Cobros to fetch.
     */
    orderBy?: Gr_Tipo_CobroOrderByWithRelationInput | Gr_Tipo_CobroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gr_Tipo_Cobros.
     */
    cursor?: Gr_Tipo_CobroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gr_Tipo_Cobros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gr_Tipo_Cobros.
     */
    skip?: number
    distinct?: Gr_Tipo_CobroScalarFieldEnum | Gr_Tipo_CobroScalarFieldEnum[]
  }

  /**
   * Gr_Tipo_Cobro create
   */
  export type Gr_Tipo_CobroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gr_Tipo_Cobro
     */
    select?: Gr_Tipo_CobroSelect<ExtArgs> | null
    /**
     * The data needed to create a Gr_Tipo_Cobro.
     */
    data?: XOR<Gr_Tipo_CobroCreateInput, Gr_Tipo_CobroUncheckedCreateInput>
  }

  /**
   * Gr_Tipo_Cobro createMany
   */
  export type Gr_Tipo_CobroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gr_Tipo_Cobros.
     */
    data: Gr_Tipo_CobroCreateManyInput | Gr_Tipo_CobroCreateManyInput[]
  }

  /**
   * Gr_Tipo_Cobro update
   */
  export type Gr_Tipo_CobroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gr_Tipo_Cobro
     */
    select?: Gr_Tipo_CobroSelect<ExtArgs> | null
    /**
     * The data needed to update a Gr_Tipo_Cobro.
     */
    data: XOR<Gr_Tipo_CobroUpdateInput, Gr_Tipo_CobroUncheckedUpdateInput>
    /**
     * Choose, which Gr_Tipo_Cobro to update.
     */
    where: Gr_Tipo_CobroWhereUniqueInput
  }

  /**
   * Gr_Tipo_Cobro updateMany
   */
  export type Gr_Tipo_CobroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gr_Tipo_Cobros.
     */
    data: XOR<Gr_Tipo_CobroUpdateManyMutationInput, Gr_Tipo_CobroUncheckedUpdateManyInput>
    /**
     * Filter which Gr_Tipo_Cobros to update
     */
    where?: Gr_Tipo_CobroWhereInput
  }

  /**
   * Gr_Tipo_Cobro upsert
   */
  export type Gr_Tipo_CobroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gr_Tipo_Cobro
     */
    select?: Gr_Tipo_CobroSelect<ExtArgs> | null
    /**
     * The filter to search for the Gr_Tipo_Cobro to update in case it exists.
     */
    where: Gr_Tipo_CobroWhereUniqueInput
    /**
     * In case the Gr_Tipo_Cobro found by the `where` argument doesn't exist, create a new Gr_Tipo_Cobro with this data.
     */
    create: XOR<Gr_Tipo_CobroCreateInput, Gr_Tipo_CobroUncheckedCreateInput>
    /**
     * In case the Gr_Tipo_Cobro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Gr_Tipo_CobroUpdateInput, Gr_Tipo_CobroUncheckedUpdateInput>
  }

  /**
   * Gr_Tipo_Cobro delete
   */
  export type Gr_Tipo_CobroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gr_Tipo_Cobro
     */
    select?: Gr_Tipo_CobroSelect<ExtArgs> | null
    /**
     * Filter which Gr_Tipo_Cobro to delete.
     */
    where: Gr_Tipo_CobroWhereUniqueInput
  }

  /**
   * Gr_Tipo_Cobro deleteMany
   */
  export type Gr_Tipo_CobroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gr_Tipo_Cobros to delete
     */
    where?: Gr_Tipo_CobroWhereInput
  }

  /**
   * Gr_Tipo_Cobro without action
   */
  export type Gr_Tipo_CobroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gr_Tipo_Cobro
     */
    select?: Gr_Tipo_CobroSelect<ExtArgs> | null
  }


  /**
   * Model insp_cab
   */

  export type AggregateInsp_cab = {
    _count: Insp_cabCountAggregateOutputType | null
    _avg: Insp_cabAvgAggregateOutputType | null
    _sum: Insp_cabSumAggregateOutputType | null
    _min: Insp_cabMinAggregateOutputType | null
    _max: Insp_cabMaxAggregateOutputType | null
  }

  export type Insp_cabAvgAggregateOutputType = {
    id_ins: number | null
    nro_sag: number | null
    id_tip_ins: number | null
    id_est_ins: number | null
  }

  export type Insp_cabSumAggregateOutputType = {
    id_ins: number | null
    nro_sag: number | null
    id_tip_ins: number | null
    id_est_ins: number | null
  }

  export type Insp_cabMinAggregateOutputType = {
    id_ins: number | null
    nro_sag: number | null
    cod_csp: string | null
    id_tip_ins: number | null
    fec_doc: Date | null
    fec_ins: Date | null
    id_usuario: string | null
    cod_mer: string | null
    cod_mer1: string | null
    cod_mer2: string | null
    cod_mer3: string | null
    obs_insp: string | null
    id_est_ins: number | null
  }

  export type Insp_cabMaxAggregateOutputType = {
    id_ins: number | null
    nro_sag: number | null
    cod_csp: string | null
    id_tip_ins: number | null
    fec_doc: Date | null
    fec_ins: Date | null
    id_usuario: string | null
    cod_mer: string | null
    cod_mer1: string | null
    cod_mer2: string | null
    cod_mer3: string | null
    obs_insp: string | null
    id_est_ins: number | null
  }

  export type Insp_cabCountAggregateOutputType = {
    id_ins: number
    nro_sag: number
    cod_csp: number
    id_tip_ins: number
    fec_doc: number
    fec_ins: number
    id_usuario: number
    cod_mer: number
    cod_mer1: number
    cod_mer2: number
    cod_mer3: number
    obs_insp: number
    id_est_ins: number
    _all: number
  }


  export type Insp_cabAvgAggregateInputType = {
    id_ins?: true
    nro_sag?: true
    id_tip_ins?: true
    id_est_ins?: true
  }

  export type Insp_cabSumAggregateInputType = {
    id_ins?: true
    nro_sag?: true
    id_tip_ins?: true
    id_est_ins?: true
  }

  export type Insp_cabMinAggregateInputType = {
    id_ins?: true
    nro_sag?: true
    cod_csp?: true
    id_tip_ins?: true
    fec_doc?: true
    fec_ins?: true
    id_usuario?: true
    cod_mer?: true
    cod_mer1?: true
    cod_mer2?: true
    cod_mer3?: true
    obs_insp?: true
    id_est_ins?: true
  }

  export type Insp_cabMaxAggregateInputType = {
    id_ins?: true
    nro_sag?: true
    cod_csp?: true
    id_tip_ins?: true
    fec_doc?: true
    fec_ins?: true
    id_usuario?: true
    cod_mer?: true
    cod_mer1?: true
    cod_mer2?: true
    cod_mer3?: true
    obs_insp?: true
    id_est_ins?: true
  }

  export type Insp_cabCountAggregateInputType = {
    id_ins?: true
    nro_sag?: true
    cod_csp?: true
    id_tip_ins?: true
    fec_doc?: true
    fec_ins?: true
    id_usuario?: true
    cod_mer?: true
    cod_mer1?: true
    cod_mer2?: true
    cod_mer3?: true
    obs_insp?: true
    id_est_ins?: true
    _all?: true
  }

  export type Insp_cabAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which insp_cab to aggregate.
     */
    where?: insp_cabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of insp_cabs to fetch.
     */
    orderBy?: insp_cabOrderByWithRelationInput | insp_cabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: insp_cabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` insp_cabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` insp_cabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned insp_cabs
    **/
    _count?: true | Insp_cabCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Insp_cabAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Insp_cabSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Insp_cabMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Insp_cabMaxAggregateInputType
  }

  export type GetInsp_cabAggregateType<T extends Insp_cabAggregateArgs> = {
        [P in keyof T & keyof AggregateInsp_cab]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsp_cab[P]>
      : GetScalarType<T[P], AggregateInsp_cab[P]>
  }




  export type insp_cabGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: insp_cabWhereInput
    orderBy?: insp_cabOrderByWithAggregationInput | insp_cabOrderByWithAggregationInput[]
    by: Insp_cabScalarFieldEnum[] | Insp_cabScalarFieldEnum
    having?: insp_cabScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Insp_cabCountAggregateInputType | true
    _avg?: Insp_cabAvgAggregateInputType
    _sum?: Insp_cabSumAggregateInputType
    _min?: Insp_cabMinAggregateInputType
    _max?: Insp_cabMaxAggregateInputType
  }

  export type Insp_cabGroupByOutputType = {
    id_ins: number
    nro_sag: number | null
    cod_csp: string | null
    id_tip_ins: number | null
    fec_doc: Date | null
    fec_ins: Date | null
    id_usuario: string | null
    cod_mer: string | null
    cod_mer1: string | null
    cod_mer2: string | null
    cod_mer3: string | null
    obs_insp: string | null
    id_est_ins: number | null
    _count: Insp_cabCountAggregateOutputType | null
    _avg: Insp_cabAvgAggregateOutputType | null
    _sum: Insp_cabSumAggregateOutputType | null
    _min: Insp_cabMinAggregateOutputType | null
    _max: Insp_cabMaxAggregateOutputType | null
  }

  type GetInsp_cabGroupByPayload<T extends insp_cabGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Insp_cabGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Insp_cabGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Insp_cabGroupByOutputType[P]>
            : GetScalarType<T[P], Insp_cabGroupByOutputType[P]>
        }
      >
    >


  export type insp_cabSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_ins?: boolean
    nro_sag?: boolean
    cod_csp?: boolean
    id_tip_ins?: boolean
    fec_doc?: boolean
    fec_ins?: boolean
    id_usuario?: boolean
    cod_mer?: boolean
    cod_mer1?: boolean
    cod_mer2?: boolean
    cod_mer3?: boolean
    obs_insp?: boolean
    id_est_ins?: boolean
  }, ExtArgs["result"]["insp_cab"]>


  export type insp_cabSelectScalar = {
    id_ins?: boolean
    nro_sag?: boolean
    cod_csp?: boolean
    id_tip_ins?: boolean
    fec_doc?: boolean
    fec_ins?: boolean
    id_usuario?: boolean
    cod_mer?: boolean
    cod_mer1?: boolean
    cod_mer2?: boolean
    cod_mer3?: boolean
    obs_insp?: boolean
    id_est_ins?: boolean
  }


  export type $insp_cabPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "insp_cab"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_ins: number
      nro_sag: number | null
      cod_csp: string | null
      id_tip_ins: number | null
      fec_doc: Date | null
      fec_ins: Date | null
      id_usuario: string | null
      cod_mer: string | null
      cod_mer1: string | null
      cod_mer2: string | null
      cod_mer3: string | null
      obs_insp: string | null
      id_est_ins: number | null
    }, ExtArgs["result"]["insp_cab"]>
    composites: {}
  }

  type insp_cabGetPayload<S extends boolean | null | undefined | insp_cabDefaultArgs> = $Result.GetResult<Prisma.$insp_cabPayload, S>

  type insp_cabCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<insp_cabFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Insp_cabCountAggregateInputType | true
    }

  export interface insp_cabDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['insp_cab'], meta: { name: 'insp_cab' } }
    /**
     * Find zero or one Insp_cab that matches the filter.
     * @param {insp_cabFindUniqueArgs} args - Arguments to find a Insp_cab
     * @example
     * // Get one Insp_cab
     * const insp_cab = await prisma.insp_cab.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends insp_cabFindUniqueArgs>(args: SelectSubset<T, insp_cabFindUniqueArgs<ExtArgs>>): Prisma__insp_cabClient<$Result.GetResult<Prisma.$insp_cabPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Insp_cab that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {insp_cabFindUniqueOrThrowArgs} args - Arguments to find a Insp_cab
     * @example
     * // Get one Insp_cab
     * const insp_cab = await prisma.insp_cab.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends insp_cabFindUniqueOrThrowArgs>(args: SelectSubset<T, insp_cabFindUniqueOrThrowArgs<ExtArgs>>): Prisma__insp_cabClient<$Result.GetResult<Prisma.$insp_cabPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Insp_cab that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {insp_cabFindFirstArgs} args - Arguments to find a Insp_cab
     * @example
     * // Get one Insp_cab
     * const insp_cab = await prisma.insp_cab.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends insp_cabFindFirstArgs>(args?: SelectSubset<T, insp_cabFindFirstArgs<ExtArgs>>): Prisma__insp_cabClient<$Result.GetResult<Prisma.$insp_cabPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Insp_cab that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {insp_cabFindFirstOrThrowArgs} args - Arguments to find a Insp_cab
     * @example
     * // Get one Insp_cab
     * const insp_cab = await prisma.insp_cab.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends insp_cabFindFirstOrThrowArgs>(args?: SelectSubset<T, insp_cabFindFirstOrThrowArgs<ExtArgs>>): Prisma__insp_cabClient<$Result.GetResult<Prisma.$insp_cabPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Insp_cabs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {insp_cabFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Insp_cabs
     * const insp_cabs = await prisma.insp_cab.findMany()
     * 
     * // Get first 10 Insp_cabs
     * const insp_cabs = await prisma.insp_cab.findMany({ take: 10 })
     * 
     * // Only select the `id_ins`
     * const insp_cabWithId_insOnly = await prisma.insp_cab.findMany({ select: { id_ins: true } })
     * 
     */
    findMany<T extends insp_cabFindManyArgs>(args?: SelectSubset<T, insp_cabFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$insp_cabPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Insp_cab.
     * @param {insp_cabCreateArgs} args - Arguments to create a Insp_cab.
     * @example
     * // Create one Insp_cab
     * const Insp_cab = await prisma.insp_cab.create({
     *   data: {
     *     // ... data to create a Insp_cab
     *   }
     * })
     * 
     */
    create<T extends insp_cabCreateArgs>(args: SelectSubset<T, insp_cabCreateArgs<ExtArgs>>): Prisma__insp_cabClient<$Result.GetResult<Prisma.$insp_cabPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Insp_cabs.
     * @param {insp_cabCreateManyArgs} args - Arguments to create many Insp_cabs.
     * @example
     * // Create many Insp_cabs
     * const insp_cab = await prisma.insp_cab.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends insp_cabCreateManyArgs>(args?: SelectSubset<T, insp_cabCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Insp_cab.
     * @param {insp_cabDeleteArgs} args - Arguments to delete one Insp_cab.
     * @example
     * // Delete one Insp_cab
     * const Insp_cab = await prisma.insp_cab.delete({
     *   where: {
     *     // ... filter to delete one Insp_cab
     *   }
     * })
     * 
     */
    delete<T extends insp_cabDeleteArgs>(args: SelectSubset<T, insp_cabDeleteArgs<ExtArgs>>): Prisma__insp_cabClient<$Result.GetResult<Prisma.$insp_cabPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Insp_cab.
     * @param {insp_cabUpdateArgs} args - Arguments to update one Insp_cab.
     * @example
     * // Update one Insp_cab
     * const insp_cab = await prisma.insp_cab.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends insp_cabUpdateArgs>(args: SelectSubset<T, insp_cabUpdateArgs<ExtArgs>>): Prisma__insp_cabClient<$Result.GetResult<Prisma.$insp_cabPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Insp_cabs.
     * @param {insp_cabDeleteManyArgs} args - Arguments to filter Insp_cabs to delete.
     * @example
     * // Delete a few Insp_cabs
     * const { count } = await prisma.insp_cab.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends insp_cabDeleteManyArgs>(args?: SelectSubset<T, insp_cabDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Insp_cabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {insp_cabUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Insp_cabs
     * const insp_cab = await prisma.insp_cab.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends insp_cabUpdateManyArgs>(args: SelectSubset<T, insp_cabUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Insp_cab.
     * @param {insp_cabUpsertArgs} args - Arguments to update or create a Insp_cab.
     * @example
     * // Update or create a Insp_cab
     * const insp_cab = await prisma.insp_cab.upsert({
     *   create: {
     *     // ... data to create a Insp_cab
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Insp_cab we want to update
     *   }
     * })
     */
    upsert<T extends insp_cabUpsertArgs>(args: SelectSubset<T, insp_cabUpsertArgs<ExtArgs>>): Prisma__insp_cabClient<$Result.GetResult<Prisma.$insp_cabPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Insp_cabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {insp_cabCountArgs} args - Arguments to filter Insp_cabs to count.
     * @example
     * // Count the number of Insp_cabs
     * const count = await prisma.insp_cab.count({
     *   where: {
     *     // ... the filter for the Insp_cabs we want to count
     *   }
     * })
    **/
    count<T extends insp_cabCountArgs>(
      args?: Subset<T, insp_cabCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Insp_cabCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Insp_cab.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Insp_cabAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Insp_cabAggregateArgs>(args: Subset<T, Insp_cabAggregateArgs>): Prisma.PrismaPromise<GetInsp_cabAggregateType<T>>

    /**
     * Group by Insp_cab.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {insp_cabGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends insp_cabGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: insp_cabGroupByArgs['orderBy'] }
        : { orderBy?: insp_cabGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, insp_cabGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsp_cabGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the insp_cab model
   */
  readonly fields: insp_cabFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for insp_cab.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__insp_cabClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the insp_cab model
   */ 
  interface insp_cabFieldRefs {
    readonly id_ins: FieldRef<"insp_cab", 'Int'>
    readonly nro_sag: FieldRef<"insp_cab", 'Int'>
    readonly cod_csp: FieldRef<"insp_cab", 'String'>
    readonly id_tip_ins: FieldRef<"insp_cab", 'Int'>
    readonly fec_doc: FieldRef<"insp_cab", 'DateTime'>
    readonly fec_ins: FieldRef<"insp_cab", 'DateTime'>
    readonly id_usuario: FieldRef<"insp_cab", 'String'>
    readonly cod_mer: FieldRef<"insp_cab", 'String'>
    readonly cod_mer1: FieldRef<"insp_cab", 'String'>
    readonly cod_mer2: FieldRef<"insp_cab", 'String'>
    readonly cod_mer3: FieldRef<"insp_cab", 'String'>
    readonly obs_insp: FieldRef<"insp_cab", 'String'>
    readonly id_est_ins: FieldRef<"insp_cab", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * insp_cab findUnique
   */
  export type insp_cabFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insp_cab
     */
    select?: insp_cabSelect<ExtArgs> | null
    /**
     * Filter, which insp_cab to fetch.
     */
    where: insp_cabWhereUniqueInput
  }

  /**
   * insp_cab findUniqueOrThrow
   */
  export type insp_cabFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insp_cab
     */
    select?: insp_cabSelect<ExtArgs> | null
    /**
     * Filter, which insp_cab to fetch.
     */
    where: insp_cabWhereUniqueInput
  }

  /**
   * insp_cab findFirst
   */
  export type insp_cabFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insp_cab
     */
    select?: insp_cabSelect<ExtArgs> | null
    /**
     * Filter, which insp_cab to fetch.
     */
    where?: insp_cabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of insp_cabs to fetch.
     */
    orderBy?: insp_cabOrderByWithRelationInput | insp_cabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for insp_cabs.
     */
    cursor?: insp_cabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` insp_cabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` insp_cabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of insp_cabs.
     */
    distinct?: Insp_cabScalarFieldEnum | Insp_cabScalarFieldEnum[]
  }

  /**
   * insp_cab findFirstOrThrow
   */
  export type insp_cabFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insp_cab
     */
    select?: insp_cabSelect<ExtArgs> | null
    /**
     * Filter, which insp_cab to fetch.
     */
    where?: insp_cabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of insp_cabs to fetch.
     */
    orderBy?: insp_cabOrderByWithRelationInput | insp_cabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for insp_cabs.
     */
    cursor?: insp_cabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` insp_cabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` insp_cabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of insp_cabs.
     */
    distinct?: Insp_cabScalarFieldEnum | Insp_cabScalarFieldEnum[]
  }

  /**
   * insp_cab findMany
   */
  export type insp_cabFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insp_cab
     */
    select?: insp_cabSelect<ExtArgs> | null
    /**
     * Filter, which insp_cabs to fetch.
     */
    where?: insp_cabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of insp_cabs to fetch.
     */
    orderBy?: insp_cabOrderByWithRelationInput | insp_cabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing insp_cabs.
     */
    cursor?: insp_cabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` insp_cabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` insp_cabs.
     */
    skip?: number
    distinct?: Insp_cabScalarFieldEnum | Insp_cabScalarFieldEnum[]
  }

  /**
   * insp_cab create
   */
  export type insp_cabCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insp_cab
     */
    select?: insp_cabSelect<ExtArgs> | null
    /**
     * The data needed to create a insp_cab.
     */
    data?: XOR<insp_cabCreateInput, insp_cabUncheckedCreateInput>
  }

  /**
   * insp_cab createMany
   */
  export type insp_cabCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many insp_cabs.
     */
    data: insp_cabCreateManyInput | insp_cabCreateManyInput[]
  }

  /**
   * insp_cab update
   */
  export type insp_cabUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insp_cab
     */
    select?: insp_cabSelect<ExtArgs> | null
    /**
     * The data needed to update a insp_cab.
     */
    data: XOR<insp_cabUpdateInput, insp_cabUncheckedUpdateInput>
    /**
     * Choose, which insp_cab to update.
     */
    where: insp_cabWhereUniqueInput
  }

  /**
   * insp_cab updateMany
   */
  export type insp_cabUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update insp_cabs.
     */
    data: XOR<insp_cabUpdateManyMutationInput, insp_cabUncheckedUpdateManyInput>
    /**
     * Filter which insp_cabs to update
     */
    where?: insp_cabWhereInput
  }

  /**
   * insp_cab upsert
   */
  export type insp_cabUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insp_cab
     */
    select?: insp_cabSelect<ExtArgs> | null
    /**
     * The filter to search for the insp_cab to update in case it exists.
     */
    where: insp_cabWhereUniqueInput
    /**
     * In case the insp_cab found by the `where` argument doesn't exist, create a new insp_cab with this data.
     */
    create: XOR<insp_cabCreateInput, insp_cabUncheckedCreateInput>
    /**
     * In case the insp_cab was found with the provided `where` argument, update it with this data.
     */
    update: XOR<insp_cabUpdateInput, insp_cabUncheckedUpdateInput>
  }

  /**
   * insp_cab delete
   */
  export type insp_cabDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insp_cab
     */
    select?: insp_cabSelect<ExtArgs> | null
    /**
     * Filter which insp_cab to delete.
     */
    where: insp_cabWhereUniqueInput
  }

  /**
   * insp_cab deleteMany
   */
  export type insp_cabDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which insp_cabs to delete
     */
    where?: insp_cabWhereInput
  }

  /**
   * insp_cab without action
   */
  export type insp_cabDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insp_cab
     */
    select?: insp_cabSelect<ExtArgs> | null
  }


  /**
   * Model mae_sta_elena
   */

  export type AggregateMae_sta_elena = {
    _count: Mae_sta_elenaCountAggregateOutputType | null
    _min: Mae_sta_elenaMinAggregateOutputType | null
    _max: Mae_sta_elenaMaxAggregateOutputType | null
  }

  export type Mae_sta_elenaMinAggregateOutputType = {
    cod_emb: string | null
  }

  export type Mae_sta_elenaMaxAggregateOutputType = {
    cod_emb: string | null
  }

  export type Mae_sta_elenaCountAggregateOutputType = {
    cod_emb: number
    _all: number
  }


  export type Mae_sta_elenaMinAggregateInputType = {
    cod_emb?: true
  }

  export type Mae_sta_elenaMaxAggregateInputType = {
    cod_emb?: true
  }

  export type Mae_sta_elenaCountAggregateInputType = {
    cod_emb?: true
    _all?: true
  }

  export type Mae_sta_elenaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mae_sta_elena to aggregate.
     */
    where?: mae_sta_elenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mae_sta_elenas to fetch.
     */
    orderBy?: mae_sta_elenaOrderByWithRelationInput | mae_sta_elenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mae_sta_elenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mae_sta_elenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mae_sta_elenas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mae_sta_elenas
    **/
    _count?: true | Mae_sta_elenaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mae_sta_elenaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mae_sta_elenaMaxAggregateInputType
  }

  export type GetMae_sta_elenaAggregateType<T extends Mae_sta_elenaAggregateArgs> = {
        [P in keyof T & keyof AggregateMae_sta_elena]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMae_sta_elena[P]>
      : GetScalarType<T[P], AggregateMae_sta_elena[P]>
  }




  export type mae_sta_elenaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mae_sta_elenaWhereInput
    orderBy?: mae_sta_elenaOrderByWithAggregationInput | mae_sta_elenaOrderByWithAggregationInput[]
    by: Mae_sta_elenaScalarFieldEnum[] | Mae_sta_elenaScalarFieldEnum
    having?: mae_sta_elenaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mae_sta_elenaCountAggregateInputType | true
    _min?: Mae_sta_elenaMinAggregateInputType
    _max?: Mae_sta_elenaMaxAggregateInputType
  }

  export type Mae_sta_elenaGroupByOutputType = {
    cod_emb: string
    _count: Mae_sta_elenaCountAggregateOutputType | null
    _min: Mae_sta_elenaMinAggregateOutputType | null
    _max: Mae_sta_elenaMaxAggregateOutputType | null
  }

  type GetMae_sta_elenaGroupByPayload<T extends mae_sta_elenaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mae_sta_elenaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mae_sta_elenaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mae_sta_elenaGroupByOutputType[P]>
            : GetScalarType<T[P], Mae_sta_elenaGroupByOutputType[P]>
        }
      >
    >


  export type mae_sta_elenaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cod_emb?: boolean
  }, ExtArgs["result"]["mae_sta_elena"]>


  export type mae_sta_elenaSelectScalar = {
    cod_emb?: boolean
  }


  export type $mae_sta_elenaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mae_sta_elena"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      cod_emb: string
    }, ExtArgs["result"]["mae_sta_elena"]>
    composites: {}
  }

  type mae_sta_elenaGetPayload<S extends boolean | null | undefined | mae_sta_elenaDefaultArgs> = $Result.GetResult<Prisma.$mae_sta_elenaPayload, S>

  type mae_sta_elenaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<mae_sta_elenaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Mae_sta_elenaCountAggregateInputType | true
    }

  export interface mae_sta_elenaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mae_sta_elena'], meta: { name: 'mae_sta_elena' } }
    /**
     * Find zero or one Mae_sta_elena that matches the filter.
     * @param {mae_sta_elenaFindUniqueArgs} args - Arguments to find a Mae_sta_elena
     * @example
     * // Get one Mae_sta_elena
     * const mae_sta_elena = await prisma.mae_sta_elena.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mae_sta_elenaFindUniqueArgs>(args: SelectSubset<T, mae_sta_elenaFindUniqueArgs<ExtArgs>>): Prisma__mae_sta_elenaClient<$Result.GetResult<Prisma.$mae_sta_elenaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mae_sta_elena that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {mae_sta_elenaFindUniqueOrThrowArgs} args - Arguments to find a Mae_sta_elena
     * @example
     * // Get one Mae_sta_elena
     * const mae_sta_elena = await prisma.mae_sta_elena.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mae_sta_elenaFindUniqueOrThrowArgs>(args: SelectSubset<T, mae_sta_elenaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mae_sta_elenaClient<$Result.GetResult<Prisma.$mae_sta_elenaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mae_sta_elena that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mae_sta_elenaFindFirstArgs} args - Arguments to find a Mae_sta_elena
     * @example
     * // Get one Mae_sta_elena
     * const mae_sta_elena = await prisma.mae_sta_elena.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mae_sta_elenaFindFirstArgs>(args?: SelectSubset<T, mae_sta_elenaFindFirstArgs<ExtArgs>>): Prisma__mae_sta_elenaClient<$Result.GetResult<Prisma.$mae_sta_elenaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mae_sta_elena that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mae_sta_elenaFindFirstOrThrowArgs} args - Arguments to find a Mae_sta_elena
     * @example
     * // Get one Mae_sta_elena
     * const mae_sta_elena = await prisma.mae_sta_elena.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mae_sta_elenaFindFirstOrThrowArgs>(args?: SelectSubset<T, mae_sta_elenaFindFirstOrThrowArgs<ExtArgs>>): Prisma__mae_sta_elenaClient<$Result.GetResult<Prisma.$mae_sta_elenaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Mae_sta_elenas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mae_sta_elenaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mae_sta_elenas
     * const mae_sta_elenas = await prisma.mae_sta_elena.findMany()
     * 
     * // Get first 10 Mae_sta_elenas
     * const mae_sta_elenas = await prisma.mae_sta_elena.findMany({ take: 10 })
     * 
     * // Only select the `cod_emb`
     * const mae_sta_elenaWithCod_embOnly = await prisma.mae_sta_elena.findMany({ select: { cod_emb: true } })
     * 
     */
    findMany<T extends mae_sta_elenaFindManyArgs>(args?: SelectSubset<T, mae_sta_elenaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mae_sta_elenaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mae_sta_elena.
     * @param {mae_sta_elenaCreateArgs} args - Arguments to create a Mae_sta_elena.
     * @example
     * // Create one Mae_sta_elena
     * const Mae_sta_elena = await prisma.mae_sta_elena.create({
     *   data: {
     *     // ... data to create a Mae_sta_elena
     *   }
     * })
     * 
     */
    create<T extends mae_sta_elenaCreateArgs>(args: SelectSubset<T, mae_sta_elenaCreateArgs<ExtArgs>>): Prisma__mae_sta_elenaClient<$Result.GetResult<Prisma.$mae_sta_elenaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Mae_sta_elenas.
     * @param {mae_sta_elenaCreateManyArgs} args - Arguments to create many Mae_sta_elenas.
     * @example
     * // Create many Mae_sta_elenas
     * const mae_sta_elena = await prisma.mae_sta_elena.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mae_sta_elenaCreateManyArgs>(args?: SelectSubset<T, mae_sta_elenaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mae_sta_elena.
     * @param {mae_sta_elenaDeleteArgs} args - Arguments to delete one Mae_sta_elena.
     * @example
     * // Delete one Mae_sta_elena
     * const Mae_sta_elena = await prisma.mae_sta_elena.delete({
     *   where: {
     *     // ... filter to delete one Mae_sta_elena
     *   }
     * })
     * 
     */
    delete<T extends mae_sta_elenaDeleteArgs>(args: SelectSubset<T, mae_sta_elenaDeleteArgs<ExtArgs>>): Prisma__mae_sta_elenaClient<$Result.GetResult<Prisma.$mae_sta_elenaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mae_sta_elena.
     * @param {mae_sta_elenaUpdateArgs} args - Arguments to update one Mae_sta_elena.
     * @example
     * // Update one Mae_sta_elena
     * const mae_sta_elena = await prisma.mae_sta_elena.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mae_sta_elenaUpdateArgs>(args: SelectSubset<T, mae_sta_elenaUpdateArgs<ExtArgs>>): Prisma__mae_sta_elenaClient<$Result.GetResult<Prisma.$mae_sta_elenaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Mae_sta_elenas.
     * @param {mae_sta_elenaDeleteManyArgs} args - Arguments to filter Mae_sta_elenas to delete.
     * @example
     * // Delete a few Mae_sta_elenas
     * const { count } = await prisma.mae_sta_elena.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mae_sta_elenaDeleteManyArgs>(args?: SelectSubset<T, mae_sta_elenaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mae_sta_elenas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mae_sta_elenaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mae_sta_elenas
     * const mae_sta_elena = await prisma.mae_sta_elena.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mae_sta_elenaUpdateManyArgs>(args: SelectSubset<T, mae_sta_elenaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mae_sta_elena.
     * @param {mae_sta_elenaUpsertArgs} args - Arguments to update or create a Mae_sta_elena.
     * @example
     * // Update or create a Mae_sta_elena
     * const mae_sta_elena = await prisma.mae_sta_elena.upsert({
     *   create: {
     *     // ... data to create a Mae_sta_elena
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mae_sta_elena we want to update
     *   }
     * })
     */
    upsert<T extends mae_sta_elenaUpsertArgs>(args: SelectSubset<T, mae_sta_elenaUpsertArgs<ExtArgs>>): Prisma__mae_sta_elenaClient<$Result.GetResult<Prisma.$mae_sta_elenaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Mae_sta_elenas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mae_sta_elenaCountArgs} args - Arguments to filter Mae_sta_elenas to count.
     * @example
     * // Count the number of Mae_sta_elenas
     * const count = await prisma.mae_sta_elena.count({
     *   where: {
     *     // ... the filter for the Mae_sta_elenas we want to count
     *   }
     * })
    **/
    count<T extends mae_sta_elenaCountArgs>(
      args?: Subset<T, mae_sta_elenaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mae_sta_elenaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mae_sta_elena.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mae_sta_elenaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mae_sta_elenaAggregateArgs>(args: Subset<T, Mae_sta_elenaAggregateArgs>): Prisma.PrismaPromise<GetMae_sta_elenaAggregateType<T>>

    /**
     * Group by Mae_sta_elena.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mae_sta_elenaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mae_sta_elenaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mae_sta_elenaGroupByArgs['orderBy'] }
        : { orderBy?: mae_sta_elenaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mae_sta_elenaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMae_sta_elenaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mae_sta_elena model
   */
  readonly fields: mae_sta_elenaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mae_sta_elena.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mae_sta_elenaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mae_sta_elena model
   */ 
  interface mae_sta_elenaFieldRefs {
    readonly cod_emb: FieldRef<"mae_sta_elena", 'String'>
  }
    

  // Custom InputTypes
  /**
   * mae_sta_elena findUnique
   */
  export type mae_sta_elenaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mae_sta_elena
     */
    select?: mae_sta_elenaSelect<ExtArgs> | null
    /**
     * Filter, which mae_sta_elena to fetch.
     */
    where: mae_sta_elenaWhereUniqueInput
  }

  /**
   * mae_sta_elena findUniqueOrThrow
   */
  export type mae_sta_elenaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mae_sta_elena
     */
    select?: mae_sta_elenaSelect<ExtArgs> | null
    /**
     * Filter, which mae_sta_elena to fetch.
     */
    where: mae_sta_elenaWhereUniqueInput
  }

  /**
   * mae_sta_elena findFirst
   */
  export type mae_sta_elenaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mae_sta_elena
     */
    select?: mae_sta_elenaSelect<ExtArgs> | null
    /**
     * Filter, which mae_sta_elena to fetch.
     */
    where?: mae_sta_elenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mae_sta_elenas to fetch.
     */
    orderBy?: mae_sta_elenaOrderByWithRelationInput | mae_sta_elenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mae_sta_elenas.
     */
    cursor?: mae_sta_elenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mae_sta_elenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mae_sta_elenas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mae_sta_elenas.
     */
    distinct?: Mae_sta_elenaScalarFieldEnum | Mae_sta_elenaScalarFieldEnum[]
  }

  /**
   * mae_sta_elena findFirstOrThrow
   */
  export type mae_sta_elenaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mae_sta_elena
     */
    select?: mae_sta_elenaSelect<ExtArgs> | null
    /**
     * Filter, which mae_sta_elena to fetch.
     */
    where?: mae_sta_elenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mae_sta_elenas to fetch.
     */
    orderBy?: mae_sta_elenaOrderByWithRelationInput | mae_sta_elenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mae_sta_elenas.
     */
    cursor?: mae_sta_elenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mae_sta_elenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mae_sta_elenas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mae_sta_elenas.
     */
    distinct?: Mae_sta_elenaScalarFieldEnum | Mae_sta_elenaScalarFieldEnum[]
  }

  /**
   * mae_sta_elena findMany
   */
  export type mae_sta_elenaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mae_sta_elena
     */
    select?: mae_sta_elenaSelect<ExtArgs> | null
    /**
     * Filter, which mae_sta_elenas to fetch.
     */
    where?: mae_sta_elenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mae_sta_elenas to fetch.
     */
    orderBy?: mae_sta_elenaOrderByWithRelationInput | mae_sta_elenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mae_sta_elenas.
     */
    cursor?: mae_sta_elenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mae_sta_elenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mae_sta_elenas.
     */
    skip?: number
    distinct?: Mae_sta_elenaScalarFieldEnum | Mae_sta_elenaScalarFieldEnum[]
  }

  /**
   * mae_sta_elena create
   */
  export type mae_sta_elenaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mae_sta_elena
     */
    select?: mae_sta_elenaSelect<ExtArgs> | null
    /**
     * The data needed to create a mae_sta_elena.
     */
    data: XOR<mae_sta_elenaCreateInput, mae_sta_elenaUncheckedCreateInput>
  }

  /**
   * mae_sta_elena createMany
   */
  export type mae_sta_elenaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mae_sta_elenas.
     */
    data: mae_sta_elenaCreateManyInput | mae_sta_elenaCreateManyInput[]
  }

  /**
   * mae_sta_elena update
   */
  export type mae_sta_elenaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mae_sta_elena
     */
    select?: mae_sta_elenaSelect<ExtArgs> | null
    /**
     * The data needed to update a mae_sta_elena.
     */
    data: XOR<mae_sta_elenaUpdateInput, mae_sta_elenaUncheckedUpdateInput>
    /**
     * Choose, which mae_sta_elena to update.
     */
    where: mae_sta_elenaWhereUniqueInput
  }

  /**
   * mae_sta_elena updateMany
   */
  export type mae_sta_elenaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mae_sta_elenas.
     */
    data: XOR<mae_sta_elenaUpdateManyMutationInput, mae_sta_elenaUncheckedUpdateManyInput>
    /**
     * Filter which mae_sta_elenas to update
     */
    where?: mae_sta_elenaWhereInput
  }

  /**
   * mae_sta_elena upsert
   */
  export type mae_sta_elenaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mae_sta_elena
     */
    select?: mae_sta_elenaSelect<ExtArgs> | null
    /**
     * The filter to search for the mae_sta_elena to update in case it exists.
     */
    where: mae_sta_elenaWhereUniqueInput
    /**
     * In case the mae_sta_elena found by the `where` argument doesn't exist, create a new mae_sta_elena with this data.
     */
    create: XOR<mae_sta_elenaCreateInput, mae_sta_elenaUncheckedCreateInput>
    /**
     * In case the mae_sta_elena was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mae_sta_elenaUpdateInput, mae_sta_elenaUncheckedUpdateInput>
  }

  /**
   * mae_sta_elena delete
   */
  export type mae_sta_elenaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mae_sta_elena
     */
    select?: mae_sta_elenaSelect<ExtArgs> | null
    /**
     * Filter which mae_sta_elena to delete.
     */
    where: mae_sta_elenaWhereUniqueInput
  }

  /**
   * mae_sta_elena deleteMany
   */
  export type mae_sta_elenaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mae_sta_elenas to delete
     */
    where?: mae_sta_elenaWhereInput
  }

  /**
   * mae_sta_elena without action
   */
  export type mae_sta_elenaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mae_sta_elena
     */
    select?: mae_sta_elenaSelect<ExtArgs> | null
  }


  /**
   * Model maestro_plu
   */

  export type AggregateMaestro_plu = {
    _count: Maestro_pluCountAggregateOutputType | null
    _min: Maestro_pluMinAggregateOutputType | null
    _max: Maestro_pluMaxAggregateOutputType | null
  }

  export type Maestro_pluMinAggregateOutputType = {
    cod_envop: string | null
    cod_cal: string | null
    cod_plu: string | null
  }

  export type Maestro_pluMaxAggregateOutputType = {
    cod_envop: string | null
    cod_cal: string | null
    cod_plu: string | null
  }

  export type Maestro_pluCountAggregateOutputType = {
    cod_envop: number
    cod_cal: number
    cod_plu: number
    _all: number
  }


  export type Maestro_pluMinAggregateInputType = {
    cod_envop?: true
    cod_cal?: true
    cod_plu?: true
  }

  export type Maestro_pluMaxAggregateInputType = {
    cod_envop?: true
    cod_cal?: true
    cod_plu?: true
  }

  export type Maestro_pluCountAggregateInputType = {
    cod_envop?: true
    cod_cal?: true
    cod_plu?: true
    _all?: true
  }

  export type Maestro_pluAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which maestro_plu to aggregate.
     */
    where?: maestro_pluWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maestro_plus to fetch.
     */
    orderBy?: maestro_pluOrderByWithRelationInput | maestro_pluOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: maestro_pluWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maestro_plus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maestro_plus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned maestro_plus
    **/
    _count?: true | Maestro_pluCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Maestro_pluMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Maestro_pluMaxAggregateInputType
  }

  export type GetMaestro_pluAggregateType<T extends Maestro_pluAggregateArgs> = {
        [P in keyof T & keyof AggregateMaestro_plu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaestro_plu[P]>
      : GetScalarType<T[P], AggregateMaestro_plu[P]>
  }




  export type maestro_pluGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: maestro_pluWhereInput
    orderBy?: maestro_pluOrderByWithAggregationInput | maestro_pluOrderByWithAggregationInput[]
    by: Maestro_pluScalarFieldEnum[] | Maestro_pluScalarFieldEnum
    having?: maestro_pluScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Maestro_pluCountAggregateInputType | true
    _min?: Maestro_pluMinAggregateInputType
    _max?: Maestro_pluMaxAggregateInputType
  }

  export type Maestro_pluGroupByOutputType = {
    cod_envop: string
    cod_cal: string
    cod_plu: string
    _count: Maestro_pluCountAggregateOutputType | null
    _min: Maestro_pluMinAggregateOutputType | null
    _max: Maestro_pluMaxAggregateOutputType | null
  }

  type GetMaestro_pluGroupByPayload<T extends maestro_pluGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Maestro_pluGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Maestro_pluGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Maestro_pluGroupByOutputType[P]>
            : GetScalarType<T[P], Maestro_pluGroupByOutputType[P]>
        }
      >
    >


  export type maestro_pluSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cod_envop?: boolean
    cod_cal?: boolean
    cod_plu?: boolean
  }, ExtArgs["result"]["maestro_plu"]>


  export type maestro_pluSelectScalar = {
    cod_envop?: boolean
    cod_cal?: boolean
    cod_plu?: boolean
  }


  export type $maestro_pluPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "maestro_plu"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      cod_envop: string
      cod_cal: string
      cod_plu: string
    }, ExtArgs["result"]["maestro_plu"]>
    composites: {}
  }

  type maestro_pluGetPayload<S extends boolean | null | undefined | maestro_pluDefaultArgs> = $Result.GetResult<Prisma.$maestro_pluPayload, S>

  type maestro_pluCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<maestro_pluFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Maestro_pluCountAggregateInputType | true
    }

  export interface maestro_pluDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['maestro_plu'], meta: { name: 'maestro_plu' } }
    /**
     * Find zero or one Maestro_plu that matches the filter.
     * @param {maestro_pluFindUniqueArgs} args - Arguments to find a Maestro_plu
     * @example
     * // Get one Maestro_plu
     * const maestro_plu = await prisma.maestro_plu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends maestro_pluFindUniqueArgs>(args: SelectSubset<T, maestro_pluFindUniqueArgs<ExtArgs>>): Prisma__maestro_pluClient<$Result.GetResult<Prisma.$maestro_pluPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Maestro_plu that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {maestro_pluFindUniqueOrThrowArgs} args - Arguments to find a Maestro_plu
     * @example
     * // Get one Maestro_plu
     * const maestro_plu = await prisma.maestro_plu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends maestro_pluFindUniqueOrThrowArgs>(args: SelectSubset<T, maestro_pluFindUniqueOrThrowArgs<ExtArgs>>): Prisma__maestro_pluClient<$Result.GetResult<Prisma.$maestro_pluPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Maestro_plu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maestro_pluFindFirstArgs} args - Arguments to find a Maestro_plu
     * @example
     * // Get one Maestro_plu
     * const maestro_plu = await prisma.maestro_plu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends maestro_pluFindFirstArgs>(args?: SelectSubset<T, maestro_pluFindFirstArgs<ExtArgs>>): Prisma__maestro_pluClient<$Result.GetResult<Prisma.$maestro_pluPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Maestro_plu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maestro_pluFindFirstOrThrowArgs} args - Arguments to find a Maestro_plu
     * @example
     * // Get one Maestro_plu
     * const maestro_plu = await prisma.maestro_plu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends maestro_pluFindFirstOrThrowArgs>(args?: SelectSubset<T, maestro_pluFindFirstOrThrowArgs<ExtArgs>>): Prisma__maestro_pluClient<$Result.GetResult<Prisma.$maestro_pluPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Maestro_plus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maestro_pluFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maestro_plus
     * const maestro_plus = await prisma.maestro_plu.findMany()
     * 
     * // Get first 10 Maestro_plus
     * const maestro_plus = await prisma.maestro_plu.findMany({ take: 10 })
     * 
     * // Only select the `cod_envop`
     * const maestro_pluWithCod_envopOnly = await prisma.maestro_plu.findMany({ select: { cod_envop: true } })
     * 
     */
    findMany<T extends maestro_pluFindManyArgs>(args?: SelectSubset<T, maestro_pluFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$maestro_pluPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Maestro_plu.
     * @param {maestro_pluCreateArgs} args - Arguments to create a Maestro_plu.
     * @example
     * // Create one Maestro_plu
     * const Maestro_plu = await prisma.maestro_plu.create({
     *   data: {
     *     // ... data to create a Maestro_plu
     *   }
     * })
     * 
     */
    create<T extends maestro_pluCreateArgs>(args: SelectSubset<T, maestro_pluCreateArgs<ExtArgs>>): Prisma__maestro_pluClient<$Result.GetResult<Prisma.$maestro_pluPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Maestro_plus.
     * @param {maestro_pluCreateManyArgs} args - Arguments to create many Maestro_plus.
     * @example
     * // Create many Maestro_plus
     * const maestro_plu = await prisma.maestro_plu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends maestro_pluCreateManyArgs>(args?: SelectSubset<T, maestro_pluCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Maestro_plu.
     * @param {maestro_pluDeleteArgs} args - Arguments to delete one Maestro_plu.
     * @example
     * // Delete one Maestro_plu
     * const Maestro_plu = await prisma.maestro_plu.delete({
     *   where: {
     *     // ... filter to delete one Maestro_plu
     *   }
     * })
     * 
     */
    delete<T extends maestro_pluDeleteArgs>(args: SelectSubset<T, maestro_pluDeleteArgs<ExtArgs>>): Prisma__maestro_pluClient<$Result.GetResult<Prisma.$maestro_pluPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Maestro_plu.
     * @param {maestro_pluUpdateArgs} args - Arguments to update one Maestro_plu.
     * @example
     * // Update one Maestro_plu
     * const maestro_plu = await prisma.maestro_plu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends maestro_pluUpdateArgs>(args: SelectSubset<T, maestro_pluUpdateArgs<ExtArgs>>): Prisma__maestro_pluClient<$Result.GetResult<Prisma.$maestro_pluPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Maestro_plus.
     * @param {maestro_pluDeleteManyArgs} args - Arguments to filter Maestro_plus to delete.
     * @example
     * // Delete a few Maestro_plus
     * const { count } = await prisma.maestro_plu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends maestro_pluDeleteManyArgs>(args?: SelectSubset<T, maestro_pluDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maestro_plus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maestro_pluUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maestro_plus
     * const maestro_plu = await prisma.maestro_plu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends maestro_pluUpdateManyArgs>(args: SelectSubset<T, maestro_pluUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Maestro_plu.
     * @param {maestro_pluUpsertArgs} args - Arguments to update or create a Maestro_plu.
     * @example
     * // Update or create a Maestro_plu
     * const maestro_plu = await prisma.maestro_plu.upsert({
     *   create: {
     *     // ... data to create a Maestro_plu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Maestro_plu we want to update
     *   }
     * })
     */
    upsert<T extends maestro_pluUpsertArgs>(args: SelectSubset<T, maestro_pluUpsertArgs<ExtArgs>>): Prisma__maestro_pluClient<$Result.GetResult<Prisma.$maestro_pluPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Maestro_plus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maestro_pluCountArgs} args - Arguments to filter Maestro_plus to count.
     * @example
     * // Count the number of Maestro_plus
     * const count = await prisma.maestro_plu.count({
     *   where: {
     *     // ... the filter for the Maestro_plus we want to count
     *   }
     * })
    **/
    count<T extends maestro_pluCountArgs>(
      args?: Subset<T, maestro_pluCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Maestro_pluCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Maestro_plu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Maestro_pluAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Maestro_pluAggregateArgs>(args: Subset<T, Maestro_pluAggregateArgs>): Prisma.PrismaPromise<GetMaestro_pluAggregateType<T>>

    /**
     * Group by Maestro_plu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maestro_pluGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends maestro_pluGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: maestro_pluGroupByArgs['orderBy'] }
        : { orderBy?: maestro_pluGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, maestro_pluGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaestro_pluGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the maestro_plu model
   */
  readonly fields: maestro_pluFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for maestro_plu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__maestro_pluClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the maestro_plu model
   */ 
  interface maestro_pluFieldRefs {
    readonly cod_envop: FieldRef<"maestro_plu", 'String'>
    readonly cod_cal: FieldRef<"maestro_plu", 'String'>
    readonly cod_plu: FieldRef<"maestro_plu", 'String'>
  }
    

  // Custom InputTypes
  /**
   * maestro_plu findUnique
   */
  export type maestro_pluFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro_plu
     */
    select?: maestro_pluSelect<ExtArgs> | null
    /**
     * Filter, which maestro_plu to fetch.
     */
    where: maestro_pluWhereUniqueInput
  }

  /**
   * maestro_plu findUniqueOrThrow
   */
  export type maestro_pluFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro_plu
     */
    select?: maestro_pluSelect<ExtArgs> | null
    /**
     * Filter, which maestro_plu to fetch.
     */
    where: maestro_pluWhereUniqueInput
  }

  /**
   * maestro_plu findFirst
   */
  export type maestro_pluFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro_plu
     */
    select?: maestro_pluSelect<ExtArgs> | null
    /**
     * Filter, which maestro_plu to fetch.
     */
    where?: maestro_pluWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maestro_plus to fetch.
     */
    orderBy?: maestro_pluOrderByWithRelationInput | maestro_pluOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for maestro_plus.
     */
    cursor?: maestro_pluWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maestro_plus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maestro_plus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of maestro_plus.
     */
    distinct?: Maestro_pluScalarFieldEnum | Maestro_pluScalarFieldEnum[]
  }

  /**
   * maestro_plu findFirstOrThrow
   */
  export type maestro_pluFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro_plu
     */
    select?: maestro_pluSelect<ExtArgs> | null
    /**
     * Filter, which maestro_plu to fetch.
     */
    where?: maestro_pluWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maestro_plus to fetch.
     */
    orderBy?: maestro_pluOrderByWithRelationInput | maestro_pluOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for maestro_plus.
     */
    cursor?: maestro_pluWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maestro_plus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maestro_plus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of maestro_plus.
     */
    distinct?: Maestro_pluScalarFieldEnum | Maestro_pluScalarFieldEnum[]
  }

  /**
   * maestro_plu findMany
   */
  export type maestro_pluFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro_plu
     */
    select?: maestro_pluSelect<ExtArgs> | null
    /**
     * Filter, which maestro_plus to fetch.
     */
    where?: maestro_pluWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maestro_plus to fetch.
     */
    orderBy?: maestro_pluOrderByWithRelationInput | maestro_pluOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing maestro_plus.
     */
    cursor?: maestro_pluWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maestro_plus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maestro_plus.
     */
    skip?: number
    distinct?: Maestro_pluScalarFieldEnum | Maestro_pluScalarFieldEnum[]
  }

  /**
   * maestro_plu create
   */
  export type maestro_pluCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro_plu
     */
    select?: maestro_pluSelect<ExtArgs> | null
    /**
     * The data needed to create a maestro_plu.
     */
    data: XOR<maestro_pluCreateInput, maestro_pluUncheckedCreateInput>
  }

  /**
   * maestro_plu createMany
   */
  export type maestro_pluCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many maestro_plus.
     */
    data: maestro_pluCreateManyInput | maestro_pluCreateManyInput[]
  }

  /**
   * maestro_plu update
   */
  export type maestro_pluUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro_plu
     */
    select?: maestro_pluSelect<ExtArgs> | null
    /**
     * The data needed to update a maestro_plu.
     */
    data: XOR<maestro_pluUpdateInput, maestro_pluUncheckedUpdateInput>
    /**
     * Choose, which maestro_plu to update.
     */
    where: maestro_pluWhereUniqueInput
  }

  /**
   * maestro_plu updateMany
   */
  export type maestro_pluUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update maestro_plus.
     */
    data: XOR<maestro_pluUpdateManyMutationInput, maestro_pluUncheckedUpdateManyInput>
    /**
     * Filter which maestro_plus to update
     */
    where?: maestro_pluWhereInput
  }

  /**
   * maestro_plu upsert
   */
  export type maestro_pluUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro_plu
     */
    select?: maestro_pluSelect<ExtArgs> | null
    /**
     * The filter to search for the maestro_plu to update in case it exists.
     */
    where: maestro_pluWhereUniqueInput
    /**
     * In case the maestro_plu found by the `where` argument doesn't exist, create a new maestro_plu with this data.
     */
    create: XOR<maestro_pluCreateInput, maestro_pluUncheckedCreateInput>
    /**
     * In case the maestro_plu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<maestro_pluUpdateInput, maestro_pluUncheckedUpdateInput>
  }

  /**
   * maestro_plu delete
   */
  export type maestro_pluDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro_plu
     */
    select?: maestro_pluSelect<ExtArgs> | null
    /**
     * Filter which maestro_plu to delete.
     */
    where: maestro_pluWhereUniqueInput
  }

  /**
   * maestro_plu deleteMany
   */
  export type maestro_pluDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which maestro_plus to delete
     */
    where?: maestro_pluWhereInput
  }

  /**
   * maestro_plu without action
   */
  export type maestro_pluDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro_plu
     */
    select?: maestro_pluSelect<ExtArgs> | null
  }


  /**
   * Model pk_desver_cab
   */

  export type AggregatePk_desver_cab = {
    _count: Pk_desver_cabCountAggregateOutputType | null
    _avg: Pk_desver_cabAvgAggregateOutputType | null
    _sum: Pk_desver_cabSumAggregateOutputType | null
    _min: Pk_desver_cabMinAggregateOutputType | null
    _max: Pk_desver_cabMaxAggregateOutputType | null
  }

  export type Pk_desver_cabAvgAggregateOutputType = {
    id: number | null
    pro_nro: number | null
    pes_ini: number | null
    pes_fin: number | null
  }

  export type Pk_desver_cabSumAggregateOutputType = {
    id: number | null
    pro_nro: number | null
    pes_ini: number | null
    pes_fin: number | null
  }

  export type Pk_desver_cabMinAggregateOutputType = {
    id: number | null
    pro_nro: number | null
    fec_ini: Date | null
    fec_fin: Date | null
    usu_res: string | null
    pes_ini: number | null
    pes_fin: number | null
    cod_esp: string | null
    fec_ven: Date | null
  }

  export type Pk_desver_cabMaxAggregateOutputType = {
    id: number | null
    pro_nro: number | null
    fec_ini: Date | null
    fec_fin: Date | null
    usu_res: string | null
    pes_ini: number | null
    pes_fin: number | null
    cod_esp: string | null
    fec_ven: Date | null
  }

  export type Pk_desver_cabCountAggregateOutputType = {
    id: number
    pro_nro: number
    fec_ini: number
    fec_fin: number
    usu_res: number
    pes_ini: number
    pes_fin: number
    cod_esp: number
    fec_ven: number
    _all: number
  }


  export type Pk_desver_cabAvgAggregateInputType = {
    id?: true
    pro_nro?: true
    pes_ini?: true
    pes_fin?: true
  }

  export type Pk_desver_cabSumAggregateInputType = {
    id?: true
    pro_nro?: true
    pes_ini?: true
    pes_fin?: true
  }

  export type Pk_desver_cabMinAggregateInputType = {
    id?: true
    pro_nro?: true
    fec_ini?: true
    fec_fin?: true
    usu_res?: true
    pes_ini?: true
    pes_fin?: true
    cod_esp?: true
    fec_ven?: true
  }

  export type Pk_desver_cabMaxAggregateInputType = {
    id?: true
    pro_nro?: true
    fec_ini?: true
    fec_fin?: true
    usu_res?: true
    pes_ini?: true
    pes_fin?: true
    cod_esp?: true
    fec_ven?: true
  }

  export type Pk_desver_cabCountAggregateInputType = {
    id?: true
    pro_nro?: true
    fec_ini?: true
    fec_fin?: true
    usu_res?: true
    pes_ini?: true
    pes_fin?: true
    cod_esp?: true
    fec_ven?: true
    _all?: true
  }

  export type Pk_desver_cabAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pk_desver_cab to aggregate.
     */
    where?: pk_desver_cabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pk_desver_cabs to fetch.
     */
    orderBy?: pk_desver_cabOrderByWithRelationInput | pk_desver_cabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pk_desver_cabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pk_desver_cabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pk_desver_cabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pk_desver_cabs
    **/
    _count?: true | Pk_desver_cabCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pk_desver_cabAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pk_desver_cabSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pk_desver_cabMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pk_desver_cabMaxAggregateInputType
  }

  export type GetPk_desver_cabAggregateType<T extends Pk_desver_cabAggregateArgs> = {
        [P in keyof T & keyof AggregatePk_desver_cab]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePk_desver_cab[P]>
      : GetScalarType<T[P], AggregatePk_desver_cab[P]>
  }




  export type pk_desver_cabGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pk_desver_cabWhereInput
    orderBy?: pk_desver_cabOrderByWithAggregationInput | pk_desver_cabOrderByWithAggregationInput[]
    by: Pk_desver_cabScalarFieldEnum[] | Pk_desver_cabScalarFieldEnum
    having?: pk_desver_cabScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pk_desver_cabCountAggregateInputType | true
    _avg?: Pk_desver_cabAvgAggregateInputType
    _sum?: Pk_desver_cabSumAggregateInputType
    _min?: Pk_desver_cabMinAggregateInputType
    _max?: Pk_desver_cabMaxAggregateInputType
  }

  export type Pk_desver_cabGroupByOutputType = {
    id: number
    pro_nro: number | null
    fec_ini: Date | null
    fec_fin: Date | null
    usu_res: string | null
    pes_ini: number | null
    pes_fin: number | null
    cod_esp: string | null
    fec_ven: Date | null
    _count: Pk_desver_cabCountAggregateOutputType | null
    _avg: Pk_desver_cabAvgAggregateOutputType | null
    _sum: Pk_desver_cabSumAggregateOutputType | null
    _min: Pk_desver_cabMinAggregateOutputType | null
    _max: Pk_desver_cabMaxAggregateOutputType | null
  }

  type GetPk_desver_cabGroupByPayload<T extends pk_desver_cabGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pk_desver_cabGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pk_desver_cabGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pk_desver_cabGroupByOutputType[P]>
            : GetScalarType<T[P], Pk_desver_cabGroupByOutputType[P]>
        }
      >
    >


  export type pk_desver_cabSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pro_nro?: boolean
    fec_ini?: boolean
    fec_fin?: boolean
    usu_res?: boolean
    pes_ini?: boolean
    pes_fin?: boolean
    cod_esp?: boolean
    fec_ven?: boolean
  }, ExtArgs["result"]["pk_desver_cab"]>


  export type pk_desver_cabSelectScalar = {
    id?: boolean
    pro_nro?: boolean
    fec_ini?: boolean
    fec_fin?: boolean
    usu_res?: boolean
    pes_ini?: boolean
    pes_fin?: boolean
    cod_esp?: boolean
    fec_ven?: boolean
  }


  export type $pk_desver_cabPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pk_desver_cab"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pro_nro: number | null
      fec_ini: Date | null
      fec_fin: Date | null
      usu_res: string | null
      pes_ini: number | null
      pes_fin: number | null
      cod_esp: string | null
      fec_ven: Date | null
    }, ExtArgs["result"]["pk_desver_cab"]>
    composites: {}
  }

  type pk_desver_cabGetPayload<S extends boolean | null | undefined | pk_desver_cabDefaultArgs> = $Result.GetResult<Prisma.$pk_desver_cabPayload, S>

  type pk_desver_cabCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pk_desver_cabFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Pk_desver_cabCountAggregateInputType | true
    }

  export interface pk_desver_cabDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pk_desver_cab'], meta: { name: 'pk_desver_cab' } }
    /**
     * Find zero or one Pk_desver_cab that matches the filter.
     * @param {pk_desver_cabFindUniqueArgs} args - Arguments to find a Pk_desver_cab
     * @example
     * // Get one Pk_desver_cab
     * const pk_desver_cab = await prisma.pk_desver_cab.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pk_desver_cabFindUniqueArgs>(args: SelectSubset<T, pk_desver_cabFindUniqueArgs<ExtArgs>>): Prisma__pk_desver_cabClient<$Result.GetResult<Prisma.$pk_desver_cabPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pk_desver_cab that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pk_desver_cabFindUniqueOrThrowArgs} args - Arguments to find a Pk_desver_cab
     * @example
     * // Get one Pk_desver_cab
     * const pk_desver_cab = await prisma.pk_desver_cab.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pk_desver_cabFindUniqueOrThrowArgs>(args: SelectSubset<T, pk_desver_cabFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pk_desver_cabClient<$Result.GetResult<Prisma.$pk_desver_cabPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pk_desver_cab that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pk_desver_cabFindFirstArgs} args - Arguments to find a Pk_desver_cab
     * @example
     * // Get one Pk_desver_cab
     * const pk_desver_cab = await prisma.pk_desver_cab.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pk_desver_cabFindFirstArgs>(args?: SelectSubset<T, pk_desver_cabFindFirstArgs<ExtArgs>>): Prisma__pk_desver_cabClient<$Result.GetResult<Prisma.$pk_desver_cabPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pk_desver_cab that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pk_desver_cabFindFirstOrThrowArgs} args - Arguments to find a Pk_desver_cab
     * @example
     * // Get one Pk_desver_cab
     * const pk_desver_cab = await prisma.pk_desver_cab.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pk_desver_cabFindFirstOrThrowArgs>(args?: SelectSubset<T, pk_desver_cabFindFirstOrThrowArgs<ExtArgs>>): Prisma__pk_desver_cabClient<$Result.GetResult<Prisma.$pk_desver_cabPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pk_desver_cabs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pk_desver_cabFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pk_desver_cabs
     * const pk_desver_cabs = await prisma.pk_desver_cab.findMany()
     * 
     * // Get first 10 Pk_desver_cabs
     * const pk_desver_cabs = await prisma.pk_desver_cab.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pk_desver_cabWithIdOnly = await prisma.pk_desver_cab.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pk_desver_cabFindManyArgs>(args?: SelectSubset<T, pk_desver_cabFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pk_desver_cabPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pk_desver_cab.
     * @param {pk_desver_cabCreateArgs} args - Arguments to create a Pk_desver_cab.
     * @example
     * // Create one Pk_desver_cab
     * const Pk_desver_cab = await prisma.pk_desver_cab.create({
     *   data: {
     *     // ... data to create a Pk_desver_cab
     *   }
     * })
     * 
     */
    create<T extends pk_desver_cabCreateArgs>(args: SelectSubset<T, pk_desver_cabCreateArgs<ExtArgs>>): Prisma__pk_desver_cabClient<$Result.GetResult<Prisma.$pk_desver_cabPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pk_desver_cabs.
     * @param {pk_desver_cabCreateManyArgs} args - Arguments to create many Pk_desver_cabs.
     * @example
     * // Create many Pk_desver_cabs
     * const pk_desver_cab = await prisma.pk_desver_cab.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pk_desver_cabCreateManyArgs>(args?: SelectSubset<T, pk_desver_cabCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pk_desver_cab.
     * @param {pk_desver_cabDeleteArgs} args - Arguments to delete one Pk_desver_cab.
     * @example
     * // Delete one Pk_desver_cab
     * const Pk_desver_cab = await prisma.pk_desver_cab.delete({
     *   where: {
     *     // ... filter to delete one Pk_desver_cab
     *   }
     * })
     * 
     */
    delete<T extends pk_desver_cabDeleteArgs>(args: SelectSubset<T, pk_desver_cabDeleteArgs<ExtArgs>>): Prisma__pk_desver_cabClient<$Result.GetResult<Prisma.$pk_desver_cabPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pk_desver_cab.
     * @param {pk_desver_cabUpdateArgs} args - Arguments to update one Pk_desver_cab.
     * @example
     * // Update one Pk_desver_cab
     * const pk_desver_cab = await prisma.pk_desver_cab.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pk_desver_cabUpdateArgs>(args: SelectSubset<T, pk_desver_cabUpdateArgs<ExtArgs>>): Prisma__pk_desver_cabClient<$Result.GetResult<Prisma.$pk_desver_cabPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pk_desver_cabs.
     * @param {pk_desver_cabDeleteManyArgs} args - Arguments to filter Pk_desver_cabs to delete.
     * @example
     * // Delete a few Pk_desver_cabs
     * const { count } = await prisma.pk_desver_cab.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pk_desver_cabDeleteManyArgs>(args?: SelectSubset<T, pk_desver_cabDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pk_desver_cabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pk_desver_cabUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pk_desver_cabs
     * const pk_desver_cab = await prisma.pk_desver_cab.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pk_desver_cabUpdateManyArgs>(args: SelectSubset<T, pk_desver_cabUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pk_desver_cab.
     * @param {pk_desver_cabUpsertArgs} args - Arguments to update or create a Pk_desver_cab.
     * @example
     * // Update or create a Pk_desver_cab
     * const pk_desver_cab = await prisma.pk_desver_cab.upsert({
     *   create: {
     *     // ... data to create a Pk_desver_cab
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pk_desver_cab we want to update
     *   }
     * })
     */
    upsert<T extends pk_desver_cabUpsertArgs>(args: SelectSubset<T, pk_desver_cabUpsertArgs<ExtArgs>>): Prisma__pk_desver_cabClient<$Result.GetResult<Prisma.$pk_desver_cabPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pk_desver_cabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pk_desver_cabCountArgs} args - Arguments to filter Pk_desver_cabs to count.
     * @example
     * // Count the number of Pk_desver_cabs
     * const count = await prisma.pk_desver_cab.count({
     *   where: {
     *     // ... the filter for the Pk_desver_cabs we want to count
     *   }
     * })
    **/
    count<T extends pk_desver_cabCountArgs>(
      args?: Subset<T, pk_desver_cabCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pk_desver_cabCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pk_desver_cab.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pk_desver_cabAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pk_desver_cabAggregateArgs>(args: Subset<T, Pk_desver_cabAggregateArgs>): Prisma.PrismaPromise<GetPk_desver_cabAggregateType<T>>

    /**
     * Group by Pk_desver_cab.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pk_desver_cabGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pk_desver_cabGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pk_desver_cabGroupByArgs['orderBy'] }
        : { orderBy?: pk_desver_cabGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pk_desver_cabGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPk_desver_cabGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pk_desver_cab model
   */
  readonly fields: pk_desver_cabFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pk_desver_cab.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pk_desver_cabClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pk_desver_cab model
   */ 
  interface pk_desver_cabFieldRefs {
    readonly id: FieldRef<"pk_desver_cab", 'Int'>
    readonly pro_nro: FieldRef<"pk_desver_cab", 'Int'>
    readonly fec_ini: FieldRef<"pk_desver_cab", 'DateTime'>
    readonly fec_fin: FieldRef<"pk_desver_cab", 'DateTime'>
    readonly usu_res: FieldRef<"pk_desver_cab", 'String'>
    readonly pes_ini: FieldRef<"pk_desver_cab", 'Float'>
    readonly pes_fin: FieldRef<"pk_desver_cab", 'Float'>
    readonly cod_esp: FieldRef<"pk_desver_cab", 'String'>
    readonly fec_ven: FieldRef<"pk_desver_cab", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pk_desver_cab findUnique
   */
  export type pk_desver_cabFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_cab
     */
    select?: pk_desver_cabSelect<ExtArgs> | null
    /**
     * Filter, which pk_desver_cab to fetch.
     */
    where: pk_desver_cabWhereUniqueInput
  }

  /**
   * pk_desver_cab findUniqueOrThrow
   */
  export type pk_desver_cabFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_cab
     */
    select?: pk_desver_cabSelect<ExtArgs> | null
    /**
     * Filter, which pk_desver_cab to fetch.
     */
    where: pk_desver_cabWhereUniqueInput
  }

  /**
   * pk_desver_cab findFirst
   */
  export type pk_desver_cabFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_cab
     */
    select?: pk_desver_cabSelect<ExtArgs> | null
    /**
     * Filter, which pk_desver_cab to fetch.
     */
    where?: pk_desver_cabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pk_desver_cabs to fetch.
     */
    orderBy?: pk_desver_cabOrderByWithRelationInput | pk_desver_cabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pk_desver_cabs.
     */
    cursor?: pk_desver_cabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pk_desver_cabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pk_desver_cabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pk_desver_cabs.
     */
    distinct?: Pk_desver_cabScalarFieldEnum | Pk_desver_cabScalarFieldEnum[]
  }

  /**
   * pk_desver_cab findFirstOrThrow
   */
  export type pk_desver_cabFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_cab
     */
    select?: pk_desver_cabSelect<ExtArgs> | null
    /**
     * Filter, which pk_desver_cab to fetch.
     */
    where?: pk_desver_cabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pk_desver_cabs to fetch.
     */
    orderBy?: pk_desver_cabOrderByWithRelationInput | pk_desver_cabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pk_desver_cabs.
     */
    cursor?: pk_desver_cabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pk_desver_cabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pk_desver_cabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pk_desver_cabs.
     */
    distinct?: Pk_desver_cabScalarFieldEnum | Pk_desver_cabScalarFieldEnum[]
  }

  /**
   * pk_desver_cab findMany
   */
  export type pk_desver_cabFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_cab
     */
    select?: pk_desver_cabSelect<ExtArgs> | null
    /**
     * Filter, which pk_desver_cabs to fetch.
     */
    where?: pk_desver_cabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pk_desver_cabs to fetch.
     */
    orderBy?: pk_desver_cabOrderByWithRelationInput | pk_desver_cabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pk_desver_cabs.
     */
    cursor?: pk_desver_cabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pk_desver_cabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pk_desver_cabs.
     */
    skip?: number
    distinct?: Pk_desver_cabScalarFieldEnum | Pk_desver_cabScalarFieldEnum[]
  }

  /**
   * pk_desver_cab create
   */
  export type pk_desver_cabCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_cab
     */
    select?: pk_desver_cabSelect<ExtArgs> | null
    /**
     * The data needed to create a pk_desver_cab.
     */
    data?: XOR<pk_desver_cabCreateInput, pk_desver_cabUncheckedCreateInput>
  }

  /**
   * pk_desver_cab createMany
   */
  export type pk_desver_cabCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pk_desver_cabs.
     */
    data: pk_desver_cabCreateManyInput | pk_desver_cabCreateManyInput[]
  }

  /**
   * pk_desver_cab update
   */
  export type pk_desver_cabUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_cab
     */
    select?: pk_desver_cabSelect<ExtArgs> | null
    /**
     * The data needed to update a pk_desver_cab.
     */
    data: XOR<pk_desver_cabUpdateInput, pk_desver_cabUncheckedUpdateInput>
    /**
     * Choose, which pk_desver_cab to update.
     */
    where: pk_desver_cabWhereUniqueInput
  }

  /**
   * pk_desver_cab updateMany
   */
  export type pk_desver_cabUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pk_desver_cabs.
     */
    data: XOR<pk_desver_cabUpdateManyMutationInput, pk_desver_cabUncheckedUpdateManyInput>
    /**
     * Filter which pk_desver_cabs to update
     */
    where?: pk_desver_cabWhereInput
  }

  /**
   * pk_desver_cab upsert
   */
  export type pk_desver_cabUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_cab
     */
    select?: pk_desver_cabSelect<ExtArgs> | null
    /**
     * The filter to search for the pk_desver_cab to update in case it exists.
     */
    where: pk_desver_cabWhereUniqueInput
    /**
     * In case the pk_desver_cab found by the `where` argument doesn't exist, create a new pk_desver_cab with this data.
     */
    create: XOR<pk_desver_cabCreateInput, pk_desver_cabUncheckedCreateInput>
    /**
     * In case the pk_desver_cab was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pk_desver_cabUpdateInput, pk_desver_cabUncheckedUpdateInput>
  }

  /**
   * pk_desver_cab delete
   */
  export type pk_desver_cabDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_cab
     */
    select?: pk_desver_cabSelect<ExtArgs> | null
    /**
     * Filter which pk_desver_cab to delete.
     */
    where: pk_desver_cabWhereUniqueInput
  }

  /**
   * pk_desver_cab deleteMany
   */
  export type pk_desver_cabDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pk_desver_cabs to delete
     */
    where?: pk_desver_cabWhereInput
  }

  /**
   * pk_desver_cab without action
   */
  export type pk_desver_cabDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_cab
     */
    select?: pk_desver_cabSelect<ExtArgs> | null
  }


  /**
   * Model pk_desver_det
   */

  export type AggregatePk_desver_det = {
    _count: Pk_desver_detCountAggregateOutputType | null
    _avg: Pk_desver_detAvgAggregateOutputType | null
    _sum: Pk_desver_detSumAggregateOutputType | null
    _min: Pk_desver_detMinAggregateOutputType | null
    _max: Pk_desver_detMaxAggregateOutputType | null
  }

  export type Pk_desver_detAvgAggregateOutputType = {
    id: number | null
    id_cab: number | null
    peso_neto: number | null
    peso_fin: number | null
  }

  export type Pk_desver_detSumAggregateOutputType = {
    id: number | null
    id_cab: number | null
    peso_neto: number | null
    peso_fin: number | null
  }

  export type Pk_desver_detMinAggregateOutputType = {
    id: number | null
    id_cab: number | null
    folio: string | null
    cod_var: string | null
    cod_esp: string | null
    peso_neto: number | null
    peso_fin: number | null
    cod_cal: string | null
  }

  export type Pk_desver_detMaxAggregateOutputType = {
    id: number | null
    id_cab: number | null
    folio: string | null
    cod_var: string | null
    cod_esp: string | null
    peso_neto: number | null
    peso_fin: number | null
    cod_cal: string | null
  }

  export type Pk_desver_detCountAggregateOutputType = {
    id: number
    id_cab: number
    folio: number
    cod_var: number
    cod_esp: number
    peso_neto: number
    peso_fin: number
    cod_cal: number
    _all: number
  }


  export type Pk_desver_detAvgAggregateInputType = {
    id?: true
    id_cab?: true
    peso_neto?: true
    peso_fin?: true
  }

  export type Pk_desver_detSumAggregateInputType = {
    id?: true
    id_cab?: true
    peso_neto?: true
    peso_fin?: true
  }

  export type Pk_desver_detMinAggregateInputType = {
    id?: true
    id_cab?: true
    folio?: true
    cod_var?: true
    cod_esp?: true
    peso_neto?: true
    peso_fin?: true
    cod_cal?: true
  }

  export type Pk_desver_detMaxAggregateInputType = {
    id?: true
    id_cab?: true
    folio?: true
    cod_var?: true
    cod_esp?: true
    peso_neto?: true
    peso_fin?: true
    cod_cal?: true
  }

  export type Pk_desver_detCountAggregateInputType = {
    id?: true
    id_cab?: true
    folio?: true
    cod_var?: true
    cod_esp?: true
    peso_neto?: true
    peso_fin?: true
    cod_cal?: true
    _all?: true
  }

  export type Pk_desver_detAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pk_desver_det to aggregate.
     */
    where?: pk_desver_detWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pk_desver_dets to fetch.
     */
    orderBy?: pk_desver_detOrderByWithRelationInput | pk_desver_detOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pk_desver_detWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pk_desver_dets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pk_desver_dets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pk_desver_dets
    **/
    _count?: true | Pk_desver_detCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pk_desver_detAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pk_desver_detSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pk_desver_detMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pk_desver_detMaxAggregateInputType
  }

  export type GetPk_desver_detAggregateType<T extends Pk_desver_detAggregateArgs> = {
        [P in keyof T & keyof AggregatePk_desver_det]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePk_desver_det[P]>
      : GetScalarType<T[P], AggregatePk_desver_det[P]>
  }




  export type pk_desver_detGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pk_desver_detWhereInput
    orderBy?: pk_desver_detOrderByWithAggregationInput | pk_desver_detOrderByWithAggregationInput[]
    by: Pk_desver_detScalarFieldEnum[] | Pk_desver_detScalarFieldEnum
    having?: pk_desver_detScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pk_desver_detCountAggregateInputType | true
    _avg?: Pk_desver_detAvgAggregateInputType
    _sum?: Pk_desver_detSumAggregateInputType
    _min?: Pk_desver_detMinAggregateInputType
    _max?: Pk_desver_detMaxAggregateInputType
  }

  export type Pk_desver_detGroupByOutputType = {
    id: number
    id_cab: number | null
    folio: string | null
    cod_var: string | null
    cod_esp: string | null
    peso_neto: number | null
    peso_fin: number | null
    cod_cal: string | null
    _count: Pk_desver_detCountAggregateOutputType | null
    _avg: Pk_desver_detAvgAggregateOutputType | null
    _sum: Pk_desver_detSumAggregateOutputType | null
    _min: Pk_desver_detMinAggregateOutputType | null
    _max: Pk_desver_detMaxAggregateOutputType | null
  }

  type GetPk_desver_detGroupByPayload<T extends pk_desver_detGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pk_desver_detGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pk_desver_detGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pk_desver_detGroupByOutputType[P]>
            : GetScalarType<T[P], Pk_desver_detGroupByOutputType[P]>
        }
      >
    >


  export type pk_desver_detSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_cab?: boolean
    folio?: boolean
    cod_var?: boolean
    cod_esp?: boolean
    peso_neto?: boolean
    peso_fin?: boolean
    cod_cal?: boolean
  }, ExtArgs["result"]["pk_desver_det"]>


  export type pk_desver_detSelectScalar = {
    id?: boolean
    id_cab?: boolean
    folio?: boolean
    cod_var?: boolean
    cod_esp?: boolean
    peso_neto?: boolean
    peso_fin?: boolean
    cod_cal?: boolean
  }


  export type $pk_desver_detPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pk_desver_det"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      id_cab: number | null
      folio: string | null
      cod_var: string | null
      cod_esp: string | null
      peso_neto: number | null
      peso_fin: number | null
      cod_cal: string | null
    }, ExtArgs["result"]["pk_desver_det"]>
    composites: {}
  }

  type pk_desver_detGetPayload<S extends boolean | null | undefined | pk_desver_detDefaultArgs> = $Result.GetResult<Prisma.$pk_desver_detPayload, S>

  type pk_desver_detCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pk_desver_detFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Pk_desver_detCountAggregateInputType | true
    }

  export interface pk_desver_detDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pk_desver_det'], meta: { name: 'pk_desver_det' } }
    /**
     * Find zero or one Pk_desver_det that matches the filter.
     * @param {pk_desver_detFindUniqueArgs} args - Arguments to find a Pk_desver_det
     * @example
     * // Get one Pk_desver_det
     * const pk_desver_det = await prisma.pk_desver_det.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pk_desver_detFindUniqueArgs>(args: SelectSubset<T, pk_desver_detFindUniqueArgs<ExtArgs>>): Prisma__pk_desver_detClient<$Result.GetResult<Prisma.$pk_desver_detPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pk_desver_det that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pk_desver_detFindUniqueOrThrowArgs} args - Arguments to find a Pk_desver_det
     * @example
     * // Get one Pk_desver_det
     * const pk_desver_det = await prisma.pk_desver_det.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pk_desver_detFindUniqueOrThrowArgs>(args: SelectSubset<T, pk_desver_detFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pk_desver_detClient<$Result.GetResult<Prisma.$pk_desver_detPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pk_desver_det that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pk_desver_detFindFirstArgs} args - Arguments to find a Pk_desver_det
     * @example
     * // Get one Pk_desver_det
     * const pk_desver_det = await prisma.pk_desver_det.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pk_desver_detFindFirstArgs>(args?: SelectSubset<T, pk_desver_detFindFirstArgs<ExtArgs>>): Prisma__pk_desver_detClient<$Result.GetResult<Prisma.$pk_desver_detPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pk_desver_det that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pk_desver_detFindFirstOrThrowArgs} args - Arguments to find a Pk_desver_det
     * @example
     * // Get one Pk_desver_det
     * const pk_desver_det = await prisma.pk_desver_det.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pk_desver_detFindFirstOrThrowArgs>(args?: SelectSubset<T, pk_desver_detFindFirstOrThrowArgs<ExtArgs>>): Prisma__pk_desver_detClient<$Result.GetResult<Prisma.$pk_desver_detPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pk_desver_dets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pk_desver_detFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pk_desver_dets
     * const pk_desver_dets = await prisma.pk_desver_det.findMany()
     * 
     * // Get first 10 Pk_desver_dets
     * const pk_desver_dets = await prisma.pk_desver_det.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pk_desver_detWithIdOnly = await prisma.pk_desver_det.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pk_desver_detFindManyArgs>(args?: SelectSubset<T, pk_desver_detFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pk_desver_detPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pk_desver_det.
     * @param {pk_desver_detCreateArgs} args - Arguments to create a Pk_desver_det.
     * @example
     * // Create one Pk_desver_det
     * const Pk_desver_det = await prisma.pk_desver_det.create({
     *   data: {
     *     // ... data to create a Pk_desver_det
     *   }
     * })
     * 
     */
    create<T extends pk_desver_detCreateArgs>(args: SelectSubset<T, pk_desver_detCreateArgs<ExtArgs>>): Prisma__pk_desver_detClient<$Result.GetResult<Prisma.$pk_desver_detPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pk_desver_dets.
     * @param {pk_desver_detCreateManyArgs} args - Arguments to create many Pk_desver_dets.
     * @example
     * // Create many Pk_desver_dets
     * const pk_desver_det = await prisma.pk_desver_det.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pk_desver_detCreateManyArgs>(args?: SelectSubset<T, pk_desver_detCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pk_desver_det.
     * @param {pk_desver_detDeleteArgs} args - Arguments to delete one Pk_desver_det.
     * @example
     * // Delete one Pk_desver_det
     * const Pk_desver_det = await prisma.pk_desver_det.delete({
     *   where: {
     *     // ... filter to delete one Pk_desver_det
     *   }
     * })
     * 
     */
    delete<T extends pk_desver_detDeleteArgs>(args: SelectSubset<T, pk_desver_detDeleteArgs<ExtArgs>>): Prisma__pk_desver_detClient<$Result.GetResult<Prisma.$pk_desver_detPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pk_desver_det.
     * @param {pk_desver_detUpdateArgs} args - Arguments to update one Pk_desver_det.
     * @example
     * // Update one Pk_desver_det
     * const pk_desver_det = await prisma.pk_desver_det.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pk_desver_detUpdateArgs>(args: SelectSubset<T, pk_desver_detUpdateArgs<ExtArgs>>): Prisma__pk_desver_detClient<$Result.GetResult<Prisma.$pk_desver_detPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pk_desver_dets.
     * @param {pk_desver_detDeleteManyArgs} args - Arguments to filter Pk_desver_dets to delete.
     * @example
     * // Delete a few Pk_desver_dets
     * const { count } = await prisma.pk_desver_det.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pk_desver_detDeleteManyArgs>(args?: SelectSubset<T, pk_desver_detDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pk_desver_dets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pk_desver_detUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pk_desver_dets
     * const pk_desver_det = await prisma.pk_desver_det.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pk_desver_detUpdateManyArgs>(args: SelectSubset<T, pk_desver_detUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pk_desver_det.
     * @param {pk_desver_detUpsertArgs} args - Arguments to update or create a Pk_desver_det.
     * @example
     * // Update or create a Pk_desver_det
     * const pk_desver_det = await prisma.pk_desver_det.upsert({
     *   create: {
     *     // ... data to create a Pk_desver_det
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pk_desver_det we want to update
     *   }
     * })
     */
    upsert<T extends pk_desver_detUpsertArgs>(args: SelectSubset<T, pk_desver_detUpsertArgs<ExtArgs>>): Prisma__pk_desver_detClient<$Result.GetResult<Prisma.$pk_desver_detPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pk_desver_dets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pk_desver_detCountArgs} args - Arguments to filter Pk_desver_dets to count.
     * @example
     * // Count the number of Pk_desver_dets
     * const count = await prisma.pk_desver_det.count({
     *   where: {
     *     // ... the filter for the Pk_desver_dets we want to count
     *   }
     * })
    **/
    count<T extends pk_desver_detCountArgs>(
      args?: Subset<T, pk_desver_detCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pk_desver_detCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pk_desver_det.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pk_desver_detAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pk_desver_detAggregateArgs>(args: Subset<T, Pk_desver_detAggregateArgs>): Prisma.PrismaPromise<GetPk_desver_detAggregateType<T>>

    /**
     * Group by Pk_desver_det.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pk_desver_detGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pk_desver_detGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pk_desver_detGroupByArgs['orderBy'] }
        : { orderBy?: pk_desver_detGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pk_desver_detGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPk_desver_detGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pk_desver_det model
   */
  readonly fields: pk_desver_detFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pk_desver_det.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pk_desver_detClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pk_desver_det model
   */ 
  interface pk_desver_detFieldRefs {
    readonly id: FieldRef<"pk_desver_det", 'Int'>
    readonly id_cab: FieldRef<"pk_desver_det", 'Int'>
    readonly folio: FieldRef<"pk_desver_det", 'String'>
    readonly cod_var: FieldRef<"pk_desver_det", 'String'>
    readonly cod_esp: FieldRef<"pk_desver_det", 'String'>
    readonly peso_neto: FieldRef<"pk_desver_det", 'Float'>
    readonly peso_fin: FieldRef<"pk_desver_det", 'Float'>
    readonly cod_cal: FieldRef<"pk_desver_det", 'String'>
  }
    

  // Custom InputTypes
  /**
   * pk_desver_det findUnique
   */
  export type pk_desver_detFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_det
     */
    select?: pk_desver_detSelect<ExtArgs> | null
    /**
     * Filter, which pk_desver_det to fetch.
     */
    where: pk_desver_detWhereUniqueInput
  }

  /**
   * pk_desver_det findUniqueOrThrow
   */
  export type pk_desver_detFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_det
     */
    select?: pk_desver_detSelect<ExtArgs> | null
    /**
     * Filter, which pk_desver_det to fetch.
     */
    where: pk_desver_detWhereUniqueInput
  }

  /**
   * pk_desver_det findFirst
   */
  export type pk_desver_detFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_det
     */
    select?: pk_desver_detSelect<ExtArgs> | null
    /**
     * Filter, which pk_desver_det to fetch.
     */
    where?: pk_desver_detWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pk_desver_dets to fetch.
     */
    orderBy?: pk_desver_detOrderByWithRelationInput | pk_desver_detOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pk_desver_dets.
     */
    cursor?: pk_desver_detWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pk_desver_dets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pk_desver_dets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pk_desver_dets.
     */
    distinct?: Pk_desver_detScalarFieldEnum | Pk_desver_detScalarFieldEnum[]
  }

  /**
   * pk_desver_det findFirstOrThrow
   */
  export type pk_desver_detFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_det
     */
    select?: pk_desver_detSelect<ExtArgs> | null
    /**
     * Filter, which pk_desver_det to fetch.
     */
    where?: pk_desver_detWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pk_desver_dets to fetch.
     */
    orderBy?: pk_desver_detOrderByWithRelationInput | pk_desver_detOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pk_desver_dets.
     */
    cursor?: pk_desver_detWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pk_desver_dets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pk_desver_dets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pk_desver_dets.
     */
    distinct?: Pk_desver_detScalarFieldEnum | Pk_desver_detScalarFieldEnum[]
  }

  /**
   * pk_desver_det findMany
   */
  export type pk_desver_detFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_det
     */
    select?: pk_desver_detSelect<ExtArgs> | null
    /**
     * Filter, which pk_desver_dets to fetch.
     */
    where?: pk_desver_detWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pk_desver_dets to fetch.
     */
    orderBy?: pk_desver_detOrderByWithRelationInput | pk_desver_detOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pk_desver_dets.
     */
    cursor?: pk_desver_detWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pk_desver_dets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pk_desver_dets.
     */
    skip?: number
    distinct?: Pk_desver_detScalarFieldEnum | Pk_desver_detScalarFieldEnum[]
  }

  /**
   * pk_desver_det create
   */
  export type pk_desver_detCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_det
     */
    select?: pk_desver_detSelect<ExtArgs> | null
    /**
     * The data needed to create a pk_desver_det.
     */
    data?: XOR<pk_desver_detCreateInput, pk_desver_detUncheckedCreateInput>
  }

  /**
   * pk_desver_det createMany
   */
  export type pk_desver_detCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pk_desver_dets.
     */
    data: pk_desver_detCreateManyInput | pk_desver_detCreateManyInput[]
  }

  /**
   * pk_desver_det update
   */
  export type pk_desver_detUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_det
     */
    select?: pk_desver_detSelect<ExtArgs> | null
    /**
     * The data needed to update a pk_desver_det.
     */
    data: XOR<pk_desver_detUpdateInput, pk_desver_detUncheckedUpdateInput>
    /**
     * Choose, which pk_desver_det to update.
     */
    where: pk_desver_detWhereUniqueInput
  }

  /**
   * pk_desver_det updateMany
   */
  export type pk_desver_detUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pk_desver_dets.
     */
    data: XOR<pk_desver_detUpdateManyMutationInput, pk_desver_detUncheckedUpdateManyInput>
    /**
     * Filter which pk_desver_dets to update
     */
    where?: pk_desver_detWhereInput
  }

  /**
   * pk_desver_det upsert
   */
  export type pk_desver_detUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_det
     */
    select?: pk_desver_detSelect<ExtArgs> | null
    /**
     * The filter to search for the pk_desver_det to update in case it exists.
     */
    where: pk_desver_detWhereUniqueInput
    /**
     * In case the pk_desver_det found by the `where` argument doesn't exist, create a new pk_desver_det with this data.
     */
    create: XOR<pk_desver_detCreateInput, pk_desver_detUncheckedCreateInput>
    /**
     * In case the pk_desver_det was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pk_desver_detUpdateInput, pk_desver_detUncheckedUpdateInput>
  }

  /**
   * pk_desver_det delete
   */
  export type pk_desver_detDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_det
     */
    select?: pk_desver_detSelect<ExtArgs> | null
    /**
     * Filter which pk_desver_det to delete.
     */
    where: pk_desver_detWhereUniqueInput
  }

  /**
   * pk_desver_det deleteMany
   */
  export type pk_desver_detDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pk_desver_dets to delete
     */
    where?: pk_desver_detWhereInput
  }

  /**
   * pk_desver_det without action
   */
  export type pk_desver_detDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_desver_det
     */
    select?: pk_desver_detSelect<ExtArgs> | null
  }


  /**
   * Model sys_log
   */

  export type AggregateSys_log = {
    _count: Sys_logCountAggregateOutputType | null
    _avg: Sys_logAvgAggregateOutputType | null
    _sum: Sys_logSumAggregateOutputType | null
    _min: Sys_logMinAggregateOutputType | null
    _max: Sys_logMaxAggregateOutputType | null
  }

  export type Sys_logAvgAggregateOutputType = {
    id: number | null
  }

  export type Sys_logSumAggregateOutputType = {
    id: number | null
  }

  export type Sys_logMinAggregateOutputType = {
    id: number | null
    tip_eve: string | null
    usu_sys: string | null
    ip_pc: string | null
    fecha_log: Date | null
    folio: string | null
    modulo: string | null
  }

  export type Sys_logMaxAggregateOutputType = {
    id: number | null
    tip_eve: string | null
    usu_sys: string | null
    ip_pc: string | null
    fecha_log: Date | null
    folio: string | null
    modulo: string | null
  }

  export type Sys_logCountAggregateOutputType = {
    id: number
    tip_eve: number
    usu_sys: number
    ip_pc: number
    fecha_log: number
    folio: number
    modulo: number
    _all: number
  }


  export type Sys_logAvgAggregateInputType = {
    id?: true
  }

  export type Sys_logSumAggregateInputType = {
    id?: true
  }

  export type Sys_logMinAggregateInputType = {
    id?: true
    tip_eve?: true
    usu_sys?: true
    ip_pc?: true
    fecha_log?: true
    folio?: true
    modulo?: true
  }

  export type Sys_logMaxAggregateInputType = {
    id?: true
    tip_eve?: true
    usu_sys?: true
    ip_pc?: true
    fecha_log?: true
    folio?: true
    modulo?: true
  }

  export type Sys_logCountAggregateInputType = {
    id?: true
    tip_eve?: true
    usu_sys?: true
    ip_pc?: true
    fecha_log?: true
    folio?: true
    modulo?: true
    _all?: true
  }

  export type Sys_logAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sys_log to aggregate.
     */
    where?: sys_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_logs to fetch.
     */
    orderBy?: sys_logOrderByWithRelationInput | sys_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sys_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sys_logs
    **/
    _count?: true | Sys_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sys_logAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sys_logSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sys_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sys_logMaxAggregateInputType
  }

  export type GetSys_logAggregateType<T extends Sys_logAggregateArgs> = {
        [P in keyof T & keyof AggregateSys_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSys_log[P]>
      : GetScalarType<T[P], AggregateSys_log[P]>
  }




  export type sys_logGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sys_logWhereInput
    orderBy?: sys_logOrderByWithAggregationInput | sys_logOrderByWithAggregationInput[]
    by: Sys_logScalarFieldEnum[] | Sys_logScalarFieldEnum
    having?: sys_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sys_logCountAggregateInputType | true
    _avg?: Sys_logAvgAggregateInputType
    _sum?: Sys_logSumAggregateInputType
    _min?: Sys_logMinAggregateInputType
    _max?: Sys_logMaxAggregateInputType
  }

  export type Sys_logGroupByOutputType = {
    id: number
    tip_eve: string | null
    usu_sys: string | null
    ip_pc: string | null
    fecha_log: Date | null
    folio: string | null
    modulo: string | null
    _count: Sys_logCountAggregateOutputType | null
    _avg: Sys_logAvgAggregateOutputType | null
    _sum: Sys_logSumAggregateOutputType | null
    _min: Sys_logMinAggregateOutputType | null
    _max: Sys_logMaxAggregateOutputType | null
  }

  type GetSys_logGroupByPayload<T extends sys_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sys_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sys_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sys_logGroupByOutputType[P]>
            : GetScalarType<T[P], Sys_logGroupByOutputType[P]>
        }
      >
    >


  export type sys_logSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tip_eve?: boolean
    usu_sys?: boolean
    ip_pc?: boolean
    fecha_log?: boolean
    folio?: boolean
    modulo?: boolean
  }, ExtArgs["result"]["sys_log"]>


  export type sys_logSelectScalar = {
    id?: boolean
    tip_eve?: boolean
    usu_sys?: boolean
    ip_pc?: boolean
    fecha_log?: boolean
    folio?: boolean
    modulo?: boolean
  }


  export type $sys_logPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sys_log"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tip_eve: string | null
      usu_sys: string | null
      ip_pc: string | null
      fecha_log: Date | null
      folio: string | null
      modulo: string | null
    }, ExtArgs["result"]["sys_log"]>
    composites: {}
  }

  type sys_logGetPayload<S extends boolean | null | undefined | sys_logDefaultArgs> = $Result.GetResult<Prisma.$sys_logPayload, S>

  type sys_logCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<sys_logFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Sys_logCountAggregateInputType | true
    }

  export interface sys_logDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sys_log'], meta: { name: 'sys_log' } }
    /**
     * Find zero or one Sys_log that matches the filter.
     * @param {sys_logFindUniqueArgs} args - Arguments to find a Sys_log
     * @example
     * // Get one Sys_log
     * const sys_log = await prisma.sys_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sys_logFindUniqueArgs>(args: SelectSubset<T, sys_logFindUniqueArgs<ExtArgs>>): Prisma__sys_logClient<$Result.GetResult<Prisma.$sys_logPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sys_log that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {sys_logFindUniqueOrThrowArgs} args - Arguments to find a Sys_log
     * @example
     * // Get one Sys_log
     * const sys_log = await prisma.sys_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sys_logFindUniqueOrThrowArgs>(args: SelectSubset<T, sys_logFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sys_logClient<$Result.GetResult<Prisma.$sys_logPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sys_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_logFindFirstArgs} args - Arguments to find a Sys_log
     * @example
     * // Get one Sys_log
     * const sys_log = await prisma.sys_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sys_logFindFirstArgs>(args?: SelectSubset<T, sys_logFindFirstArgs<ExtArgs>>): Prisma__sys_logClient<$Result.GetResult<Prisma.$sys_logPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sys_log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_logFindFirstOrThrowArgs} args - Arguments to find a Sys_log
     * @example
     * // Get one Sys_log
     * const sys_log = await prisma.sys_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sys_logFindFirstOrThrowArgs>(args?: SelectSubset<T, sys_logFindFirstOrThrowArgs<ExtArgs>>): Prisma__sys_logClient<$Result.GetResult<Prisma.$sys_logPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sys_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_logFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sys_logs
     * const sys_logs = await prisma.sys_log.findMany()
     * 
     * // Get first 10 Sys_logs
     * const sys_logs = await prisma.sys_log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sys_logWithIdOnly = await prisma.sys_log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sys_logFindManyArgs>(args?: SelectSubset<T, sys_logFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sys_logPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sys_log.
     * @param {sys_logCreateArgs} args - Arguments to create a Sys_log.
     * @example
     * // Create one Sys_log
     * const Sys_log = await prisma.sys_log.create({
     *   data: {
     *     // ... data to create a Sys_log
     *   }
     * })
     * 
     */
    create<T extends sys_logCreateArgs>(args: SelectSubset<T, sys_logCreateArgs<ExtArgs>>): Prisma__sys_logClient<$Result.GetResult<Prisma.$sys_logPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sys_logs.
     * @param {sys_logCreateManyArgs} args - Arguments to create many Sys_logs.
     * @example
     * // Create many Sys_logs
     * const sys_log = await prisma.sys_log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sys_logCreateManyArgs>(args?: SelectSubset<T, sys_logCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sys_log.
     * @param {sys_logDeleteArgs} args - Arguments to delete one Sys_log.
     * @example
     * // Delete one Sys_log
     * const Sys_log = await prisma.sys_log.delete({
     *   where: {
     *     // ... filter to delete one Sys_log
     *   }
     * })
     * 
     */
    delete<T extends sys_logDeleteArgs>(args: SelectSubset<T, sys_logDeleteArgs<ExtArgs>>): Prisma__sys_logClient<$Result.GetResult<Prisma.$sys_logPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sys_log.
     * @param {sys_logUpdateArgs} args - Arguments to update one Sys_log.
     * @example
     * // Update one Sys_log
     * const sys_log = await prisma.sys_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sys_logUpdateArgs>(args: SelectSubset<T, sys_logUpdateArgs<ExtArgs>>): Prisma__sys_logClient<$Result.GetResult<Prisma.$sys_logPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sys_logs.
     * @param {sys_logDeleteManyArgs} args - Arguments to filter Sys_logs to delete.
     * @example
     * // Delete a few Sys_logs
     * const { count } = await prisma.sys_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sys_logDeleteManyArgs>(args?: SelectSubset<T, sys_logDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sys_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sys_logs
     * const sys_log = await prisma.sys_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sys_logUpdateManyArgs>(args: SelectSubset<T, sys_logUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sys_log.
     * @param {sys_logUpsertArgs} args - Arguments to update or create a Sys_log.
     * @example
     * // Update or create a Sys_log
     * const sys_log = await prisma.sys_log.upsert({
     *   create: {
     *     // ... data to create a Sys_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sys_log we want to update
     *   }
     * })
     */
    upsert<T extends sys_logUpsertArgs>(args: SelectSubset<T, sys_logUpsertArgs<ExtArgs>>): Prisma__sys_logClient<$Result.GetResult<Prisma.$sys_logPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sys_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_logCountArgs} args - Arguments to filter Sys_logs to count.
     * @example
     * // Count the number of Sys_logs
     * const count = await prisma.sys_log.count({
     *   where: {
     *     // ... the filter for the Sys_logs we want to count
     *   }
     * })
    **/
    count<T extends sys_logCountArgs>(
      args?: Subset<T, sys_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sys_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sys_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sys_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sys_logAggregateArgs>(args: Subset<T, Sys_logAggregateArgs>): Prisma.PrismaPromise<GetSys_logAggregateType<T>>

    /**
     * Group by Sys_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sys_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sys_logGroupByArgs['orderBy'] }
        : { orderBy?: sys_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sys_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSys_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sys_log model
   */
  readonly fields: sys_logFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sys_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sys_logClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sys_log model
   */ 
  interface sys_logFieldRefs {
    readonly id: FieldRef<"sys_log", 'Int'>
    readonly tip_eve: FieldRef<"sys_log", 'String'>
    readonly usu_sys: FieldRef<"sys_log", 'String'>
    readonly ip_pc: FieldRef<"sys_log", 'String'>
    readonly fecha_log: FieldRef<"sys_log", 'DateTime'>
    readonly folio: FieldRef<"sys_log", 'String'>
    readonly modulo: FieldRef<"sys_log", 'String'>
  }
    

  // Custom InputTypes
  /**
   * sys_log findUnique
   */
  export type sys_logFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_log
     */
    select?: sys_logSelect<ExtArgs> | null
    /**
     * Filter, which sys_log to fetch.
     */
    where: sys_logWhereUniqueInput
  }

  /**
   * sys_log findUniqueOrThrow
   */
  export type sys_logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_log
     */
    select?: sys_logSelect<ExtArgs> | null
    /**
     * Filter, which sys_log to fetch.
     */
    where: sys_logWhereUniqueInput
  }

  /**
   * sys_log findFirst
   */
  export type sys_logFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_log
     */
    select?: sys_logSelect<ExtArgs> | null
    /**
     * Filter, which sys_log to fetch.
     */
    where?: sys_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_logs to fetch.
     */
    orderBy?: sys_logOrderByWithRelationInput | sys_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sys_logs.
     */
    cursor?: sys_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sys_logs.
     */
    distinct?: Sys_logScalarFieldEnum | Sys_logScalarFieldEnum[]
  }

  /**
   * sys_log findFirstOrThrow
   */
  export type sys_logFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_log
     */
    select?: sys_logSelect<ExtArgs> | null
    /**
     * Filter, which sys_log to fetch.
     */
    where?: sys_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_logs to fetch.
     */
    orderBy?: sys_logOrderByWithRelationInput | sys_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sys_logs.
     */
    cursor?: sys_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sys_logs.
     */
    distinct?: Sys_logScalarFieldEnum | Sys_logScalarFieldEnum[]
  }

  /**
   * sys_log findMany
   */
  export type sys_logFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_log
     */
    select?: sys_logSelect<ExtArgs> | null
    /**
     * Filter, which sys_logs to fetch.
     */
    where?: sys_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_logs to fetch.
     */
    orderBy?: sys_logOrderByWithRelationInput | sys_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sys_logs.
     */
    cursor?: sys_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_logs.
     */
    skip?: number
    distinct?: Sys_logScalarFieldEnum | Sys_logScalarFieldEnum[]
  }

  /**
   * sys_log create
   */
  export type sys_logCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_log
     */
    select?: sys_logSelect<ExtArgs> | null
    /**
     * The data needed to create a sys_log.
     */
    data?: XOR<sys_logCreateInput, sys_logUncheckedCreateInput>
  }

  /**
   * sys_log createMany
   */
  export type sys_logCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sys_logs.
     */
    data: sys_logCreateManyInput | sys_logCreateManyInput[]
  }

  /**
   * sys_log update
   */
  export type sys_logUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_log
     */
    select?: sys_logSelect<ExtArgs> | null
    /**
     * The data needed to update a sys_log.
     */
    data: XOR<sys_logUpdateInput, sys_logUncheckedUpdateInput>
    /**
     * Choose, which sys_log to update.
     */
    where: sys_logWhereUniqueInput
  }

  /**
   * sys_log updateMany
   */
  export type sys_logUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sys_logs.
     */
    data: XOR<sys_logUpdateManyMutationInput, sys_logUncheckedUpdateManyInput>
    /**
     * Filter which sys_logs to update
     */
    where?: sys_logWhereInput
  }

  /**
   * sys_log upsert
   */
  export type sys_logUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_log
     */
    select?: sys_logSelect<ExtArgs> | null
    /**
     * The filter to search for the sys_log to update in case it exists.
     */
    where: sys_logWhereUniqueInput
    /**
     * In case the sys_log found by the `where` argument doesn't exist, create a new sys_log with this data.
     */
    create: XOR<sys_logCreateInput, sys_logUncheckedCreateInput>
    /**
     * In case the sys_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sys_logUpdateInput, sys_logUncheckedUpdateInput>
  }

  /**
   * sys_log delete
   */
  export type sys_logDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_log
     */
    select?: sys_logSelect<ExtArgs> | null
    /**
     * Filter which sys_log to delete.
     */
    where: sys_logWhereUniqueInput
  }

  /**
   * sys_log deleteMany
   */
  export type sys_logDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sys_logs to delete
     */
    where?: sys_logWhereInput
  }

  /**
   * sys_log without action
   */
  export type sys_logDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sys_log
     */
    select?: sys_logSelect<ExtArgs> | null
  }


  /**
   * Model sysdiagrams
   */

  export type AggregateSysdiagrams = {
    _count: SysdiagramsCountAggregateOutputType | null
    _avg: SysdiagramsAvgAggregateOutputType | null
    _sum: SysdiagramsSumAggregateOutputType | null
    _min: SysdiagramsMinAggregateOutputType | null
    _max: SysdiagramsMaxAggregateOutputType | null
  }

  export type SysdiagramsAvgAggregateOutputType = {
    principal_id: number | null
    diagram_id: number | null
    version: number | null
  }

  export type SysdiagramsSumAggregateOutputType = {
    principal_id: number | null
    diagram_id: number | null
    version: number | null
  }

  export type SysdiagramsMinAggregateOutputType = {
    name: string | null
    principal_id: number | null
    diagram_id: number | null
    version: number | null
    definition: Buffer | null
  }

  export type SysdiagramsMaxAggregateOutputType = {
    name: string | null
    principal_id: number | null
    diagram_id: number | null
    version: number | null
    definition: Buffer | null
  }

  export type SysdiagramsCountAggregateOutputType = {
    name: number
    principal_id: number
    diagram_id: number
    version: number
    definition: number
    _all: number
  }


  export type SysdiagramsAvgAggregateInputType = {
    principal_id?: true
    diagram_id?: true
    version?: true
  }

  export type SysdiagramsSumAggregateInputType = {
    principal_id?: true
    diagram_id?: true
    version?: true
  }

  export type SysdiagramsMinAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
  }

  export type SysdiagramsMaxAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
  }

  export type SysdiagramsCountAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
    _all?: true
  }

  export type SysdiagramsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sysdiagrams to aggregate.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sysdiagrams
    **/
    _count?: true | SysdiagramsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SysdiagramsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SysdiagramsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SysdiagramsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SysdiagramsMaxAggregateInputType
  }

  export type GetSysdiagramsAggregateType<T extends SysdiagramsAggregateArgs> = {
        [P in keyof T & keyof AggregateSysdiagrams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSysdiagrams[P]>
      : GetScalarType<T[P], AggregateSysdiagrams[P]>
  }




  export type sysdiagramsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sysdiagramsWhereInput
    orderBy?: sysdiagramsOrderByWithAggregationInput | sysdiagramsOrderByWithAggregationInput[]
    by: SysdiagramsScalarFieldEnum[] | SysdiagramsScalarFieldEnum
    having?: sysdiagramsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SysdiagramsCountAggregateInputType | true
    _avg?: SysdiagramsAvgAggregateInputType
    _sum?: SysdiagramsSumAggregateInputType
    _min?: SysdiagramsMinAggregateInputType
    _max?: SysdiagramsMaxAggregateInputType
  }

  export type SysdiagramsGroupByOutputType = {
    name: string
    principal_id: number
    diagram_id: number
    version: number | null
    definition: Buffer | null
    _count: SysdiagramsCountAggregateOutputType | null
    _avg: SysdiagramsAvgAggregateOutputType | null
    _sum: SysdiagramsSumAggregateOutputType | null
    _min: SysdiagramsMinAggregateOutputType | null
    _max: SysdiagramsMaxAggregateOutputType | null
  }

  type GetSysdiagramsGroupByPayload<T extends sysdiagramsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SysdiagramsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SysdiagramsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SysdiagramsGroupByOutputType[P]>
            : GetScalarType<T[P], SysdiagramsGroupByOutputType[P]>
        }
      >
    >


  export type sysdiagramsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    principal_id?: boolean
    diagram_id?: boolean
    version?: boolean
    definition?: boolean
  }, ExtArgs["result"]["sysdiagrams"]>


  export type sysdiagramsSelectScalar = {
    name?: boolean
    principal_id?: boolean
    diagram_id?: boolean
    version?: boolean
    definition?: boolean
  }


  export type $sysdiagramsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sysdiagrams"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      name: string
      principal_id: number
      diagram_id: number
      version: number | null
      definition: Buffer | null
    }, ExtArgs["result"]["sysdiagrams"]>
    composites: {}
  }

  type sysdiagramsGetPayload<S extends boolean | null | undefined | sysdiagramsDefaultArgs> = $Result.GetResult<Prisma.$sysdiagramsPayload, S>

  type sysdiagramsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<sysdiagramsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SysdiagramsCountAggregateInputType | true
    }

  export interface sysdiagramsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sysdiagrams'], meta: { name: 'sysdiagrams' } }
    /**
     * Find zero or one Sysdiagrams that matches the filter.
     * @param {sysdiagramsFindUniqueArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sysdiagramsFindUniqueArgs>(args: SelectSubset<T, sysdiagramsFindUniqueArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sysdiagrams that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {sysdiagramsFindUniqueOrThrowArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sysdiagramsFindUniqueOrThrowArgs>(args: SelectSubset<T, sysdiagramsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sysdiagrams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindFirstArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sysdiagramsFindFirstArgs>(args?: SelectSubset<T, sysdiagramsFindFirstArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sysdiagrams that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindFirstOrThrowArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sysdiagramsFindFirstOrThrowArgs>(args?: SelectSubset<T, sysdiagramsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sysdiagrams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findMany()
     * 
     * // Get first 10 Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const sysdiagramsWithNameOnly = await prisma.sysdiagrams.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends sysdiagramsFindManyArgs>(args?: SelectSubset<T, sysdiagramsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sysdiagrams.
     * @param {sysdiagramsCreateArgs} args - Arguments to create a Sysdiagrams.
     * @example
     * // Create one Sysdiagrams
     * const Sysdiagrams = await prisma.sysdiagrams.create({
     *   data: {
     *     // ... data to create a Sysdiagrams
     *   }
     * })
     * 
     */
    create<T extends sysdiagramsCreateArgs>(args: SelectSubset<T, sysdiagramsCreateArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sysdiagrams.
     * @param {sysdiagramsCreateManyArgs} args - Arguments to create many Sysdiagrams.
     * @example
     * // Create many Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sysdiagramsCreateManyArgs>(args?: SelectSubset<T, sysdiagramsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sysdiagrams.
     * @param {sysdiagramsDeleteArgs} args - Arguments to delete one Sysdiagrams.
     * @example
     * // Delete one Sysdiagrams
     * const Sysdiagrams = await prisma.sysdiagrams.delete({
     *   where: {
     *     // ... filter to delete one Sysdiagrams
     *   }
     * })
     * 
     */
    delete<T extends sysdiagramsDeleteArgs>(args: SelectSubset<T, sysdiagramsDeleteArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sysdiagrams.
     * @param {sysdiagramsUpdateArgs} args - Arguments to update one Sysdiagrams.
     * @example
     * // Update one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sysdiagramsUpdateArgs>(args: SelectSubset<T, sysdiagramsUpdateArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sysdiagrams.
     * @param {sysdiagramsDeleteManyArgs} args - Arguments to filter Sysdiagrams to delete.
     * @example
     * // Delete a few Sysdiagrams
     * const { count } = await prisma.sysdiagrams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sysdiagramsDeleteManyArgs>(args?: SelectSubset<T, sysdiagramsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sysdiagramsUpdateManyArgs>(args: SelectSubset<T, sysdiagramsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sysdiagrams.
     * @param {sysdiagramsUpsertArgs} args - Arguments to update or create a Sysdiagrams.
     * @example
     * // Update or create a Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.upsert({
     *   create: {
     *     // ... data to create a Sysdiagrams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sysdiagrams we want to update
     *   }
     * })
     */
    upsert<T extends sysdiagramsUpsertArgs>(args: SelectSubset<T, sysdiagramsUpsertArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsCountArgs} args - Arguments to filter Sysdiagrams to count.
     * @example
     * // Count the number of Sysdiagrams
     * const count = await prisma.sysdiagrams.count({
     *   where: {
     *     // ... the filter for the Sysdiagrams we want to count
     *   }
     * })
    **/
    count<T extends sysdiagramsCountArgs>(
      args?: Subset<T, sysdiagramsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SysdiagramsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SysdiagramsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SysdiagramsAggregateArgs>(args: Subset<T, SysdiagramsAggregateArgs>): Prisma.PrismaPromise<GetSysdiagramsAggregateType<T>>

    /**
     * Group by Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sysdiagramsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sysdiagramsGroupByArgs['orderBy'] }
        : { orderBy?: sysdiagramsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sysdiagramsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSysdiagramsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sysdiagrams model
   */
  readonly fields: sysdiagramsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sysdiagrams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sysdiagramsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sysdiagrams model
   */ 
  interface sysdiagramsFieldRefs {
    readonly name: FieldRef<"sysdiagrams", 'String'>
    readonly principal_id: FieldRef<"sysdiagrams", 'Int'>
    readonly diagram_id: FieldRef<"sysdiagrams", 'Int'>
    readonly version: FieldRef<"sysdiagrams", 'Int'>
    readonly definition: FieldRef<"sysdiagrams", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * sysdiagrams findUnique
   */
  export type sysdiagramsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams findUniqueOrThrow
   */
  export type sysdiagramsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams findFirst
   */
  export type sysdiagramsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sysdiagrams.
     */
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams findFirstOrThrow
   */
  export type sysdiagramsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sysdiagrams.
     */
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams findMany
   */
  export type sysdiagramsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams create
   */
  export type sysdiagramsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * The data needed to create a sysdiagrams.
     */
    data: XOR<sysdiagramsCreateInput, sysdiagramsUncheckedCreateInput>
  }

  /**
   * sysdiagrams createMany
   */
  export type sysdiagramsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sysdiagrams.
     */
    data: sysdiagramsCreateManyInput | sysdiagramsCreateManyInput[]
  }

  /**
   * sysdiagrams update
   */
  export type sysdiagramsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * The data needed to update a sysdiagrams.
     */
    data: XOR<sysdiagramsUpdateInput, sysdiagramsUncheckedUpdateInput>
    /**
     * Choose, which sysdiagrams to update.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams updateMany
   */
  export type sysdiagramsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sysdiagrams.
     */
    data: XOR<sysdiagramsUpdateManyMutationInput, sysdiagramsUncheckedUpdateManyInput>
    /**
     * Filter which sysdiagrams to update
     */
    where?: sysdiagramsWhereInput
  }

  /**
   * sysdiagrams upsert
   */
  export type sysdiagramsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * The filter to search for the sysdiagrams to update in case it exists.
     */
    where: sysdiagramsWhereUniqueInput
    /**
     * In case the sysdiagrams found by the `where` argument doesn't exist, create a new sysdiagrams with this data.
     */
    create: XOR<sysdiagramsCreateInput, sysdiagramsUncheckedCreateInput>
    /**
     * In case the sysdiagrams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sysdiagramsUpdateInput, sysdiagramsUncheckedUpdateInput>
  }

  /**
   * sysdiagrams delete
   */
  export type sysdiagramsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Filter which sysdiagrams to delete.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams deleteMany
   */
  export type sysdiagramsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sysdiagrams to delete
     */
    where?: sysdiagramsWhereInput
  }

  /**
   * sysdiagrams without action
   */
  export type sysdiagramsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
  }


  /**
   * Model tipo_ins
   */

  export type AggregateTipo_ins = {
    _count: Tipo_insCountAggregateOutputType | null
    _avg: Tipo_insAvgAggregateOutputType | null
    _sum: Tipo_insSumAggregateOutputType | null
    _min: Tipo_insMinAggregateOutputType | null
    _max: Tipo_insMaxAggregateOutputType | null
  }

  export type Tipo_insAvgAggregateOutputType = {
    id_tip_ins: number | null
  }

  export type Tipo_insSumAggregateOutputType = {
    id_tip_ins: number | null
  }

  export type Tipo_insMinAggregateOutputType = {
    id_tip_ins: number | null
    des_tip_ins: string | null
  }

  export type Tipo_insMaxAggregateOutputType = {
    id_tip_ins: number | null
    des_tip_ins: string | null
  }

  export type Tipo_insCountAggregateOutputType = {
    id_tip_ins: number
    des_tip_ins: number
    _all: number
  }


  export type Tipo_insAvgAggregateInputType = {
    id_tip_ins?: true
  }

  export type Tipo_insSumAggregateInputType = {
    id_tip_ins?: true
  }

  export type Tipo_insMinAggregateInputType = {
    id_tip_ins?: true
    des_tip_ins?: true
  }

  export type Tipo_insMaxAggregateInputType = {
    id_tip_ins?: true
    des_tip_ins?: true
  }

  export type Tipo_insCountAggregateInputType = {
    id_tip_ins?: true
    des_tip_ins?: true
    _all?: true
  }

  export type Tipo_insAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipo_ins to aggregate.
     */
    where?: tipo_insWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_ins to fetch.
     */
    orderBy?: tipo_insOrderByWithRelationInput | tipo_insOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tipo_insWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_ins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tipo_ins
    **/
    _count?: true | Tipo_insCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tipo_insAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tipo_insSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tipo_insMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tipo_insMaxAggregateInputType
  }

  export type GetTipo_insAggregateType<T extends Tipo_insAggregateArgs> = {
        [P in keyof T & keyof AggregateTipo_ins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipo_ins[P]>
      : GetScalarType<T[P], AggregateTipo_ins[P]>
  }




  export type tipo_insGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tipo_insWhereInput
    orderBy?: tipo_insOrderByWithAggregationInput | tipo_insOrderByWithAggregationInput[]
    by: Tipo_insScalarFieldEnum[] | Tipo_insScalarFieldEnum
    having?: tipo_insScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tipo_insCountAggregateInputType | true
    _avg?: Tipo_insAvgAggregateInputType
    _sum?: Tipo_insSumAggregateInputType
    _min?: Tipo_insMinAggregateInputType
    _max?: Tipo_insMaxAggregateInputType
  }

  export type Tipo_insGroupByOutputType = {
    id_tip_ins: number
    des_tip_ins: string | null
    _count: Tipo_insCountAggregateOutputType | null
    _avg: Tipo_insAvgAggregateOutputType | null
    _sum: Tipo_insSumAggregateOutputType | null
    _min: Tipo_insMinAggregateOutputType | null
    _max: Tipo_insMaxAggregateOutputType | null
  }

  type GetTipo_insGroupByPayload<T extends tipo_insGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tipo_insGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tipo_insGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tipo_insGroupByOutputType[P]>
            : GetScalarType<T[P], Tipo_insGroupByOutputType[P]>
        }
      >
    >


  export type tipo_insSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tip_ins?: boolean
    des_tip_ins?: boolean
  }, ExtArgs["result"]["tipo_ins"]>


  export type tipo_insSelectScalar = {
    id_tip_ins?: boolean
    des_tip_ins?: boolean
  }


  export type $tipo_insPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tipo_ins"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_tip_ins: number
      des_tip_ins: string | null
    }, ExtArgs["result"]["tipo_ins"]>
    composites: {}
  }

  type tipo_insGetPayload<S extends boolean | null | undefined | tipo_insDefaultArgs> = $Result.GetResult<Prisma.$tipo_insPayload, S>

  type tipo_insCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tipo_insFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tipo_insCountAggregateInputType | true
    }

  export interface tipo_insDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tipo_ins'], meta: { name: 'tipo_ins' } }
    /**
     * Find zero or one Tipo_ins that matches the filter.
     * @param {tipo_insFindUniqueArgs} args - Arguments to find a Tipo_ins
     * @example
     * // Get one Tipo_ins
     * const tipo_ins = await prisma.tipo_ins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tipo_insFindUniqueArgs>(args: SelectSubset<T, tipo_insFindUniqueArgs<ExtArgs>>): Prisma__tipo_insClient<$Result.GetResult<Prisma.$tipo_insPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tipo_ins that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tipo_insFindUniqueOrThrowArgs} args - Arguments to find a Tipo_ins
     * @example
     * // Get one Tipo_ins
     * const tipo_ins = await prisma.tipo_ins.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tipo_insFindUniqueOrThrowArgs>(args: SelectSubset<T, tipo_insFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tipo_insClient<$Result.GetResult<Prisma.$tipo_insPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tipo_ins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_insFindFirstArgs} args - Arguments to find a Tipo_ins
     * @example
     * // Get one Tipo_ins
     * const tipo_ins = await prisma.tipo_ins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tipo_insFindFirstArgs>(args?: SelectSubset<T, tipo_insFindFirstArgs<ExtArgs>>): Prisma__tipo_insClient<$Result.GetResult<Prisma.$tipo_insPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tipo_ins that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_insFindFirstOrThrowArgs} args - Arguments to find a Tipo_ins
     * @example
     * // Get one Tipo_ins
     * const tipo_ins = await prisma.tipo_ins.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tipo_insFindFirstOrThrowArgs>(args?: SelectSubset<T, tipo_insFindFirstOrThrowArgs<ExtArgs>>): Prisma__tipo_insClient<$Result.GetResult<Prisma.$tipo_insPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tipo_ins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_insFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipo_ins
     * const tipo_ins = await prisma.tipo_ins.findMany()
     * 
     * // Get first 10 Tipo_ins
     * const tipo_ins = await prisma.tipo_ins.findMany({ take: 10 })
     * 
     * // Only select the `id_tip_ins`
     * const tipo_insWithId_tip_insOnly = await prisma.tipo_ins.findMany({ select: { id_tip_ins: true } })
     * 
     */
    findMany<T extends tipo_insFindManyArgs>(args?: SelectSubset<T, tipo_insFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipo_insPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tipo_ins.
     * @param {tipo_insCreateArgs} args - Arguments to create a Tipo_ins.
     * @example
     * // Create one Tipo_ins
     * const Tipo_ins = await prisma.tipo_ins.create({
     *   data: {
     *     // ... data to create a Tipo_ins
     *   }
     * })
     * 
     */
    create<T extends tipo_insCreateArgs>(args: SelectSubset<T, tipo_insCreateArgs<ExtArgs>>): Prisma__tipo_insClient<$Result.GetResult<Prisma.$tipo_insPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tipo_ins.
     * @param {tipo_insCreateManyArgs} args - Arguments to create many Tipo_ins.
     * @example
     * // Create many Tipo_ins
     * const tipo_ins = await prisma.tipo_ins.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tipo_insCreateManyArgs>(args?: SelectSubset<T, tipo_insCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tipo_ins.
     * @param {tipo_insDeleteArgs} args - Arguments to delete one Tipo_ins.
     * @example
     * // Delete one Tipo_ins
     * const Tipo_ins = await prisma.tipo_ins.delete({
     *   where: {
     *     // ... filter to delete one Tipo_ins
     *   }
     * })
     * 
     */
    delete<T extends tipo_insDeleteArgs>(args: SelectSubset<T, tipo_insDeleteArgs<ExtArgs>>): Prisma__tipo_insClient<$Result.GetResult<Prisma.$tipo_insPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tipo_ins.
     * @param {tipo_insUpdateArgs} args - Arguments to update one Tipo_ins.
     * @example
     * // Update one Tipo_ins
     * const tipo_ins = await prisma.tipo_ins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tipo_insUpdateArgs>(args: SelectSubset<T, tipo_insUpdateArgs<ExtArgs>>): Prisma__tipo_insClient<$Result.GetResult<Prisma.$tipo_insPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tipo_ins.
     * @param {tipo_insDeleteManyArgs} args - Arguments to filter Tipo_ins to delete.
     * @example
     * // Delete a few Tipo_ins
     * const { count } = await prisma.tipo_ins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tipo_insDeleteManyArgs>(args?: SelectSubset<T, tipo_insDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipo_ins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_insUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipo_ins
     * const tipo_ins = await prisma.tipo_ins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tipo_insUpdateManyArgs>(args: SelectSubset<T, tipo_insUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tipo_ins.
     * @param {tipo_insUpsertArgs} args - Arguments to update or create a Tipo_ins.
     * @example
     * // Update or create a Tipo_ins
     * const tipo_ins = await prisma.tipo_ins.upsert({
     *   create: {
     *     // ... data to create a Tipo_ins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipo_ins we want to update
     *   }
     * })
     */
    upsert<T extends tipo_insUpsertArgs>(args: SelectSubset<T, tipo_insUpsertArgs<ExtArgs>>): Prisma__tipo_insClient<$Result.GetResult<Prisma.$tipo_insPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tipo_ins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_insCountArgs} args - Arguments to filter Tipo_ins to count.
     * @example
     * // Count the number of Tipo_ins
     * const count = await prisma.tipo_ins.count({
     *   where: {
     *     // ... the filter for the Tipo_ins we want to count
     *   }
     * })
    **/
    count<T extends tipo_insCountArgs>(
      args?: Subset<T, tipo_insCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tipo_insCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipo_ins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_insAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tipo_insAggregateArgs>(args: Subset<T, Tipo_insAggregateArgs>): Prisma.PrismaPromise<GetTipo_insAggregateType<T>>

    /**
     * Group by Tipo_ins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_insGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tipo_insGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tipo_insGroupByArgs['orderBy'] }
        : { orderBy?: tipo_insGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tipo_insGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipo_insGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tipo_ins model
   */
  readonly fields: tipo_insFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tipo_ins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tipo_insClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tipo_ins model
   */ 
  interface tipo_insFieldRefs {
    readonly id_tip_ins: FieldRef<"tipo_ins", 'Int'>
    readonly des_tip_ins: FieldRef<"tipo_ins", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tipo_ins findUnique
   */
  export type tipo_insFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_ins
     */
    select?: tipo_insSelect<ExtArgs> | null
    /**
     * Filter, which tipo_ins to fetch.
     */
    where: tipo_insWhereUniqueInput
  }

  /**
   * tipo_ins findUniqueOrThrow
   */
  export type tipo_insFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_ins
     */
    select?: tipo_insSelect<ExtArgs> | null
    /**
     * Filter, which tipo_ins to fetch.
     */
    where: tipo_insWhereUniqueInput
  }

  /**
   * tipo_ins findFirst
   */
  export type tipo_insFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_ins
     */
    select?: tipo_insSelect<ExtArgs> | null
    /**
     * Filter, which tipo_ins to fetch.
     */
    where?: tipo_insWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_ins to fetch.
     */
    orderBy?: tipo_insOrderByWithRelationInput | tipo_insOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipo_ins.
     */
    cursor?: tipo_insWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_ins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipo_ins.
     */
    distinct?: Tipo_insScalarFieldEnum | Tipo_insScalarFieldEnum[]
  }

  /**
   * tipo_ins findFirstOrThrow
   */
  export type tipo_insFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_ins
     */
    select?: tipo_insSelect<ExtArgs> | null
    /**
     * Filter, which tipo_ins to fetch.
     */
    where?: tipo_insWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_ins to fetch.
     */
    orderBy?: tipo_insOrderByWithRelationInput | tipo_insOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipo_ins.
     */
    cursor?: tipo_insWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_ins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipo_ins.
     */
    distinct?: Tipo_insScalarFieldEnum | Tipo_insScalarFieldEnum[]
  }

  /**
   * tipo_ins findMany
   */
  export type tipo_insFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_ins
     */
    select?: tipo_insSelect<ExtArgs> | null
    /**
     * Filter, which tipo_ins to fetch.
     */
    where?: tipo_insWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_ins to fetch.
     */
    orderBy?: tipo_insOrderByWithRelationInput | tipo_insOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tipo_ins.
     */
    cursor?: tipo_insWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_ins.
     */
    skip?: number
    distinct?: Tipo_insScalarFieldEnum | Tipo_insScalarFieldEnum[]
  }

  /**
   * tipo_ins create
   */
  export type tipo_insCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_ins
     */
    select?: tipo_insSelect<ExtArgs> | null
    /**
     * The data needed to create a tipo_ins.
     */
    data?: XOR<tipo_insCreateInput, tipo_insUncheckedCreateInput>
  }

  /**
   * tipo_ins createMany
   */
  export type tipo_insCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tipo_ins.
     */
    data: tipo_insCreateManyInput | tipo_insCreateManyInput[]
  }

  /**
   * tipo_ins update
   */
  export type tipo_insUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_ins
     */
    select?: tipo_insSelect<ExtArgs> | null
    /**
     * The data needed to update a tipo_ins.
     */
    data: XOR<tipo_insUpdateInput, tipo_insUncheckedUpdateInput>
    /**
     * Choose, which tipo_ins to update.
     */
    where: tipo_insWhereUniqueInput
  }

  /**
   * tipo_ins updateMany
   */
  export type tipo_insUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tipo_ins.
     */
    data: XOR<tipo_insUpdateManyMutationInput, tipo_insUncheckedUpdateManyInput>
    /**
     * Filter which tipo_ins to update
     */
    where?: tipo_insWhereInput
  }

  /**
   * tipo_ins upsert
   */
  export type tipo_insUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_ins
     */
    select?: tipo_insSelect<ExtArgs> | null
    /**
     * The filter to search for the tipo_ins to update in case it exists.
     */
    where: tipo_insWhereUniqueInput
    /**
     * In case the tipo_ins found by the `where` argument doesn't exist, create a new tipo_ins with this data.
     */
    create: XOR<tipo_insCreateInput, tipo_insUncheckedCreateInput>
    /**
     * In case the tipo_ins was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipo_insUpdateInput, tipo_insUncheckedUpdateInput>
  }

  /**
   * tipo_ins delete
   */
  export type tipo_insDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_ins
     */
    select?: tipo_insSelect<ExtArgs> | null
    /**
     * Filter which tipo_ins to delete.
     */
    where: tipo_insWhereUniqueInput
  }

  /**
   * tipo_ins deleteMany
   */
  export type tipo_insDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipo_ins to delete
     */
    where?: tipo_insWhereInput
  }

  /**
   * tipo_ins without action
   */
  export type tipo_insDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_ins
     */
    select?: tipo_insSelect<ExtArgs> | null
  }


  /**
   * Model traductor_calibre
   */

  export type AggregateTraductor_calibre = {
    _count: Traductor_calibreCountAggregateOutputType | null
    _avg: Traductor_calibreAvgAggregateOutputType | null
    _sum: Traductor_calibreSumAggregateOutputType | null
    _min: Traductor_calibreMinAggregateOutputType | null
    _max: Traductor_calibreMaxAggregateOutputType | null
  }

  export type Traductor_calibreAvgAggregateOutputType = {
    id: number | null
    val_calibre: number | null
  }

  export type Traductor_calibreSumAggregateOutputType = {
    id: number | null
    val_calibre: number | null
  }

  export type Traductor_calibreMinAggregateOutputType = {
    id: number | null
    n_calibre_std: string | null
    val_calibre: number | null
    cod_exp: string | null
    n_calibre: string | null
  }

  export type Traductor_calibreMaxAggregateOutputType = {
    id: number | null
    n_calibre_std: string | null
    val_calibre: number | null
    cod_exp: string | null
    n_calibre: string | null
  }

  export type Traductor_calibreCountAggregateOutputType = {
    id: number
    n_calibre_std: number
    val_calibre: number
    cod_exp: number
    n_calibre: number
    _all: number
  }


  export type Traductor_calibreAvgAggregateInputType = {
    id?: true
    val_calibre?: true
  }

  export type Traductor_calibreSumAggregateInputType = {
    id?: true
    val_calibre?: true
  }

  export type Traductor_calibreMinAggregateInputType = {
    id?: true
    n_calibre_std?: true
    val_calibre?: true
    cod_exp?: true
    n_calibre?: true
  }

  export type Traductor_calibreMaxAggregateInputType = {
    id?: true
    n_calibre_std?: true
    val_calibre?: true
    cod_exp?: true
    n_calibre?: true
  }

  export type Traductor_calibreCountAggregateInputType = {
    id?: true
    n_calibre_std?: true
    val_calibre?: true
    cod_exp?: true
    n_calibre?: true
    _all?: true
  }

  export type Traductor_calibreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which traductor_calibre to aggregate.
     */
    where?: traductor_calibreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of traductor_calibres to fetch.
     */
    orderBy?: traductor_calibreOrderByWithRelationInput | traductor_calibreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: traductor_calibreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` traductor_calibres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` traductor_calibres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned traductor_calibres
    **/
    _count?: true | Traductor_calibreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Traductor_calibreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Traductor_calibreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Traductor_calibreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Traductor_calibreMaxAggregateInputType
  }

  export type GetTraductor_calibreAggregateType<T extends Traductor_calibreAggregateArgs> = {
        [P in keyof T & keyof AggregateTraductor_calibre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTraductor_calibre[P]>
      : GetScalarType<T[P], AggregateTraductor_calibre[P]>
  }




  export type traductor_calibreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: traductor_calibreWhereInput
    orderBy?: traductor_calibreOrderByWithAggregationInput | traductor_calibreOrderByWithAggregationInput[]
    by: Traductor_calibreScalarFieldEnum[] | Traductor_calibreScalarFieldEnum
    having?: traductor_calibreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Traductor_calibreCountAggregateInputType | true
    _avg?: Traductor_calibreAvgAggregateInputType
    _sum?: Traductor_calibreSumAggregateInputType
    _min?: Traductor_calibreMinAggregateInputType
    _max?: Traductor_calibreMaxAggregateInputType
  }

  export type Traductor_calibreGroupByOutputType = {
    id: number
    n_calibre_std: string | null
    val_calibre: number | null
    cod_exp: string | null
    n_calibre: string | null
    _count: Traductor_calibreCountAggregateOutputType | null
    _avg: Traductor_calibreAvgAggregateOutputType | null
    _sum: Traductor_calibreSumAggregateOutputType | null
    _min: Traductor_calibreMinAggregateOutputType | null
    _max: Traductor_calibreMaxAggregateOutputType | null
  }

  type GetTraductor_calibreGroupByPayload<T extends traductor_calibreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Traductor_calibreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Traductor_calibreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Traductor_calibreGroupByOutputType[P]>
            : GetScalarType<T[P], Traductor_calibreGroupByOutputType[P]>
        }
      >
    >


  export type traductor_calibreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    n_calibre_std?: boolean
    val_calibre?: boolean
    cod_exp?: boolean
    n_calibre?: boolean
  }, ExtArgs["result"]["traductor_calibre"]>


  export type traductor_calibreSelectScalar = {
    id?: boolean
    n_calibre_std?: boolean
    val_calibre?: boolean
    cod_exp?: boolean
    n_calibre?: boolean
  }


  export type $traductor_calibrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "traductor_calibre"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      n_calibre_std: string | null
      val_calibre: number | null
      cod_exp: string | null
      n_calibre: string | null
    }, ExtArgs["result"]["traductor_calibre"]>
    composites: {}
  }

  type traductor_calibreGetPayload<S extends boolean | null | undefined | traductor_calibreDefaultArgs> = $Result.GetResult<Prisma.$traductor_calibrePayload, S>

  type traductor_calibreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<traductor_calibreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Traductor_calibreCountAggregateInputType | true
    }

  export interface traductor_calibreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['traductor_calibre'], meta: { name: 'traductor_calibre' } }
    /**
     * Find zero or one Traductor_calibre that matches the filter.
     * @param {traductor_calibreFindUniqueArgs} args - Arguments to find a Traductor_calibre
     * @example
     * // Get one Traductor_calibre
     * const traductor_calibre = await prisma.traductor_calibre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends traductor_calibreFindUniqueArgs>(args: SelectSubset<T, traductor_calibreFindUniqueArgs<ExtArgs>>): Prisma__traductor_calibreClient<$Result.GetResult<Prisma.$traductor_calibrePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Traductor_calibre that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {traductor_calibreFindUniqueOrThrowArgs} args - Arguments to find a Traductor_calibre
     * @example
     * // Get one Traductor_calibre
     * const traductor_calibre = await prisma.traductor_calibre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends traductor_calibreFindUniqueOrThrowArgs>(args: SelectSubset<T, traductor_calibreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__traductor_calibreClient<$Result.GetResult<Prisma.$traductor_calibrePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Traductor_calibre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {traductor_calibreFindFirstArgs} args - Arguments to find a Traductor_calibre
     * @example
     * // Get one Traductor_calibre
     * const traductor_calibre = await prisma.traductor_calibre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends traductor_calibreFindFirstArgs>(args?: SelectSubset<T, traductor_calibreFindFirstArgs<ExtArgs>>): Prisma__traductor_calibreClient<$Result.GetResult<Prisma.$traductor_calibrePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Traductor_calibre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {traductor_calibreFindFirstOrThrowArgs} args - Arguments to find a Traductor_calibre
     * @example
     * // Get one Traductor_calibre
     * const traductor_calibre = await prisma.traductor_calibre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends traductor_calibreFindFirstOrThrowArgs>(args?: SelectSubset<T, traductor_calibreFindFirstOrThrowArgs<ExtArgs>>): Prisma__traductor_calibreClient<$Result.GetResult<Prisma.$traductor_calibrePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Traductor_calibres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {traductor_calibreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Traductor_calibres
     * const traductor_calibres = await prisma.traductor_calibre.findMany()
     * 
     * // Get first 10 Traductor_calibres
     * const traductor_calibres = await prisma.traductor_calibre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const traductor_calibreWithIdOnly = await prisma.traductor_calibre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends traductor_calibreFindManyArgs>(args?: SelectSubset<T, traductor_calibreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$traductor_calibrePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Traductor_calibre.
     * @param {traductor_calibreCreateArgs} args - Arguments to create a Traductor_calibre.
     * @example
     * // Create one Traductor_calibre
     * const Traductor_calibre = await prisma.traductor_calibre.create({
     *   data: {
     *     // ... data to create a Traductor_calibre
     *   }
     * })
     * 
     */
    create<T extends traductor_calibreCreateArgs>(args: SelectSubset<T, traductor_calibreCreateArgs<ExtArgs>>): Prisma__traductor_calibreClient<$Result.GetResult<Prisma.$traductor_calibrePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Traductor_calibres.
     * @param {traductor_calibreCreateManyArgs} args - Arguments to create many Traductor_calibres.
     * @example
     * // Create many Traductor_calibres
     * const traductor_calibre = await prisma.traductor_calibre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends traductor_calibreCreateManyArgs>(args?: SelectSubset<T, traductor_calibreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Traductor_calibre.
     * @param {traductor_calibreDeleteArgs} args - Arguments to delete one Traductor_calibre.
     * @example
     * // Delete one Traductor_calibre
     * const Traductor_calibre = await prisma.traductor_calibre.delete({
     *   where: {
     *     // ... filter to delete one Traductor_calibre
     *   }
     * })
     * 
     */
    delete<T extends traductor_calibreDeleteArgs>(args: SelectSubset<T, traductor_calibreDeleteArgs<ExtArgs>>): Prisma__traductor_calibreClient<$Result.GetResult<Prisma.$traductor_calibrePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Traductor_calibre.
     * @param {traductor_calibreUpdateArgs} args - Arguments to update one Traductor_calibre.
     * @example
     * // Update one Traductor_calibre
     * const traductor_calibre = await prisma.traductor_calibre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends traductor_calibreUpdateArgs>(args: SelectSubset<T, traductor_calibreUpdateArgs<ExtArgs>>): Prisma__traductor_calibreClient<$Result.GetResult<Prisma.$traductor_calibrePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Traductor_calibres.
     * @param {traductor_calibreDeleteManyArgs} args - Arguments to filter Traductor_calibres to delete.
     * @example
     * // Delete a few Traductor_calibres
     * const { count } = await prisma.traductor_calibre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends traductor_calibreDeleteManyArgs>(args?: SelectSubset<T, traductor_calibreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Traductor_calibres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {traductor_calibreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Traductor_calibres
     * const traductor_calibre = await prisma.traductor_calibre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends traductor_calibreUpdateManyArgs>(args: SelectSubset<T, traductor_calibreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Traductor_calibre.
     * @param {traductor_calibreUpsertArgs} args - Arguments to update or create a Traductor_calibre.
     * @example
     * // Update or create a Traductor_calibre
     * const traductor_calibre = await prisma.traductor_calibre.upsert({
     *   create: {
     *     // ... data to create a Traductor_calibre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Traductor_calibre we want to update
     *   }
     * })
     */
    upsert<T extends traductor_calibreUpsertArgs>(args: SelectSubset<T, traductor_calibreUpsertArgs<ExtArgs>>): Prisma__traductor_calibreClient<$Result.GetResult<Prisma.$traductor_calibrePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Traductor_calibres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {traductor_calibreCountArgs} args - Arguments to filter Traductor_calibres to count.
     * @example
     * // Count the number of Traductor_calibres
     * const count = await prisma.traductor_calibre.count({
     *   where: {
     *     // ... the filter for the Traductor_calibres we want to count
     *   }
     * })
    **/
    count<T extends traductor_calibreCountArgs>(
      args?: Subset<T, traductor_calibreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Traductor_calibreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Traductor_calibre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Traductor_calibreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Traductor_calibreAggregateArgs>(args: Subset<T, Traductor_calibreAggregateArgs>): Prisma.PrismaPromise<GetTraductor_calibreAggregateType<T>>

    /**
     * Group by Traductor_calibre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {traductor_calibreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends traductor_calibreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: traductor_calibreGroupByArgs['orderBy'] }
        : { orderBy?: traductor_calibreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, traductor_calibreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTraductor_calibreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the traductor_calibre model
   */
  readonly fields: traductor_calibreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for traductor_calibre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__traductor_calibreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the traductor_calibre model
   */ 
  interface traductor_calibreFieldRefs {
    readonly id: FieldRef<"traductor_calibre", 'Int'>
    readonly n_calibre_std: FieldRef<"traductor_calibre", 'String'>
    readonly val_calibre: FieldRef<"traductor_calibre", 'Int'>
    readonly cod_exp: FieldRef<"traductor_calibre", 'String'>
    readonly n_calibre: FieldRef<"traductor_calibre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * traductor_calibre findUnique
   */
  export type traductor_calibreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the traductor_calibre
     */
    select?: traductor_calibreSelect<ExtArgs> | null
    /**
     * Filter, which traductor_calibre to fetch.
     */
    where: traductor_calibreWhereUniqueInput
  }

  /**
   * traductor_calibre findUniqueOrThrow
   */
  export type traductor_calibreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the traductor_calibre
     */
    select?: traductor_calibreSelect<ExtArgs> | null
    /**
     * Filter, which traductor_calibre to fetch.
     */
    where: traductor_calibreWhereUniqueInput
  }

  /**
   * traductor_calibre findFirst
   */
  export type traductor_calibreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the traductor_calibre
     */
    select?: traductor_calibreSelect<ExtArgs> | null
    /**
     * Filter, which traductor_calibre to fetch.
     */
    where?: traductor_calibreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of traductor_calibres to fetch.
     */
    orderBy?: traductor_calibreOrderByWithRelationInput | traductor_calibreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for traductor_calibres.
     */
    cursor?: traductor_calibreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` traductor_calibres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` traductor_calibres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of traductor_calibres.
     */
    distinct?: Traductor_calibreScalarFieldEnum | Traductor_calibreScalarFieldEnum[]
  }

  /**
   * traductor_calibre findFirstOrThrow
   */
  export type traductor_calibreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the traductor_calibre
     */
    select?: traductor_calibreSelect<ExtArgs> | null
    /**
     * Filter, which traductor_calibre to fetch.
     */
    where?: traductor_calibreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of traductor_calibres to fetch.
     */
    orderBy?: traductor_calibreOrderByWithRelationInput | traductor_calibreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for traductor_calibres.
     */
    cursor?: traductor_calibreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` traductor_calibres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` traductor_calibres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of traductor_calibres.
     */
    distinct?: Traductor_calibreScalarFieldEnum | Traductor_calibreScalarFieldEnum[]
  }

  /**
   * traductor_calibre findMany
   */
  export type traductor_calibreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the traductor_calibre
     */
    select?: traductor_calibreSelect<ExtArgs> | null
    /**
     * Filter, which traductor_calibres to fetch.
     */
    where?: traductor_calibreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of traductor_calibres to fetch.
     */
    orderBy?: traductor_calibreOrderByWithRelationInput | traductor_calibreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing traductor_calibres.
     */
    cursor?: traductor_calibreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` traductor_calibres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` traductor_calibres.
     */
    skip?: number
    distinct?: Traductor_calibreScalarFieldEnum | Traductor_calibreScalarFieldEnum[]
  }

  /**
   * traductor_calibre create
   */
  export type traductor_calibreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the traductor_calibre
     */
    select?: traductor_calibreSelect<ExtArgs> | null
    /**
     * The data needed to create a traductor_calibre.
     */
    data?: XOR<traductor_calibreCreateInput, traductor_calibreUncheckedCreateInput>
  }

  /**
   * traductor_calibre createMany
   */
  export type traductor_calibreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many traductor_calibres.
     */
    data: traductor_calibreCreateManyInput | traductor_calibreCreateManyInput[]
  }

  /**
   * traductor_calibre update
   */
  export type traductor_calibreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the traductor_calibre
     */
    select?: traductor_calibreSelect<ExtArgs> | null
    /**
     * The data needed to update a traductor_calibre.
     */
    data: XOR<traductor_calibreUpdateInput, traductor_calibreUncheckedUpdateInput>
    /**
     * Choose, which traductor_calibre to update.
     */
    where: traductor_calibreWhereUniqueInput
  }

  /**
   * traductor_calibre updateMany
   */
  export type traductor_calibreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update traductor_calibres.
     */
    data: XOR<traductor_calibreUpdateManyMutationInput, traductor_calibreUncheckedUpdateManyInput>
    /**
     * Filter which traductor_calibres to update
     */
    where?: traductor_calibreWhereInput
  }

  /**
   * traductor_calibre upsert
   */
  export type traductor_calibreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the traductor_calibre
     */
    select?: traductor_calibreSelect<ExtArgs> | null
    /**
     * The filter to search for the traductor_calibre to update in case it exists.
     */
    where: traductor_calibreWhereUniqueInput
    /**
     * In case the traductor_calibre found by the `where` argument doesn't exist, create a new traductor_calibre with this data.
     */
    create: XOR<traductor_calibreCreateInput, traductor_calibreUncheckedCreateInput>
    /**
     * In case the traductor_calibre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<traductor_calibreUpdateInput, traductor_calibreUncheckedUpdateInput>
  }

  /**
   * traductor_calibre delete
   */
  export type traductor_calibreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the traductor_calibre
     */
    select?: traductor_calibreSelect<ExtArgs> | null
    /**
     * Filter which traductor_calibre to delete.
     */
    where: traductor_calibreWhereUniqueInput
  }

  /**
   * traductor_calibre deleteMany
   */
  export type traductor_calibreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which traductor_calibres to delete
     */
    where?: traductor_calibreWhereInput
  }

  /**
   * traductor_calibre without action
   */
  export type traductor_calibreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the traductor_calibre
     */
    select?: traductor_calibreSelect<ExtArgs> | null
  }


  /**
   * Model validacion_pallets
   */

  export type AggregateValidacion_pallets = {
    _count: Validacion_palletsCountAggregateOutputType | null
    _avg: Validacion_palletsAvgAggregateOutputType | null
    _sum: Validacion_palletsSumAggregateOutputType | null
    _min: Validacion_palletsMinAggregateOutputType | null
    _max: Validacion_palletsMaxAggregateOutputType | null
  }

  export type Validacion_palletsAvgAggregateOutputType = {
    id: number | null
    temporada: number | null
  }

  export type Validacion_palletsSumAggregateOutputType = {
    id: number | null
    temporada: number | null
  }

  export type Validacion_palletsMinAggregateOutputType = {
    id: number | null
    numero_pallet: string | null
    temporada: number | null
  }

  export type Validacion_palletsMaxAggregateOutputType = {
    id: number | null
    numero_pallet: string | null
    temporada: number | null
  }

  export type Validacion_palletsCountAggregateOutputType = {
    id: number
    numero_pallet: number
    temporada: number
    _all: number
  }


  export type Validacion_palletsAvgAggregateInputType = {
    id?: true
    temporada?: true
  }

  export type Validacion_palletsSumAggregateInputType = {
    id?: true
    temporada?: true
  }

  export type Validacion_palletsMinAggregateInputType = {
    id?: true
    numero_pallet?: true
    temporada?: true
  }

  export type Validacion_palletsMaxAggregateInputType = {
    id?: true
    numero_pallet?: true
    temporada?: true
  }

  export type Validacion_palletsCountAggregateInputType = {
    id?: true
    numero_pallet?: true
    temporada?: true
    _all?: true
  }

  export type Validacion_palletsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which validacion_pallets to aggregate.
     */
    where?: validacion_palletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of validacion_pallets to fetch.
     */
    orderBy?: validacion_palletsOrderByWithRelationInput | validacion_palletsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: validacion_palletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` validacion_pallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` validacion_pallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned validacion_pallets
    **/
    _count?: true | Validacion_palletsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Validacion_palletsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Validacion_palletsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Validacion_palletsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Validacion_palletsMaxAggregateInputType
  }

  export type GetValidacion_palletsAggregateType<T extends Validacion_palletsAggregateArgs> = {
        [P in keyof T & keyof AggregateValidacion_pallets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateValidacion_pallets[P]>
      : GetScalarType<T[P], AggregateValidacion_pallets[P]>
  }




  export type validacion_palletsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: validacion_palletsWhereInput
    orderBy?: validacion_palletsOrderByWithAggregationInput | validacion_palletsOrderByWithAggregationInput[]
    by: Validacion_palletsScalarFieldEnum[] | Validacion_palletsScalarFieldEnum
    having?: validacion_palletsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Validacion_palletsCountAggregateInputType | true
    _avg?: Validacion_palletsAvgAggregateInputType
    _sum?: Validacion_palletsSumAggregateInputType
    _min?: Validacion_palletsMinAggregateInputType
    _max?: Validacion_palletsMaxAggregateInputType
  }

  export type Validacion_palletsGroupByOutputType = {
    id: number
    numero_pallet: string | null
    temporada: number | null
    _count: Validacion_palletsCountAggregateOutputType | null
    _avg: Validacion_palletsAvgAggregateOutputType | null
    _sum: Validacion_palletsSumAggregateOutputType | null
    _min: Validacion_palletsMinAggregateOutputType | null
    _max: Validacion_palletsMaxAggregateOutputType | null
  }

  type GetValidacion_palletsGroupByPayload<T extends validacion_palletsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Validacion_palletsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Validacion_palletsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Validacion_palletsGroupByOutputType[P]>
            : GetScalarType<T[P], Validacion_palletsGroupByOutputType[P]>
        }
      >
    >


  export type validacion_palletsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numero_pallet?: boolean
    temporada?: boolean
  }, ExtArgs["result"]["validacion_pallets"]>


  export type validacion_palletsSelectScalar = {
    id?: boolean
    numero_pallet?: boolean
    temporada?: boolean
  }


  export type $validacion_palletsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "validacion_pallets"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      numero_pallet: string | null
      temporada: number | null
    }, ExtArgs["result"]["validacion_pallets"]>
    composites: {}
  }

  type validacion_palletsGetPayload<S extends boolean | null | undefined | validacion_palletsDefaultArgs> = $Result.GetResult<Prisma.$validacion_palletsPayload, S>

  type validacion_palletsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<validacion_palletsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Validacion_palletsCountAggregateInputType | true
    }

  export interface validacion_palletsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['validacion_pallets'], meta: { name: 'validacion_pallets' } }
    /**
     * Find zero or one Validacion_pallets that matches the filter.
     * @param {validacion_palletsFindUniqueArgs} args - Arguments to find a Validacion_pallets
     * @example
     * // Get one Validacion_pallets
     * const validacion_pallets = await prisma.validacion_pallets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends validacion_palletsFindUniqueArgs>(args: SelectSubset<T, validacion_palletsFindUniqueArgs<ExtArgs>>): Prisma__validacion_palletsClient<$Result.GetResult<Prisma.$validacion_palletsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Validacion_pallets that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {validacion_palletsFindUniqueOrThrowArgs} args - Arguments to find a Validacion_pallets
     * @example
     * // Get one Validacion_pallets
     * const validacion_pallets = await prisma.validacion_pallets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends validacion_palletsFindUniqueOrThrowArgs>(args: SelectSubset<T, validacion_palletsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__validacion_palletsClient<$Result.GetResult<Prisma.$validacion_palletsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Validacion_pallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {validacion_palletsFindFirstArgs} args - Arguments to find a Validacion_pallets
     * @example
     * // Get one Validacion_pallets
     * const validacion_pallets = await prisma.validacion_pallets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends validacion_palletsFindFirstArgs>(args?: SelectSubset<T, validacion_palletsFindFirstArgs<ExtArgs>>): Prisma__validacion_palletsClient<$Result.GetResult<Prisma.$validacion_palletsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Validacion_pallets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {validacion_palletsFindFirstOrThrowArgs} args - Arguments to find a Validacion_pallets
     * @example
     * // Get one Validacion_pallets
     * const validacion_pallets = await prisma.validacion_pallets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends validacion_palletsFindFirstOrThrowArgs>(args?: SelectSubset<T, validacion_palletsFindFirstOrThrowArgs<ExtArgs>>): Prisma__validacion_palletsClient<$Result.GetResult<Prisma.$validacion_palletsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Validacion_pallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {validacion_palletsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Validacion_pallets
     * const validacion_pallets = await prisma.validacion_pallets.findMany()
     * 
     * // Get first 10 Validacion_pallets
     * const validacion_pallets = await prisma.validacion_pallets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const validacion_palletsWithIdOnly = await prisma.validacion_pallets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends validacion_palletsFindManyArgs>(args?: SelectSubset<T, validacion_palletsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$validacion_palletsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Validacion_pallets.
     * @param {validacion_palletsCreateArgs} args - Arguments to create a Validacion_pallets.
     * @example
     * // Create one Validacion_pallets
     * const Validacion_pallets = await prisma.validacion_pallets.create({
     *   data: {
     *     // ... data to create a Validacion_pallets
     *   }
     * })
     * 
     */
    create<T extends validacion_palletsCreateArgs>(args: SelectSubset<T, validacion_palletsCreateArgs<ExtArgs>>): Prisma__validacion_palletsClient<$Result.GetResult<Prisma.$validacion_palletsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Validacion_pallets.
     * @param {validacion_palletsCreateManyArgs} args - Arguments to create many Validacion_pallets.
     * @example
     * // Create many Validacion_pallets
     * const validacion_pallets = await prisma.validacion_pallets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends validacion_palletsCreateManyArgs>(args?: SelectSubset<T, validacion_palletsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Validacion_pallets.
     * @param {validacion_palletsDeleteArgs} args - Arguments to delete one Validacion_pallets.
     * @example
     * // Delete one Validacion_pallets
     * const Validacion_pallets = await prisma.validacion_pallets.delete({
     *   where: {
     *     // ... filter to delete one Validacion_pallets
     *   }
     * })
     * 
     */
    delete<T extends validacion_palletsDeleteArgs>(args: SelectSubset<T, validacion_palletsDeleteArgs<ExtArgs>>): Prisma__validacion_palletsClient<$Result.GetResult<Prisma.$validacion_palletsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Validacion_pallets.
     * @param {validacion_palletsUpdateArgs} args - Arguments to update one Validacion_pallets.
     * @example
     * // Update one Validacion_pallets
     * const validacion_pallets = await prisma.validacion_pallets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends validacion_palletsUpdateArgs>(args: SelectSubset<T, validacion_palletsUpdateArgs<ExtArgs>>): Prisma__validacion_palletsClient<$Result.GetResult<Prisma.$validacion_palletsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Validacion_pallets.
     * @param {validacion_palletsDeleteManyArgs} args - Arguments to filter Validacion_pallets to delete.
     * @example
     * // Delete a few Validacion_pallets
     * const { count } = await prisma.validacion_pallets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends validacion_palletsDeleteManyArgs>(args?: SelectSubset<T, validacion_palletsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Validacion_pallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {validacion_palletsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Validacion_pallets
     * const validacion_pallets = await prisma.validacion_pallets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends validacion_palletsUpdateManyArgs>(args: SelectSubset<T, validacion_palletsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Validacion_pallets.
     * @param {validacion_palletsUpsertArgs} args - Arguments to update or create a Validacion_pallets.
     * @example
     * // Update or create a Validacion_pallets
     * const validacion_pallets = await prisma.validacion_pallets.upsert({
     *   create: {
     *     // ... data to create a Validacion_pallets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Validacion_pallets we want to update
     *   }
     * })
     */
    upsert<T extends validacion_palletsUpsertArgs>(args: SelectSubset<T, validacion_palletsUpsertArgs<ExtArgs>>): Prisma__validacion_palletsClient<$Result.GetResult<Prisma.$validacion_palletsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Validacion_pallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {validacion_palletsCountArgs} args - Arguments to filter Validacion_pallets to count.
     * @example
     * // Count the number of Validacion_pallets
     * const count = await prisma.validacion_pallets.count({
     *   where: {
     *     // ... the filter for the Validacion_pallets we want to count
     *   }
     * })
    **/
    count<T extends validacion_palletsCountArgs>(
      args?: Subset<T, validacion_palletsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Validacion_palletsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Validacion_pallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Validacion_palletsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Validacion_palletsAggregateArgs>(args: Subset<T, Validacion_palletsAggregateArgs>): Prisma.PrismaPromise<GetValidacion_palletsAggregateType<T>>

    /**
     * Group by Validacion_pallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {validacion_palletsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends validacion_palletsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: validacion_palletsGroupByArgs['orderBy'] }
        : { orderBy?: validacion_palletsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, validacion_palletsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetValidacion_palletsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the validacion_pallets model
   */
  readonly fields: validacion_palletsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for validacion_pallets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__validacion_palletsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the validacion_pallets model
   */ 
  interface validacion_palletsFieldRefs {
    readonly id: FieldRef<"validacion_pallets", 'Int'>
    readonly numero_pallet: FieldRef<"validacion_pallets", 'String'>
    readonly temporada: FieldRef<"validacion_pallets", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * validacion_pallets findUnique
   */
  export type validacion_palletsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validacion_pallets
     */
    select?: validacion_palletsSelect<ExtArgs> | null
    /**
     * Filter, which validacion_pallets to fetch.
     */
    where: validacion_palletsWhereUniqueInput
  }

  /**
   * validacion_pallets findUniqueOrThrow
   */
  export type validacion_palletsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validacion_pallets
     */
    select?: validacion_palletsSelect<ExtArgs> | null
    /**
     * Filter, which validacion_pallets to fetch.
     */
    where: validacion_palletsWhereUniqueInput
  }

  /**
   * validacion_pallets findFirst
   */
  export type validacion_palletsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validacion_pallets
     */
    select?: validacion_palletsSelect<ExtArgs> | null
    /**
     * Filter, which validacion_pallets to fetch.
     */
    where?: validacion_palletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of validacion_pallets to fetch.
     */
    orderBy?: validacion_palletsOrderByWithRelationInput | validacion_palletsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for validacion_pallets.
     */
    cursor?: validacion_palletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` validacion_pallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` validacion_pallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of validacion_pallets.
     */
    distinct?: Validacion_palletsScalarFieldEnum | Validacion_palletsScalarFieldEnum[]
  }

  /**
   * validacion_pallets findFirstOrThrow
   */
  export type validacion_palletsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validacion_pallets
     */
    select?: validacion_palletsSelect<ExtArgs> | null
    /**
     * Filter, which validacion_pallets to fetch.
     */
    where?: validacion_palletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of validacion_pallets to fetch.
     */
    orderBy?: validacion_palletsOrderByWithRelationInput | validacion_palletsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for validacion_pallets.
     */
    cursor?: validacion_palletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` validacion_pallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` validacion_pallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of validacion_pallets.
     */
    distinct?: Validacion_palletsScalarFieldEnum | Validacion_palletsScalarFieldEnum[]
  }

  /**
   * validacion_pallets findMany
   */
  export type validacion_palletsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validacion_pallets
     */
    select?: validacion_palletsSelect<ExtArgs> | null
    /**
     * Filter, which validacion_pallets to fetch.
     */
    where?: validacion_palletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of validacion_pallets to fetch.
     */
    orderBy?: validacion_palletsOrderByWithRelationInput | validacion_palletsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing validacion_pallets.
     */
    cursor?: validacion_palletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` validacion_pallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` validacion_pallets.
     */
    skip?: number
    distinct?: Validacion_palletsScalarFieldEnum | Validacion_palletsScalarFieldEnum[]
  }

  /**
   * validacion_pallets create
   */
  export type validacion_palletsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validacion_pallets
     */
    select?: validacion_palletsSelect<ExtArgs> | null
    /**
     * The data needed to create a validacion_pallets.
     */
    data?: XOR<validacion_palletsCreateInput, validacion_palletsUncheckedCreateInput>
  }

  /**
   * validacion_pallets createMany
   */
  export type validacion_palletsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many validacion_pallets.
     */
    data: validacion_palletsCreateManyInput | validacion_palletsCreateManyInput[]
  }

  /**
   * validacion_pallets update
   */
  export type validacion_palletsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validacion_pallets
     */
    select?: validacion_palletsSelect<ExtArgs> | null
    /**
     * The data needed to update a validacion_pallets.
     */
    data: XOR<validacion_palletsUpdateInput, validacion_palletsUncheckedUpdateInput>
    /**
     * Choose, which validacion_pallets to update.
     */
    where: validacion_palletsWhereUniqueInput
  }

  /**
   * validacion_pallets updateMany
   */
  export type validacion_palletsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update validacion_pallets.
     */
    data: XOR<validacion_palletsUpdateManyMutationInput, validacion_palletsUncheckedUpdateManyInput>
    /**
     * Filter which validacion_pallets to update
     */
    where?: validacion_palletsWhereInput
  }

  /**
   * validacion_pallets upsert
   */
  export type validacion_palletsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validacion_pallets
     */
    select?: validacion_palletsSelect<ExtArgs> | null
    /**
     * The filter to search for the validacion_pallets to update in case it exists.
     */
    where: validacion_palletsWhereUniqueInput
    /**
     * In case the validacion_pallets found by the `where` argument doesn't exist, create a new validacion_pallets with this data.
     */
    create: XOR<validacion_palletsCreateInput, validacion_palletsUncheckedCreateInput>
    /**
     * In case the validacion_pallets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<validacion_palletsUpdateInput, validacion_palletsUncheckedUpdateInput>
  }

  /**
   * validacion_pallets delete
   */
  export type validacion_palletsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validacion_pallets
     */
    select?: validacion_palletsSelect<ExtArgs> | null
    /**
     * Filter which validacion_pallets to delete.
     */
    where: validacion_palletsWhereUniqueInput
  }

  /**
   * validacion_pallets deleteMany
   */
  export type validacion_palletsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which validacion_pallets to delete
     */
    where?: validacion_palletsWhereInput
  }

  /**
   * validacion_pallets without action
   */
  export type validacion_palletsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validacion_pallets
     */
    select?: validacion_palletsSelect<ExtArgs> | null
  }


  /**
   * Model existencias_cajas
   */

  export type AggregateExistencias_cajas = {
    _count: Existencias_cajasCountAggregateOutputType | null
    _avg: Existencias_cajasAvgAggregateOutputType | null
    _sum: Existencias_cajasSumAggregateOutputType | null
    _min: Existencias_cajasMinAggregateOutputType | null
    _max: Existencias_cajasMaxAggregateOutputType | null
  }

  export type Existencias_cajasAvgAggregateOutputType = {
    Cajas: number | null
    Proceso: number | null
  }

  export type Existencias_cajasSumAggregateOutputType = {
    Cajas: number | null
    Proceso: number | null
  }

  export type Existencias_cajasMinAggregateOutputType = {
    Camara: string | null
    Especie: string | null
    Fecha_packing: Date | null
    Hora_Packing: string | null
    Packing: string | null
    Folio: string | null
    Productor: string | null
    CSG: string | null
    Marca: string | null
    Embalaje: string | null
    Linea: string | null
    Exportadora: string | null
    Jornada: string | null
    Variedad: string | null
    Calibre: string | null
    Categoria: string | null
    Cajas: number | null
    Proceso: number | null
  }

  export type Existencias_cajasMaxAggregateOutputType = {
    Camara: string | null
    Especie: string | null
    Fecha_packing: Date | null
    Hora_Packing: string | null
    Packing: string | null
    Folio: string | null
    Productor: string | null
    CSG: string | null
    Marca: string | null
    Embalaje: string | null
    Linea: string | null
    Exportadora: string | null
    Jornada: string | null
    Variedad: string | null
    Calibre: string | null
    Categoria: string | null
    Cajas: number | null
    Proceso: number | null
  }

  export type Existencias_cajasCountAggregateOutputType = {
    Camara: number
    Especie: number
    Fecha_packing: number
    Hora_Packing: number
    Packing: number
    Folio: number
    Productor: number
    CSG: number
    Marca: number
    Embalaje: number
    Linea: number
    Exportadora: number
    Jornada: number
    Variedad: number
    Calibre: number
    Categoria: number
    Cajas: number
    Proceso: number
    _all: number
  }


  export type Existencias_cajasAvgAggregateInputType = {
    Cajas?: true
    Proceso?: true
  }

  export type Existencias_cajasSumAggregateInputType = {
    Cajas?: true
    Proceso?: true
  }

  export type Existencias_cajasMinAggregateInputType = {
    Camara?: true
    Especie?: true
    Fecha_packing?: true
    Hora_Packing?: true
    Packing?: true
    Folio?: true
    Productor?: true
    CSG?: true
    Marca?: true
    Embalaje?: true
    Linea?: true
    Exportadora?: true
    Jornada?: true
    Variedad?: true
    Calibre?: true
    Categoria?: true
    Cajas?: true
    Proceso?: true
  }

  export type Existencias_cajasMaxAggregateInputType = {
    Camara?: true
    Especie?: true
    Fecha_packing?: true
    Hora_Packing?: true
    Packing?: true
    Folio?: true
    Productor?: true
    CSG?: true
    Marca?: true
    Embalaje?: true
    Linea?: true
    Exportadora?: true
    Jornada?: true
    Variedad?: true
    Calibre?: true
    Categoria?: true
    Cajas?: true
    Proceso?: true
  }

  export type Existencias_cajasCountAggregateInputType = {
    Camara?: true
    Especie?: true
    Fecha_packing?: true
    Hora_Packing?: true
    Packing?: true
    Folio?: true
    Productor?: true
    CSG?: true
    Marca?: true
    Embalaje?: true
    Linea?: true
    Exportadora?: true
    Jornada?: true
    Variedad?: true
    Calibre?: true
    Categoria?: true
    Cajas?: true
    Proceso?: true
    _all?: true
  }

  export type Existencias_cajasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which existencias_cajas to aggregate.
     */
    where?: existencias_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of existencias_cajas to fetch.
     */
    orderBy?: existencias_cajasOrderByWithRelationInput | existencias_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: existencias_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` existencias_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` existencias_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned existencias_cajas
    **/
    _count?: true | Existencias_cajasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Existencias_cajasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Existencias_cajasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Existencias_cajasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Existencias_cajasMaxAggregateInputType
  }

  export type GetExistencias_cajasAggregateType<T extends Existencias_cajasAggregateArgs> = {
        [P in keyof T & keyof AggregateExistencias_cajas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExistencias_cajas[P]>
      : GetScalarType<T[P], AggregateExistencias_cajas[P]>
  }




  export type existencias_cajasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: existencias_cajasWhereInput
    orderBy?: existencias_cajasOrderByWithAggregationInput | existencias_cajasOrderByWithAggregationInput[]
    by: Existencias_cajasScalarFieldEnum[] | Existencias_cajasScalarFieldEnum
    having?: existencias_cajasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Existencias_cajasCountAggregateInputType | true
    _avg?: Existencias_cajasAvgAggregateInputType
    _sum?: Existencias_cajasSumAggregateInputType
    _min?: Existencias_cajasMinAggregateInputType
    _max?: Existencias_cajasMaxAggregateInputType
  }

  export type Existencias_cajasGroupByOutputType = {
    Camara: string | null
    Especie: string | null
    Fecha_packing: Date | null
    Hora_Packing: string | null
    Packing: string
    Folio: string
    Productor: string | null
    CSG: string | null
    Marca: string
    Embalaje: string
    Linea: string | null
    Exportadora: string | null
    Jornada: string | null
    Variedad: string | null
    Calibre: string
    Categoria: string | null
    Cajas: number
    Proceso: number
    _count: Existencias_cajasCountAggregateOutputType | null
    _avg: Existencias_cajasAvgAggregateOutputType | null
    _sum: Existencias_cajasSumAggregateOutputType | null
    _min: Existencias_cajasMinAggregateOutputType | null
    _max: Existencias_cajasMaxAggregateOutputType | null
  }

  type GetExistencias_cajasGroupByPayload<T extends existencias_cajasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Existencias_cajasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Existencias_cajasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Existencias_cajasGroupByOutputType[P]>
            : GetScalarType<T[P], Existencias_cajasGroupByOutputType[P]>
        }
      >
    >


  export type existencias_cajasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Camara?: boolean
    Especie?: boolean
    Fecha_packing?: boolean
    Hora_Packing?: boolean
    Packing?: boolean
    Folio?: boolean
    Productor?: boolean
    CSG?: boolean
    Marca?: boolean
    Embalaje?: boolean
    Linea?: boolean
    Exportadora?: boolean
    Jornada?: boolean
    Variedad?: boolean
    Calibre?: boolean
    Categoria?: boolean
    Cajas?: boolean
    Proceso?: boolean
  }, ExtArgs["result"]["existencias_cajas"]>


  export type existencias_cajasSelectScalar = {
    Camara?: boolean
    Especie?: boolean
    Fecha_packing?: boolean
    Hora_Packing?: boolean
    Packing?: boolean
    Folio?: boolean
    Productor?: boolean
    CSG?: boolean
    Marca?: boolean
    Embalaje?: boolean
    Linea?: boolean
    Exportadora?: boolean
    Jornada?: boolean
    Variedad?: boolean
    Calibre?: boolean
    Categoria?: boolean
    Cajas?: boolean
    Proceso?: boolean
  }


  export type $existencias_cajasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "existencias_cajas"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Camara: string | null
      Especie: string | null
      Fecha_packing: Date | null
      Hora_Packing: string | null
      Packing: string
      Folio: string
      Productor: string | null
      CSG: string | null
      Marca: string
      Embalaje: string
      Linea: string | null
      Exportadora: string | null
      Jornada: string | null
      Variedad: string | null
      Calibre: string
      Categoria: string | null
      Cajas: number
      Proceso: number
    }, ExtArgs["result"]["existencias_cajas"]>
    composites: {}
  }

  type existencias_cajasGetPayload<S extends boolean | null | undefined | existencias_cajasDefaultArgs> = $Result.GetResult<Prisma.$existencias_cajasPayload, S>

  type existencias_cajasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<existencias_cajasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Existencias_cajasCountAggregateInputType | true
    }

  export interface existencias_cajasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['existencias_cajas'], meta: { name: 'existencias_cajas' } }
    /**
     * Find zero or one Existencias_cajas that matches the filter.
     * @param {existencias_cajasFindUniqueArgs} args - Arguments to find a Existencias_cajas
     * @example
     * // Get one Existencias_cajas
     * const existencias_cajas = await prisma.existencias_cajas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends existencias_cajasFindUniqueArgs>(args: SelectSubset<T, existencias_cajasFindUniqueArgs<ExtArgs>>): Prisma__existencias_cajasClient<$Result.GetResult<Prisma.$existencias_cajasPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Existencias_cajas that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {existencias_cajasFindUniqueOrThrowArgs} args - Arguments to find a Existencias_cajas
     * @example
     * // Get one Existencias_cajas
     * const existencias_cajas = await prisma.existencias_cajas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends existencias_cajasFindUniqueOrThrowArgs>(args: SelectSubset<T, existencias_cajasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__existencias_cajasClient<$Result.GetResult<Prisma.$existencias_cajasPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Existencias_cajas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {existencias_cajasFindFirstArgs} args - Arguments to find a Existencias_cajas
     * @example
     * // Get one Existencias_cajas
     * const existencias_cajas = await prisma.existencias_cajas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends existencias_cajasFindFirstArgs>(args?: SelectSubset<T, existencias_cajasFindFirstArgs<ExtArgs>>): Prisma__existencias_cajasClient<$Result.GetResult<Prisma.$existencias_cajasPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Existencias_cajas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {existencias_cajasFindFirstOrThrowArgs} args - Arguments to find a Existencias_cajas
     * @example
     * // Get one Existencias_cajas
     * const existencias_cajas = await prisma.existencias_cajas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends existencias_cajasFindFirstOrThrowArgs>(args?: SelectSubset<T, existencias_cajasFindFirstOrThrowArgs<ExtArgs>>): Prisma__existencias_cajasClient<$Result.GetResult<Prisma.$existencias_cajasPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Existencias_cajas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {existencias_cajasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Existencias_cajas
     * const existencias_cajas = await prisma.existencias_cajas.findMany()
     * 
     * // Get first 10 Existencias_cajas
     * const existencias_cajas = await prisma.existencias_cajas.findMany({ take: 10 })
     * 
     * // Only select the `Camara`
     * const existencias_cajasWithCamaraOnly = await prisma.existencias_cajas.findMany({ select: { Camara: true } })
     * 
     */
    findMany<T extends existencias_cajasFindManyArgs>(args?: SelectSubset<T, existencias_cajasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$existencias_cajasPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Existencias_cajas.
     * @param {existencias_cajasCreateArgs} args - Arguments to create a Existencias_cajas.
     * @example
     * // Create one Existencias_cajas
     * const Existencias_cajas = await prisma.existencias_cajas.create({
     *   data: {
     *     // ... data to create a Existencias_cajas
     *   }
     * })
     * 
     */
    create<T extends existencias_cajasCreateArgs>(args: SelectSubset<T, existencias_cajasCreateArgs<ExtArgs>>): Prisma__existencias_cajasClient<$Result.GetResult<Prisma.$existencias_cajasPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Existencias_cajas.
     * @param {existencias_cajasCreateManyArgs} args - Arguments to create many Existencias_cajas.
     * @example
     * // Create many Existencias_cajas
     * const existencias_cajas = await prisma.existencias_cajas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends existencias_cajasCreateManyArgs>(args?: SelectSubset<T, existencias_cajasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Existencias_cajas.
     * @param {existencias_cajasDeleteArgs} args - Arguments to delete one Existencias_cajas.
     * @example
     * // Delete one Existencias_cajas
     * const Existencias_cajas = await prisma.existencias_cajas.delete({
     *   where: {
     *     // ... filter to delete one Existencias_cajas
     *   }
     * })
     * 
     */
    delete<T extends existencias_cajasDeleteArgs>(args: SelectSubset<T, existencias_cajasDeleteArgs<ExtArgs>>): Prisma__existencias_cajasClient<$Result.GetResult<Prisma.$existencias_cajasPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Existencias_cajas.
     * @param {existencias_cajasUpdateArgs} args - Arguments to update one Existencias_cajas.
     * @example
     * // Update one Existencias_cajas
     * const existencias_cajas = await prisma.existencias_cajas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends existencias_cajasUpdateArgs>(args: SelectSubset<T, existencias_cajasUpdateArgs<ExtArgs>>): Prisma__existencias_cajasClient<$Result.GetResult<Prisma.$existencias_cajasPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Existencias_cajas.
     * @param {existencias_cajasDeleteManyArgs} args - Arguments to filter Existencias_cajas to delete.
     * @example
     * // Delete a few Existencias_cajas
     * const { count } = await prisma.existencias_cajas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends existencias_cajasDeleteManyArgs>(args?: SelectSubset<T, existencias_cajasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Existencias_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {existencias_cajasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Existencias_cajas
     * const existencias_cajas = await prisma.existencias_cajas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends existencias_cajasUpdateManyArgs>(args: SelectSubset<T, existencias_cajasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Existencias_cajas.
     * @param {existencias_cajasUpsertArgs} args - Arguments to update or create a Existencias_cajas.
     * @example
     * // Update or create a Existencias_cajas
     * const existencias_cajas = await prisma.existencias_cajas.upsert({
     *   create: {
     *     // ... data to create a Existencias_cajas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Existencias_cajas we want to update
     *   }
     * })
     */
    upsert<T extends existencias_cajasUpsertArgs>(args: SelectSubset<T, existencias_cajasUpsertArgs<ExtArgs>>): Prisma__existencias_cajasClient<$Result.GetResult<Prisma.$existencias_cajasPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Existencias_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {existencias_cajasCountArgs} args - Arguments to filter Existencias_cajas to count.
     * @example
     * // Count the number of Existencias_cajas
     * const count = await prisma.existencias_cajas.count({
     *   where: {
     *     // ... the filter for the Existencias_cajas we want to count
     *   }
     * })
    **/
    count<T extends existencias_cajasCountArgs>(
      args?: Subset<T, existencias_cajasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Existencias_cajasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Existencias_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Existencias_cajasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Existencias_cajasAggregateArgs>(args: Subset<T, Existencias_cajasAggregateArgs>): Prisma.PrismaPromise<GetExistencias_cajasAggregateType<T>>

    /**
     * Group by Existencias_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {existencias_cajasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends existencias_cajasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: existencias_cajasGroupByArgs['orderBy'] }
        : { orderBy?: existencias_cajasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, existencias_cajasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExistencias_cajasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the existencias_cajas model
   */
  readonly fields: existencias_cajasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for existencias_cajas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__existencias_cajasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the existencias_cajas model
   */ 
  interface existencias_cajasFieldRefs {
    readonly Camara: FieldRef<"existencias_cajas", 'String'>
    readonly Especie: FieldRef<"existencias_cajas", 'String'>
    readonly Fecha_packing: FieldRef<"existencias_cajas", 'DateTime'>
    readonly Hora_Packing: FieldRef<"existencias_cajas", 'String'>
    readonly Packing: FieldRef<"existencias_cajas", 'String'>
    readonly Folio: FieldRef<"existencias_cajas", 'String'>
    readonly Productor: FieldRef<"existencias_cajas", 'String'>
    readonly CSG: FieldRef<"existencias_cajas", 'String'>
    readonly Marca: FieldRef<"existencias_cajas", 'String'>
    readonly Embalaje: FieldRef<"existencias_cajas", 'String'>
    readonly Linea: FieldRef<"existencias_cajas", 'String'>
    readonly Exportadora: FieldRef<"existencias_cajas", 'String'>
    readonly Jornada: FieldRef<"existencias_cajas", 'String'>
    readonly Variedad: FieldRef<"existencias_cajas", 'String'>
    readonly Calibre: FieldRef<"existencias_cajas", 'String'>
    readonly Categoria: FieldRef<"existencias_cajas", 'String'>
    readonly Cajas: FieldRef<"existencias_cajas", 'Int'>
    readonly Proceso: FieldRef<"existencias_cajas", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * existencias_cajas findUnique
   */
  export type existencias_cajasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existencias_cajas
     */
    select?: existencias_cajasSelect<ExtArgs> | null
    /**
     * Filter, which existencias_cajas to fetch.
     */
    where: existencias_cajasWhereUniqueInput
  }

  /**
   * existencias_cajas findUniqueOrThrow
   */
  export type existencias_cajasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existencias_cajas
     */
    select?: existencias_cajasSelect<ExtArgs> | null
    /**
     * Filter, which existencias_cajas to fetch.
     */
    where: existencias_cajasWhereUniqueInput
  }

  /**
   * existencias_cajas findFirst
   */
  export type existencias_cajasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existencias_cajas
     */
    select?: existencias_cajasSelect<ExtArgs> | null
    /**
     * Filter, which existencias_cajas to fetch.
     */
    where?: existencias_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of existencias_cajas to fetch.
     */
    orderBy?: existencias_cajasOrderByWithRelationInput | existencias_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for existencias_cajas.
     */
    cursor?: existencias_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` existencias_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` existencias_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of existencias_cajas.
     */
    distinct?: Existencias_cajasScalarFieldEnum | Existencias_cajasScalarFieldEnum[]
  }

  /**
   * existencias_cajas findFirstOrThrow
   */
  export type existencias_cajasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existencias_cajas
     */
    select?: existencias_cajasSelect<ExtArgs> | null
    /**
     * Filter, which existencias_cajas to fetch.
     */
    where?: existencias_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of existencias_cajas to fetch.
     */
    orderBy?: existencias_cajasOrderByWithRelationInput | existencias_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for existencias_cajas.
     */
    cursor?: existencias_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` existencias_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` existencias_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of existencias_cajas.
     */
    distinct?: Existencias_cajasScalarFieldEnum | Existencias_cajasScalarFieldEnum[]
  }

  /**
   * existencias_cajas findMany
   */
  export type existencias_cajasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existencias_cajas
     */
    select?: existencias_cajasSelect<ExtArgs> | null
    /**
     * Filter, which existencias_cajas to fetch.
     */
    where?: existencias_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of existencias_cajas to fetch.
     */
    orderBy?: existencias_cajasOrderByWithRelationInput | existencias_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing existencias_cajas.
     */
    cursor?: existencias_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` existencias_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` existencias_cajas.
     */
    skip?: number
    distinct?: Existencias_cajasScalarFieldEnum | Existencias_cajasScalarFieldEnum[]
  }

  /**
   * existencias_cajas create
   */
  export type existencias_cajasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existencias_cajas
     */
    select?: existencias_cajasSelect<ExtArgs> | null
    /**
     * The data needed to create a existencias_cajas.
     */
    data: XOR<existencias_cajasCreateInput, existencias_cajasUncheckedCreateInput>
  }

  /**
   * existencias_cajas createMany
   */
  export type existencias_cajasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many existencias_cajas.
     */
    data: existencias_cajasCreateManyInput | existencias_cajasCreateManyInput[]
  }

  /**
   * existencias_cajas update
   */
  export type existencias_cajasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existencias_cajas
     */
    select?: existencias_cajasSelect<ExtArgs> | null
    /**
     * The data needed to update a existencias_cajas.
     */
    data: XOR<existencias_cajasUpdateInput, existencias_cajasUncheckedUpdateInput>
    /**
     * Choose, which existencias_cajas to update.
     */
    where: existencias_cajasWhereUniqueInput
  }

  /**
   * existencias_cajas updateMany
   */
  export type existencias_cajasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update existencias_cajas.
     */
    data: XOR<existencias_cajasUpdateManyMutationInput, existencias_cajasUncheckedUpdateManyInput>
    /**
     * Filter which existencias_cajas to update
     */
    where?: existencias_cajasWhereInput
  }

  /**
   * existencias_cajas upsert
   */
  export type existencias_cajasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existencias_cajas
     */
    select?: existencias_cajasSelect<ExtArgs> | null
    /**
     * The filter to search for the existencias_cajas to update in case it exists.
     */
    where: existencias_cajasWhereUniqueInput
    /**
     * In case the existencias_cajas found by the `where` argument doesn't exist, create a new existencias_cajas with this data.
     */
    create: XOR<existencias_cajasCreateInput, existencias_cajasUncheckedCreateInput>
    /**
     * In case the existencias_cajas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<existencias_cajasUpdateInput, existencias_cajasUncheckedUpdateInput>
  }

  /**
   * existencias_cajas delete
   */
  export type existencias_cajasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existencias_cajas
     */
    select?: existencias_cajasSelect<ExtArgs> | null
    /**
     * Filter which existencias_cajas to delete.
     */
    where: existencias_cajasWhereUniqueInput
  }

  /**
   * existencias_cajas deleteMany
   */
  export type existencias_cajasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which existencias_cajas to delete
     */
    where?: existencias_cajasWhereInput
  }

  /**
   * existencias_cajas without action
   */
  export type existencias_cajasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existencias_cajas
     */
    select?: existencias_cajasSelect<ExtArgs> | null
  }


  /**
   * Model existenciamix_cajas
   */

  export type AggregateExistenciamix_cajas = {
    _count: Existenciamix_cajasCountAggregateOutputType | null
    _avg: Existenciamix_cajasAvgAggregateOutputType | null
    _sum: Existenciamix_cajasSumAggregateOutputType | null
    _min: Existenciamix_cajasMinAggregateOutputType | null
    _max: Existenciamix_cajasMaxAggregateOutputType | null
  }

  export type Existenciamix_cajasAvgAggregateOutputType = {
    Cajas: number | null
    Proceso: number | null
  }

  export type Existenciamix_cajasSumAggregateOutputType = {
    Cajas: number | null
    Proceso: number | null
  }

  export type Existenciamix_cajasMinAggregateOutputType = {
    Camara: string | null
    Fecha_Packing: string | null
    Hora_Packing: string | null
    Packing: string | null
    Folio: string | null
    Productor: string | null
    CSG: string | null
    Cuartel: string | null
    Variedad: string | null
    Embalaje: string | null
    Etiqueta: string | null
    Calibre: string | null
    Categoria: string | null
    Cajas: number | null
    Proceso: number | null
  }

  export type Existenciamix_cajasMaxAggregateOutputType = {
    Camara: string | null
    Fecha_Packing: string | null
    Hora_Packing: string | null
    Packing: string | null
    Folio: string | null
    Productor: string | null
    CSG: string | null
    Cuartel: string | null
    Variedad: string | null
    Embalaje: string | null
    Etiqueta: string | null
    Calibre: string | null
    Categoria: string | null
    Cajas: number | null
    Proceso: number | null
  }

  export type Existenciamix_cajasCountAggregateOutputType = {
    Camara: number
    Fecha_Packing: number
    Hora_Packing: number
    Packing: number
    Folio: number
    Productor: number
    CSG: number
    Cuartel: number
    Variedad: number
    Embalaje: number
    Etiqueta: number
    Calibre: number
    Categoria: number
    Cajas: number
    Proceso: number
    _all: number
  }


  export type Existenciamix_cajasAvgAggregateInputType = {
    Cajas?: true
    Proceso?: true
  }

  export type Existenciamix_cajasSumAggregateInputType = {
    Cajas?: true
    Proceso?: true
  }

  export type Existenciamix_cajasMinAggregateInputType = {
    Camara?: true
    Fecha_Packing?: true
    Hora_Packing?: true
    Packing?: true
    Folio?: true
    Productor?: true
    CSG?: true
    Cuartel?: true
    Variedad?: true
    Embalaje?: true
    Etiqueta?: true
    Calibre?: true
    Categoria?: true
    Cajas?: true
    Proceso?: true
  }

  export type Existenciamix_cajasMaxAggregateInputType = {
    Camara?: true
    Fecha_Packing?: true
    Hora_Packing?: true
    Packing?: true
    Folio?: true
    Productor?: true
    CSG?: true
    Cuartel?: true
    Variedad?: true
    Embalaje?: true
    Etiqueta?: true
    Calibre?: true
    Categoria?: true
    Cajas?: true
    Proceso?: true
  }

  export type Existenciamix_cajasCountAggregateInputType = {
    Camara?: true
    Fecha_Packing?: true
    Hora_Packing?: true
    Packing?: true
    Folio?: true
    Productor?: true
    CSG?: true
    Cuartel?: true
    Variedad?: true
    Embalaje?: true
    Etiqueta?: true
    Calibre?: true
    Categoria?: true
    Cajas?: true
    Proceso?: true
    _all?: true
  }

  export type Existenciamix_cajasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which existenciamix_cajas to aggregate.
     */
    where?: existenciamix_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of existenciamix_cajas to fetch.
     */
    orderBy?: existenciamix_cajasOrderByWithRelationInput | existenciamix_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: existenciamix_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` existenciamix_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` existenciamix_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned existenciamix_cajas
    **/
    _count?: true | Existenciamix_cajasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Existenciamix_cajasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Existenciamix_cajasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Existenciamix_cajasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Existenciamix_cajasMaxAggregateInputType
  }

  export type GetExistenciamix_cajasAggregateType<T extends Existenciamix_cajasAggregateArgs> = {
        [P in keyof T & keyof AggregateExistenciamix_cajas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExistenciamix_cajas[P]>
      : GetScalarType<T[P], AggregateExistenciamix_cajas[P]>
  }




  export type existenciamix_cajasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: existenciamix_cajasWhereInput
    orderBy?: existenciamix_cajasOrderByWithAggregationInput | existenciamix_cajasOrderByWithAggregationInput[]
    by: Existenciamix_cajasScalarFieldEnum[] | Existenciamix_cajasScalarFieldEnum
    having?: existenciamix_cajasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Existenciamix_cajasCountAggregateInputType | true
    _avg?: Existenciamix_cajasAvgAggregateInputType
    _sum?: Existenciamix_cajasSumAggregateInputType
    _min?: Existenciamix_cajasMinAggregateInputType
    _max?: Existenciamix_cajasMaxAggregateInputType
  }

  export type Existenciamix_cajasGroupByOutputType = {
    Camara: string | null
    Fecha_Packing: string | null
    Hora_Packing: string | null
    Packing: string
    Folio: string
    Productor: string | null
    CSG: string | null
    Cuartel: string | null
    Variedad: string | null
    Embalaje: string
    Etiqueta: string | null
    Calibre: string
    Categoria: string | null
    Cajas: number
    Proceso: number
    _count: Existenciamix_cajasCountAggregateOutputType | null
    _avg: Existenciamix_cajasAvgAggregateOutputType | null
    _sum: Existenciamix_cajasSumAggregateOutputType | null
    _min: Existenciamix_cajasMinAggregateOutputType | null
    _max: Existenciamix_cajasMaxAggregateOutputType | null
  }

  type GetExistenciamix_cajasGroupByPayload<T extends existenciamix_cajasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Existenciamix_cajasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Existenciamix_cajasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Existenciamix_cajasGroupByOutputType[P]>
            : GetScalarType<T[P], Existenciamix_cajasGroupByOutputType[P]>
        }
      >
    >


  export type existenciamix_cajasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Camara?: boolean
    Fecha_Packing?: boolean
    Hora_Packing?: boolean
    Packing?: boolean
    Folio?: boolean
    Productor?: boolean
    CSG?: boolean
    Cuartel?: boolean
    Variedad?: boolean
    Embalaje?: boolean
    Etiqueta?: boolean
    Calibre?: boolean
    Categoria?: boolean
    Cajas?: boolean
    Proceso?: boolean
  }, ExtArgs["result"]["existenciamix_cajas"]>


  export type existenciamix_cajasSelectScalar = {
    Camara?: boolean
    Fecha_Packing?: boolean
    Hora_Packing?: boolean
    Packing?: boolean
    Folio?: boolean
    Productor?: boolean
    CSG?: boolean
    Cuartel?: boolean
    Variedad?: boolean
    Embalaje?: boolean
    Etiqueta?: boolean
    Calibre?: boolean
    Categoria?: boolean
    Cajas?: boolean
    Proceso?: boolean
  }


  export type $existenciamix_cajasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "existenciamix_cajas"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Camara: string | null
      Fecha_Packing: string | null
      Hora_Packing: string | null
      Packing: string
      Folio: string
      Productor: string | null
      CSG: string | null
      Cuartel: string | null
      Variedad: string | null
      Embalaje: string
      Etiqueta: string | null
      Calibre: string
      Categoria: string | null
      Cajas: number
      Proceso: number
    }, ExtArgs["result"]["existenciamix_cajas"]>
    composites: {}
  }

  type existenciamix_cajasGetPayload<S extends boolean | null | undefined | existenciamix_cajasDefaultArgs> = $Result.GetResult<Prisma.$existenciamix_cajasPayload, S>

  type existenciamix_cajasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<existenciamix_cajasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Existenciamix_cajasCountAggregateInputType | true
    }

  export interface existenciamix_cajasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['existenciamix_cajas'], meta: { name: 'existenciamix_cajas' } }
    /**
     * Find zero or one Existenciamix_cajas that matches the filter.
     * @param {existenciamix_cajasFindUniqueArgs} args - Arguments to find a Existenciamix_cajas
     * @example
     * // Get one Existenciamix_cajas
     * const existenciamix_cajas = await prisma.existenciamix_cajas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends existenciamix_cajasFindUniqueArgs>(args: SelectSubset<T, existenciamix_cajasFindUniqueArgs<ExtArgs>>): Prisma__existenciamix_cajasClient<$Result.GetResult<Prisma.$existenciamix_cajasPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Existenciamix_cajas that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {existenciamix_cajasFindUniqueOrThrowArgs} args - Arguments to find a Existenciamix_cajas
     * @example
     * // Get one Existenciamix_cajas
     * const existenciamix_cajas = await prisma.existenciamix_cajas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends existenciamix_cajasFindUniqueOrThrowArgs>(args: SelectSubset<T, existenciamix_cajasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__existenciamix_cajasClient<$Result.GetResult<Prisma.$existenciamix_cajasPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Existenciamix_cajas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {existenciamix_cajasFindFirstArgs} args - Arguments to find a Existenciamix_cajas
     * @example
     * // Get one Existenciamix_cajas
     * const existenciamix_cajas = await prisma.existenciamix_cajas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends existenciamix_cajasFindFirstArgs>(args?: SelectSubset<T, existenciamix_cajasFindFirstArgs<ExtArgs>>): Prisma__existenciamix_cajasClient<$Result.GetResult<Prisma.$existenciamix_cajasPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Existenciamix_cajas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {existenciamix_cajasFindFirstOrThrowArgs} args - Arguments to find a Existenciamix_cajas
     * @example
     * // Get one Existenciamix_cajas
     * const existenciamix_cajas = await prisma.existenciamix_cajas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends existenciamix_cajasFindFirstOrThrowArgs>(args?: SelectSubset<T, existenciamix_cajasFindFirstOrThrowArgs<ExtArgs>>): Prisma__existenciamix_cajasClient<$Result.GetResult<Prisma.$existenciamix_cajasPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Existenciamix_cajas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {existenciamix_cajasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Existenciamix_cajas
     * const existenciamix_cajas = await prisma.existenciamix_cajas.findMany()
     * 
     * // Get first 10 Existenciamix_cajas
     * const existenciamix_cajas = await prisma.existenciamix_cajas.findMany({ take: 10 })
     * 
     * // Only select the `Camara`
     * const existenciamix_cajasWithCamaraOnly = await prisma.existenciamix_cajas.findMany({ select: { Camara: true } })
     * 
     */
    findMany<T extends existenciamix_cajasFindManyArgs>(args?: SelectSubset<T, existenciamix_cajasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$existenciamix_cajasPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Existenciamix_cajas.
     * @param {existenciamix_cajasCreateArgs} args - Arguments to create a Existenciamix_cajas.
     * @example
     * // Create one Existenciamix_cajas
     * const Existenciamix_cajas = await prisma.existenciamix_cajas.create({
     *   data: {
     *     // ... data to create a Existenciamix_cajas
     *   }
     * })
     * 
     */
    create<T extends existenciamix_cajasCreateArgs>(args: SelectSubset<T, existenciamix_cajasCreateArgs<ExtArgs>>): Prisma__existenciamix_cajasClient<$Result.GetResult<Prisma.$existenciamix_cajasPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Existenciamix_cajas.
     * @param {existenciamix_cajasCreateManyArgs} args - Arguments to create many Existenciamix_cajas.
     * @example
     * // Create many Existenciamix_cajas
     * const existenciamix_cajas = await prisma.existenciamix_cajas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends existenciamix_cajasCreateManyArgs>(args?: SelectSubset<T, existenciamix_cajasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Existenciamix_cajas.
     * @param {existenciamix_cajasDeleteArgs} args - Arguments to delete one Existenciamix_cajas.
     * @example
     * // Delete one Existenciamix_cajas
     * const Existenciamix_cajas = await prisma.existenciamix_cajas.delete({
     *   where: {
     *     // ... filter to delete one Existenciamix_cajas
     *   }
     * })
     * 
     */
    delete<T extends existenciamix_cajasDeleteArgs>(args: SelectSubset<T, existenciamix_cajasDeleteArgs<ExtArgs>>): Prisma__existenciamix_cajasClient<$Result.GetResult<Prisma.$existenciamix_cajasPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Existenciamix_cajas.
     * @param {existenciamix_cajasUpdateArgs} args - Arguments to update one Existenciamix_cajas.
     * @example
     * // Update one Existenciamix_cajas
     * const existenciamix_cajas = await prisma.existenciamix_cajas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends existenciamix_cajasUpdateArgs>(args: SelectSubset<T, existenciamix_cajasUpdateArgs<ExtArgs>>): Prisma__existenciamix_cajasClient<$Result.GetResult<Prisma.$existenciamix_cajasPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Existenciamix_cajas.
     * @param {existenciamix_cajasDeleteManyArgs} args - Arguments to filter Existenciamix_cajas to delete.
     * @example
     * // Delete a few Existenciamix_cajas
     * const { count } = await prisma.existenciamix_cajas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends existenciamix_cajasDeleteManyArgs>(args?: SelectSubset<T, existenciamix_cajasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Existenciamix_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {existenciamix_cajasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Existenciamix_cajas
     * const existenciamix_cajas = await prisma.existenciamix_cajas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends existenciamix_cajasUpdateManyArgs>(args: SelectSubset<T, existenciamix_cajasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Existenciamix_cajas.
     * @param {existenciamix_cajasUpsertArgs} args - Arguments to update or create a Existenciamix_cajas.
     * @example
     * // Update or create a Existenciamix_cajas
     * const existenciamix_cajas = await prisma.existenciamix_cajas.upsert({
     *   create: {
     *     // ... data to create a Existenciamix_cajas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Existenciamix_cajas we want to update
     *   }
     * })
     */
    upsert<T extends existenciamix_cajasUpsertArgs>(args: SelectSubset<T, existenciamix_cajasUpsertArgs<ExtArgs>>): Prisma__existenciamix_cajasClient<$Result.GetResult<Prisma.$existenciamix_cajasPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Existenciamix_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {existenciamix_cajasCountArgs} args - Arguments to filter Existenciamix_cajas to count.
     * @example
     * // Count the number of Existenciamix_cajas
     * const count = await prisma.existenciamix_cajas.count({
     *   where: {
     *     // ... the filter for the Existenciamix_cajas we want to count
     *   }
     * })
    **/
    count<T extends existenciamix_cajasCountArgs>(
      args?: Subset<T, existenciamix_cajasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Existenciamix_cajasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Existenciamix_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Existenciamix_cajasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Existenciamix_cajasAggregateArgs>(args: Subset<T, Existenciamix_cajasAggregateArgs>): Prisma.PrismaPromise<GetExistenciamix_cajasAggregateType<T>>

    /**
     * Group by Existenciamix_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {existenciamix_cajasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends existenciamix_cajasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: existenciamix_cajasGroupByArgs['orderBy'] }
        : { orderBy?: existenciamix_cajasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, existenciamix_cajasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExistenciamix_cajasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the existenciamix_cajas model
   */
  readonly fields: existenciamix_cajasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for existenciamix_cajas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__existenciamix_cajasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the existenciamix_cajas model
   */ 
  interface existenciamix_cajasFieldRefs {
    readonly Camara: FieldRef<"existenciamix_cajas", 'String'>
    readonly Fecha_Packing: FieldRef<"existenciamix_cajas", 'String'>
    readonly Hora_Packing: FieldRef<"existenciamix_cajas", 'String'>
    readonly Packing: FieldRef<"existenciamix_cajas", 'String'>
    readonly Folio: FieldRef<"existenciamix_cajas", 'String'>
    readonly Productor: FieldRef<"existenciamix_cajas", 'String'>
    readonly CSG: FieldRef<"existenciamix_cajas", 'String'>
    readonly Cuartel: FieldRef<"existenciamix_cajas", 'String'>
    readonly Variedad: FieldRef<"existenciamix_cajas", 'String'>
    readonly Embalaje: FieldRef<"existenciamix_cajas", 'String'>
    readonly Etiqueta: FieldRef<"existenciamix_cajas", 'String'>
    readonly Calibre: FieldRef<"existenciamix_cajas", 'String'>
    readonly Categoria: FieldRef<"existenciamix_cajas", 'String'>
    readonly Cajas: FieldRef<"existenciamix_cajas", 'Int'>
    readonly Proceso: FieldRef<"existenciamix_cajas", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * existenciamix_cajas findUnique
   */
  export type existenciamix_cajasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existenciamix_cajas
     */
    select?: existenciamix_cajasSelect<ExtArgs> | null
    /**
     * Filter, which existenciamix_cajas to fetch.
     */
    where: existenciamix_cajasWhereUniqueInput
  }

  /**
   * existenciamix_cajas findUniqueOrThrow
   */
  export type existenciamix_cajasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existenciamix_cajas
     */
    select?: existenciamix_cajasSelect<ExtArgs> | null
    /**
     * Filter, which existenciamix_cajas to fetch.
     */
    where: existenciamix_cajasWhereUniqueInput
  }

  /**
   * existenciamix_cajas findFirst
   */
  export type existenciamix_cajasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existenciamix_cajas
     */
    select?: existenciamix_cajasSelect<ExtArgs> | null
    /**
     * Filter, which existenciamix_cajas to fetch.
     */
    where?: existenciamix_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of existenciamix_cajas to fetch.
     */
    orderBy?: existenciamix_cajasOrderByWithRelationInput | existenciamix_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for existenciamix_cajas.
     */
    cursor?: existenciamix_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` existenciamix_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` existenciamix_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of existenciamix_cajas.
     */
    distinct?: Existenciamix_cajasScalarFieldEnum | Existenciamix_cajasScalarFieldEnum[]
  }

  /**
   * existenciamix_cajas findFirstOrThrow
   */
  export type existenciamix_cajasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existenciamix_cajas
     */
    select?: existenciamix_cajasSelect<ExtArgs> | null
    /**
     * Filter, which existenciamix_cajas to fetch.
     */
    where?: existenciamix_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of existenciamix_cajas to fetch.
     */
    orderBy?: existenciamix_cajasOrderByWithRelationInput | existenciamix_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for existenciamix_cajas.
     */
    cursor?: existenciamix_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` existenciamix_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` existenciamix_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of existenciamix_cajas.
     */
    distinct?: Existenciamix_cajasScalarFieldEnum | Existenciamix_cajasScalarFieldEnum[]
  }

  /**
   * existenciamix_cajas findMany
   */
  export type existenciamix_cajasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existenciamix_cajas
     */
    select?: existenciamix_cajasSelect<ExtArgs> | null
    /**
     * Filter, which existenciamix_cajas to fetch.
     */
    where?: existenciamix_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of existenciamix_cajas to fetch.
     */
    orderBy?: existenciamix_cajasOrderByWithRelationInput | existenciamix_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing existenciamix_cajas.
     */
    cursor?: existenciamix_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` existenciamix_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` existenciamix_cajas.
     */
    skip?: number
    distinct?: Existenciamix_cajasScalarFieldEnum | Existenciamix_cajasScalarFieldEnum[]
  }

  /**
   * existenciamix_cajas create
   */
  export type existenciamix_cajasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existenciamix_cajas
     */
    select?: existenciamix_cajasSelect<ExtArgs> | null
    /**
     * The data needed to create a existenciamix_cajas.
     */
    data: XOR<existenciamix_cajasCreateInput, existenciamix_cajasUncheckedCreateInput>
  }

  /**
   * existenciamix_cajas createMany
   */
  export type existenciamix_cajasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many existenciamix_cajas.
     */
    data: existenciamix_cajasCreateManyInput | existenciamix_cajasCreateManyInput[]
  }

  /**
   * existenciamix_cajas update
   */
  export type existenciamix_cajasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existenciamix_cajas
     */
    select?: existenciamix_cajasSelect<ExtArgs> | null
    /**
     * The data needed to update a existenciamix_cajas.
     */
    data: XOR<existenciamix_cajasUpdateInput, existenciamix_cajasUncheckedUpdateInput>
    /**
     * Choose, which existenciamix_cajas to update.
     */
    where: existenciamix_cajasWhereUniqueInput
  }

  /**
   * existenciamix_cajas updateMany
   */
  export type existenciamix_cajasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update existenciamix_cajas.
     */
    data: XOR<existenciamix_cajasUpdateManyMutationInput, existenciamix_cajasUncheckedUpdateManyInput>
    /**
     * Filter which existenciamix_cajas to update
     */
    where?: existenciamix_cajasWhereInput
  }

  /**
   * existenciamix_cajas upsert
   */
  export type existenciamix_cajasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existenciamix_cajas
     */
    select?: existenciamix_cajasSelect<ExtArgs> | null
    /**
     * The filter to search for the existenciamix_cajas to update in case it exists.
     */
    where: existenciamix_cajasWhereUniqueInput
    /**
     * In case the existenciamix_cajas found by the `where` argument doesn't exist, create a new existenciamix_cajas with this data.
     */
    create: XOR<existenciamix_cajasCreateInput, existenciamix_cajasUncheckedCreateInput>
    /**
     * In case the existenciamix_cajas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<existenciamix_cajasUpdateInput, existenciamix_cajasUncheckedUpdateInput>
  }

  /**
   * existenciamix_cajas delete
   */
  export type existenciamix_cajasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existenciamix_cajas
     */
    select?: existenciamix_cajasSelect<ExtArgs> | null
    /**
     * Filter which existenciamix_cajas to delete.
     */
    where: existenciamix_cajasWhereUniqueInput
  }

  /**
   * existenciamix_cajas deleteMany
   */
  export type existenciamix_cajasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which existenciamix_cajas to delete
     */
    where?: existenciamix_cajasWhereInput
  }

  /**
   * existenciamix_cajas without action
   */
  export type existenciamix_cajasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the existenciamix_cajas
     */
    select?: existenciamix_cajasSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable',
    Snapshot: 'Snapshot'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Capacidad_lineasScalarFieldEnum: {
    id: 'id',
    cod_linea: 'cod_linea',
    cod_esp: 'cod_esp',
    nro_vias: 'nro_vias',
    capacidad_vias: 'capacidad_vias'
  };

  export type Capacidad_lineasScalarFieldEnum = (typeof Capacidad_lineasScalarFieldEnum)[keyof typeof Capacidad_lineasScalarFieldEnum]


  export const Cc_checklistScalarFieldEnum: {
    id: 'id',
    n_proceso: 'n_proceso',
    cod_esp: 'cod_esp',
    cod_var: 'cod_var',
    cod_pro: 'cod_pro',
    cod_linea: 'cod_linea',
    fecha: 'fecha',
    cal_encerado: 'cal_encerado',
    porc_exp: 'porc_exp',
    cal_cajas: 'cal_cajas',
    porc_plu_c: 'porc_plu_c',
    peso_caj: 'peso_caj',
    cal_palet: 'cal_palet',
    saturacion: 'saturacion',
    porc_exp_c: 'porc_exp_c',
    usuario: 'usuario',
    porc_plu: 'porc_plu',
    cod_emp: 'cod_emp',
    cod_tem: 'cod_tem',
    cod_envop: 'cod_envop',
    peso_c: 'peso_c',
    fec_muestra: 'fec_muestra'
  };

  export type Cc_checklistScalarFieldEnum = (typeof Cc_checklistScalarFieldEnum)[keyof typeof Cc_checklistScalarFieldEnum]


  export const CertificacionScalarFieldEnum: {
    id: 'id',
    exportadora: 'exportadora',
    productor: 'productor',
    ggn: 'ggn',
    fecha_emision: 'fecha_emision',
    fecha_caducidad: 'fecha_caducidad',
    vigencia: 'vigencia',
    especie: 'especie',
    mercados: 'mercados'
  };

  export type CertificacionScalarFieldEnum = (typeof CertificacionScalarFieldEnum)[keyof typeof CertificacionScalarFieldEnum]


  export const CorrelativoScalarFieldEnum: {
    id_cor: 'id_cor',
    id_tip_ins: 'id_tip_ins',
    nro_sag: 'nro_sag',
    cod_sdp: 'cod_sdp'
  };

  export type CorrelativoScalarFieldEnum = (typeof CorrelativoScalarFieldEnum)[keyof typeof CorrelativoScalarFieldEnum]


  export const Env_x_sellarScalarFieldEnum: {
    id: 'id',
    cod_envop: 'cod_envop',
    cod_esp: 'cod_esp',
    cod_exp: 'cod_exp'
  };

  export type Env_x_sellarScalarFieldEnum = (typeof Env_x_sellarScalarFieldEnum)[keyof typeof Env_x_sellarScalarFieldEnum]


  export const EstadosScalarFieldEnum: {
    id_est_ins: 'id_est_ins',
    des_est_ins: 'des_est_ins',
    tip_sdt: 'tip_sdt',
    id_tip_ins: 'id_tip_ins'
  };

  export type EstadosScalarFieldEnum = (typeof EstadosScalarFieldEnum)[keyof typeof EstadosScalarFieldEnum]


  export const FoliosScalarFieldEnum: {
    folio: 'folio',
    nom_var: 'nom_var',
    cod_var: 'cod_var',
    cajas: 'cajas',
    fecha: 'fecha',
    calibre: 'calibre',
    embalaje: 'embalaje'
  };

  export type FoliosScalarFieldEnum = (typeof FoliosScalarFieldEnum)[keyof typeof FoliosScalarFieldEnum]


  export const Folios_frioScalarFieldEnum: {
    folio: 'folio',
    nom_var: 'nom_var',
    cod_var: 'cod_var',
    cajas: 'cajas',
    fecha: 'fecha',
    calibre: 'calibre',
    embalaje: 'embalaje'
  };

  export type Folios_frioScalarFieldEnum = (typeof Folios_frioScalarFieldEnum)[keyof typeof Folios_frioScalarFieldEnum]


  export const Folios_packScalarFieldEnum: {
    folio: 'folio',
    nom_var: 'nom_var',
    cod_var: 'cod_var',
    cajas: 'cajas',
    fecha: 'fecha',
    calibre: 'calibre',
    embalaje: 'embalaje'
  };

  export type Folios_packScalarFieldEnum = (typeof Folios_packScalarFieldEnum)[keyof typeof Folios_packScalarFieldEnum]


  export const Folios_seScalarFieldEnum: {
    folio: 'folio',
    nom_var: 'nom_var',
    cod_var: 'cod_var',
    cajas: 'cajas',
    fecha: 'fecha',
    calibre: 'calibre',
    embalaje: 'embalaje'
  };

  export type Folios_seScalarFieldEnum = (typeof Folios_seScalarFieldEnum)[keyof typeof Folios_seScalarFieldEnum]


  export const Fr_repa_cabScalarFieldEnum: {
    id: 'id',
    fec_rep: 'fec_rep',
    id_tip_rep: 'id_tip_rep',
    fr_cod_pac: 'fr_cod_pac',
    fr_cod_fri: 'fr_cod_fri',
    fr_usu: 'fr_usu',
    fr_rep_sag: 'fr_rep_sag',
    fr_cod_tem: 'fr_cod_tem',
    fr_cod_emp: 'fr_cod_emp',
    fr_tra_sdt: 'fr_tra_sdt',
    fr_nro_rep: 'fr_nro_rep',
    fr_cod_esp: 'fr_cod_esp'
  };

  export type Fr_repa_cabScalarFieldEnum = (typeof Fr_repa_cabScalarFieldEnum)[keyof typeof Fr_repa_cabScalarFieldEnum]


  export const Fr_repa_detScalarFieldEnum: {
    id: 'id',
    id_rep_cab: 'id_rep_cab',
    fr_lote: 'fr_lote',
    fr_cor_sdt: 'fr_cor_sdt',
    fr_pla_sdt: 'fr_pla_sdt',
    fr_est_sdt: 'fr_est_sdt',
    fr_fec_pac: 'fr_fec_pac',
    fr_fec_rpa: 'fr_fec_rpa',
    fr_gui_sdt: 'fr_gui_sdt',
    fr_cod_pro: 'fr_cod_pro',
    fr_cod_esp: 'fr_cod_esp',
    fr_cod_var: 'fr_cod_var',
    fr_hor_rec: 'fr_hor_rec',
    fr_con: 'fr_con',
    fr_tip_lot: 'fr_tip_lot',
    fr_alt_pal: 'fr_alt_pal',
    fr_cod_env: 'fr_cod_env',
    fr_cod_eti: 'fr_cod_eti',
    fr_cod_emb: 'fr_cod_emb',
    fr_cod_envop: 'fr_cod_envop',
    fr_plu: 'fr_plu',
    fr_caj: 'fr_caj',
    fr_cod_cat: 'fr_cod_cat',
    fr_cod_cal: 'fr_cod_cal',
    fr_nro_mix: 'fr_nro_mix',
    fr_fec_sem: 'fr_fec_sem',
    fr_cod_bp: 'fr_cod_bp',
    fr_cod_pre: 'fr_cod_pre',
    fr_cod_cua: 'fr_cod_cua',
    fr_proceso: 'fr_proceso',
    fr_con_fri: 'fr_con_fri',
    fr_fol_ori: 'fr_fol_ori',
    fr_cod_var_eti: 'fr_cod_var_eti',
    fr_cod_tip_tra: 'fr_cod_tip_tra',
    fr_cod_pro_eti: 'fr_cod_pro_eti',
    fr_cod_exp: 'fr_cod_exp',
    fr_pk_ori: 'fr_pk_ori',
    id_tip_io: 'id_tip_io',
    fr_caj_usa: 'fr_caj_usa',
    fr_tip_mov: 'fr_tip_mov',
    fr_fec_sag: 'fr_fec_sag',
    fr_guia_sag: 'fr_guia_sag',
    fr_cer_sag: 'fr_cer_sag',
    fr_sol_sag: 'fr_sol_sag',
    fr_tip_sag: 'fr_tip_sag',
    fr_cod_mer: 'fr_cod_mer',
    fr_cod_mer1: 'fr_cod_mer1',
    fr_cod_mer2: 'fr_cod_mer2',
    fr_cod_mer3: 'fr_cod_mer3',
    fr_cod_mer4: 'fr_cod_mer4',
    fr_fec_fum: 'fr_fec_fum',
    fr_guia_fum: 'fr_guia_fum',
    fr_cer_fum: 'fr_cer_fum',
    fr_cod_tipo_fum: 'fr_cod_tipo_fum',
    fr_pfrio: 'fr_pfrio',
    fr_correlativo_rec: 'fr_correlativo_rec',
    fr_cod_linea: 'fr_cod_linea',
    fr_peso_original: 'fr_peso_original'
  };

  export type Fr_repa_detScalarFieldEnum = (typeof Fr_repa_detScalarFieldEnum)[keyof typeof Fr_repa_detScalarFieldEnum]


  export const Gr_Tipo_CobroScalarFieldEnum: {
    id: 'id',
    Descripcion: 'Descripcion',
    tipo_c: 'tipo_c'
  };

  export type Gr_Tipo_CobroScalarFieldEnum = (typeof Gr_Tipo_CobroScalarFieldEnum)[keyof typeof Gr_Tipo_CobroScalarFieldEnum]


  export const Insp_cabScalarFieldEnum: {
    id_ins: 'id_ins',
    nro_sag: 'nro_sag',
    cod_csp: 'cod_csp',
    id_tip_ins: 'id_tip_ins',
    fec_doc: 'fec_doc',
    fec_ins: 'fec_ins',
    id_usuario: 'id_usuario',
    cod_mer: 'cod_mer',
    cod_mer1: 'cod_mer1',
    cod_mer2: 'cod_mer2',
    cod_mer3: 'cod_mer3',
    obs_insp: 'obs_insp',
    id_est_ins: 'id_est_ins'
  };

  export type Insp_cabScalarFieldEnum = (typeof Insp_cabScalarFieldEnum)[keyof typeof Insp_cabScalarFieldEnum]


  export const Mae_sta_elenaScalarFieldEnum: {
    cod_emb: 'cod_emb'
  };

  export type Mae_sta_elenaScalarFieldEnum = (typeof Mae_sta_elenaScalarFieldEnum)[keyof typeof Mae_sta_elenaScalarFieldEnum]


  export const Maestro_pluScalarFieldEnum: {
    cod_envop: 'cod_envop',
    cod_cal: 'cod_cal',
    cod_plu: 'cod_plu'
  };

  export type Maestro_pluScalarFieldEnum = (typeof Maestro_pluScalarFieldEnum)[keyof typeof Maestro_pluScalarFieldEnum]


  export const Pk_desver_cabScalarFieldEnum: {
    id: 'id',
    pro_nro: 'pro_nro',
    fec_ini: 'fec_ini',
    fec_fin: 'fec_fin',
    usu_res: 'usu_res',
    pes_ini: 'pes_ini',
    pes_fin: 'pes_fin',
    cod_esp: 'cod_esp',
    fec_ven: 'fec_ven'
  };

  export type Pk_desver_cabScalarFieldEnum = (typeof Pk_desver_cabScalarFieldEnum)[keyof typeof Pk_desver_cabScalarFieldEnum]


  export const Pk_desver_detScalarFieldEnum: {
    id: 'id',
    id_cab: 'id_cab',
    folio: 'folio',
    cod_var: 'cod_var',
    cod_esp: 'cod_esp',
    peso_neto: 'peso_neto',
    peso_fin: 'peso_fin',
    cod_cal: 'cod_cal'
  };

  export type Pk_desver_detScalarFieldEnum = (typeof Pk_desver_detScalarFieldEnum)[keyof typeof Pk_desver_detScalarFieldEnum]


  export const Sys_logScalarFieldEnum: {
    id: 'id',
    tip_eve: 'tip_eve',
    usu_sys: 'usu_sys',
    ip_pc: 'ip_pc',
    fecha_log: 'fecha_log',
    folio: 'folio',
    modulo: 'modulo'
  };

  export type Sys_logScalarFieldEnum = (typeof Sys_logScalarFieldEnum)[keyof typeof Sys_logScalarFieldEnum]


  export const SysdiagramsScalarFieldEnum: {
    name: 'name',
    principal_id: 'principal_id',
    diagram_id: 'diagram_id',
    version: 'version',
    definition: 'definition'
  };

  export type SysdiagramsScalarFieldEnum = (typeof SysdiagramsScalarFieldEnum)[keyof typeof SysdiagramsScalarFieldEnum]


  export const Tipo_insScalarFieldEnum: {
    id_tip_ins: 'id_tip_ins',
    des_tip_ins: 'des_tip_ins'
  };

  export type Tipo_insScalarFieldEnum = (typeof Tipo_insScalarFieldEnum)[keyof typeof Tipo_insScalarFieldEnum]


  export const Traductor_calibreScalarFieldEnum: {
    id: 'id',
    n_calibre_std: 'n_calibre_std',
    val_calibre: 'val_calibre',
    cod_exp: 'cod_exp',
    n_calibre: 'n_calibre'
  };

  export type Traductor_calibreScalarFieldEnum = (typeof Traductor_calibreScalarFieldEnum)[keyof typeof Traductor_calibreScalarFieldEnum]


  export const Validacion_palletsScalarFieldEnum: {
    id: 'id',
    numero_pallet: 'numero_pallet',
    temporada: 'temporada'
  };

  export type Validacion_palletsScalarFieldEnum = (typeof Validacion_palletsScalarFieldEnum)[keyof typeof Validacion_palletsScalarFieldEnum]


  export const Existencias_cajasScalarFieldEnum: {
    Camara: 'Camara',
    Especie: 'Especie',
    Fecha_packing: 'Fecha_packing',
    Hora_Packing: 'Hora_Packing',
    Packing: 'Packing',
    Folio: 'Folio',
    Productor: 'Productor',
    CSG: 'CSG',
    Marca: 'Marca',
    Embalaje: 'Embalaje',
    Linea: 'Linea',
    Exportadora: 'Exportadora',
    Jornada: 'Jornada',
    Variedad: 'Variedad',
    Calibre: 'Calibre',
    Categoria: 'Categoria',
    Cajas: 'Cajas',
    Proceso: 'Proceso'
  };

  export type Existencias_cajasScalarFieldEnum = (typeof Existencias_cajasScalarFieldEnum)[keyof typeof Existencias_cajasScalarFieldEnum]


  export const Existenciamix_cajasScalarFieldEnum: {
    Camara: 'Camara',
    Fecha_Packing: 'Fecha_Packing',
    Hora_Packing: 'Hora_Packing',
    Packing: 'Packing',
    Folio: 'Folio',
    Productor: 'Productor',
    CSG: 'CSG',
    Cuartel: 'Cuartel',
    Variedad: 'Variedad',
    Embalaje: 'Embalaje',
    Etiqueta: 'Etiqueta',
    Calibre: 'Calibre',
    Categoria: 'Categoria',
    Cajas: 'Cajas',
    Proceso: 'Proceso'
  };

  export type Existenciamix_cajasScalarFieldEnum = (typeof Existenciamix_cajasScalarFieldEnum)[keyof typeof Existenciamix_cajasScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type capacidad_lineasWhereInput = {
    AND?: capacidad_lineasWhereInput | capacidad_lineasWhereInput[]
    OR?: capacidad_lineasWhereInput[]
    NOT?: capacidad_lineasWhereInput | capacidad_lineasWhereInput[]
    id?: IntFilter<"capacidad_lineas"> | number
    cod_linea?: StringNullableFilter<"capacidad_lineas"> | string | null
    cod_esp?: StringNullableFilter<"capacidad_lineas"> | string | null
    nro_vias?: IntNullableFilter<"capacidad_lineas"> | number | null
    capacidad_vias?: DecimalNullableFilter<"capacidad_lineas"> | Decimal | DecimalJsLike | number | string | null
  }

  export type capacidad_lineasOrderByWithRelationInput = {
    id?: SortOrder
    cod_linea?: SortOrderInput | SortOrder
    cod_esp?: SortOrderInput | SortOrder
    nro_vias?: SortOrderInput | SortOrder
    capacidad_vias?: SortOrderInput | SortOrder
  }

  export type capacidad_lineasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: capacidad_lineasWhereInput | capacidad_lineasWhereInput[]
    OR?: capacidad_lineasWhereInput[]
    NOT?: capacidad_lineasWhereInput | capacidad_lineasWhereInput[]
    cod_linea?: StringNullableFilter<"capacidad_lineas"> | string | null
    cod_esp?: StringNullableFilter<"capacidad_lineas"> | string | null
    nro_vias?: IntNullableFilter<"capacidad_lineas"> | number | null
    capacidad_vias?: DecimalNullableFilter<"capacidad_lineas"> | Decimal | DecimalJsLike | number | string | null
  }, "id">

  export type capacidad_lineasOrderByWithAggregationInput = {
    id?: SortOrder
    cod_linea?: SortOrderInput | SortOrder
    cod_esp?: SortOrderInput | SortOrder
    nro_vias?: SortOrderInput | SortOrder
    capacidad_vias?: SortOrderInput | SortOrder
    _count?: capacidad_lineasCountOrderByAggregateInput
    _avg?: capacidad_lineasAvgOrderByAggregateInput
    _max?: capacidad_lineasMaxOrderByAggregateInput
    _min?: capacidad_lineasMinOrderByAggregateInput
    _sum?: capacidad_lineasSumOrderByAggregateInput
  }

  export type capacidad_lineasScalarWhereWithAggregatesInput = {
    AND?: capacidad_lineasScalarWhereWithAggregatesInput | capacidad_lineasScalarWhereWithAggregatesInput[]
    OR?: capacidad_lineasScalarWhereWithAggregatesInput[]
    NOT?: capacidad_lineasScalarWhereWithAggregatesInput | capacidad_lineasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"capacidad_lineas"> | number
    cod_linea?: StringNullableWithAggregatesFilter<"capacidad_lineas"> | string | null
    cod_esp?: StringNullableWithAggregatesFilter<"capacidad_lineas"> | string | null
    nro_vias?: IntNullableWithAggregatesFilter<"capacidad_lineas"> | number | null
    capacidad_vias?: DecimalNullableWithAggregatesFilter<"capacidad_lineas"> | Decimal | DecimalJsLike | number | string | null
  }

  export type cc_checklistWhereInput = {
    AND?: cc_checklistWhereInput | cc_checklistWhereInput[]
    OR?: cc_checklistWhereInput[]
    NOT?: cc_checklistWhereInput | cc_checklistWhereInput[]
    id?: IntFilter<"cc_checklist"> | number
    n_proceso?: IntNullableFilter<"cc_checklist"> | number | null
    cod_esp?: StringNullableFilter<"cc_checklist"> | string | null
    cod_var?: StringNullableFilter<"cc_checklist"> | string | null
    cod_pro?: StringNullableFilter<"cc_checklist"> | string | null
    cod_linea?: StringNullableFilter<"cc_checklist"> | string | null
    fecha?: DateTimeNullableFilter<"cc_checklist"> | Date | string | null
    cal_encerado?: StringNullableFilter<"cc_checklist"> | string | null
    porc_exp?: IntNullableFilter<"cc_checklist"> | number | null
    cal_cajas?: StringNullableFilter<"cc_checklist"> | string | null
    porc_plu_c?: StringNullableFilter<"cc_checklist"> | string | null
    peso_caj?: DecimalNullableFilter<"cc_checklist"> | Decimal | DecimalJsLike | number | string | null
    cal_palet?: StringNullableFilter<"cc_checklist"> | string | null
    saturacion?: StringNullableFilter<"cc_checklist"> | string | null
    porc_exp_c?: StringNullableFilter<"cc_checklist"> | string | null
    usuario?: StringNullableFilter<"cc_checklist"> | string | null
    porc_plu?: IntNullableFilter<"cc_checklist"> | number | null
    cod_emp?: StringNullableFilter<"cc_checklist"> | string | null
    cod_tem?: StringNullableFilter<"cc_checklist"> | string | null
    cod_envop?: StringNullableFilter<"cc_checklist"> | string | null
    peso_c?: StringNullableFilter<"cc_checklist"> | string | null
    fec_muestra?: DateTimeNullableFilter<"cc_checklist"> | Date | string | null
  }

  export type cc_checklistOrderByWithRelationInput = {
    id?: SortOrder
    n_proceso?: SortOrderInput | SortOrder
    cod_esp?: SortOrderInput | SortOrder
    cod_var?: SortOrderInput | SortOrder
    cod_pro?: SortOrderInput | SortOrder
    cod_linea?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    cal_encerado?: SortOrderInput | SortOrder
    porc_exp?: SortOrderInput | SortOrder
    cal_cajas?: SortOrderInput | SortOrder
    porc_plu_c?: SortOrderInput | SortOrder
    peso_caj?: SortOrderInput | SortOrder
    cal_palet?: SortOrderInput | SortOrder
    saturacion?: SortOrderInput | SortOrder
    porc_exp_c?: SortOrderInput | SortOrder
    usuario?: SortOrderInput | SortOrder
    porc_plu?: SortOrderInput | SortOrder
    cod_emp?: SortOrderInput | SortOrder
    cod_tem?: SortOrderInput | SortOrder
    cod_envop?: SortOrderInput | SortOrder
    peso_c?: SortOrderInput | SortOrder
    fec_muestra?: SortOrderInput | SortOrder
  }

  export type cc_checklistWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: cc_checklistWhereInput | cc_checklistWhereInput[]
    OR?: cc_checklistWhereInput[]
    NOT?: cc_checklistWhereInput | cc_checklistWhereInput[]
    n_proceso?: IntNullableFilter<"cc_checklist"> | number | null
    cod_esp?: StringNullableFilter<"cc_checklist"> | string | null
    cod_var?: StringNullableFilter<"cc_checklist"> | string | null
    cod_pro?: StringNullableFilter<"cc_checklist"> | string | null
    cod_linea?: StringNullableFilter<"cc_checklist"> | string | null
    fecha?: DateTimeNullableFilter<"cc_checklist"> | Date | string | null
    cal_encerado?: StringNullableFilter<"cc_checklist"> | string | null
    porc_exp?: IntNullableFilter<"cc_checklist"> | number | null
    cal_cajas?: StringNullableFilter<"cc_checklist"> | string | null
    porc_plu_c?: StringNullableFilter<"cc_checklist"> | string | null
    peso_caj?: DecimalNullableFilter<"cc_checklist"> | Decimal | DecimalJsLike | number | string | null
    cal_palet?: StringNullableFilter<"cc_checklist"> | string | null
    saturacion?: StringNullableFilter<"cc_checklist"> | string | null
    porc_exp_c?: StringNullableFilter<"cc_checklist"> | string | null
    usuario?: StringNullableFilter<"cc_checklist"> | string | null
    porc_plu?: IntNullableFilter<"cc_checklist"> | number | null
    cod_emp?: StringNullableFilter<"cc_checklist"> | string | null
    cod_tem?: StringNullableFilter<"cc_checklist"> | string | null
    cod_envop?: StringNullableFilter<"cc_checklist"> | string | null
    peso_c?: StringNullableFilter<"cc_checklist"> | string | null
    fec_muestra?: DateTimeNullableFilter<"cc_checklist"> | Date | string | null
  }, "id">

  export type cc_checklistOrderByWithAggregationInput = {
    id?: SortOrder
    n_proceso?: SortOrderInput | SortOrder
    cod_esp?: SortOrderInput | SortOrder
    cod_var?: SortOrderInput | SortOrder
    cod_pro?: SortOrderInput | SortOrder
    cod_linea?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    cal_encerado?: SortOrderInput | SortOrder
    porc_exp?: SortOrderInput | SortOrder
    cal_cajas?: SortOrderInput | SortOrder
    porc_plu_c?: SortOrderInput | SortOrder
    peso_caj?: SortOrderInput | SortOrder
    cal_palet?: SortOrderInput | SortOrder
    saturacion?: SortOrderInput | SortOrder
    porc_exp_c?: SortOrderInput | SortOrder
    usuario?: SortOrderInput | SortOrder
    porc_plu?: SortOrderInput | SortOrder
    cod_emp?: SortOrderInput | SortOrder
    cod_tem?: SortOrderInput | SortOrder
    cod_envop?: SortOrderInput | SortOrder
    peso_c?: SortOrderInput | SortOrder
    fec_muestra?: SortOrderInput | SortOrder
    _count?: cc_checklistCountOrderByAggregateInput
    _avg?: cc_checklistAvgOrderByAggregateInput
    _max?: cc_checklistMaxOrderByAggregateInput
    _min?: cc_checklistMinOrderByAggregateInput
    _sum?: cc_checklistSumOrderByAggregateInput
  }

  export type cc_checklistScalarWhereWithAggregatesInput = {
    AND?: cc_checklistScalarWhereWithAggregatesInput | cc_checklistScalarWhereWithAggregatesInput[]
    OR?: cc_checklistScalarWhereWithAggregatesInput[]
    NOT?: cc_checklistScalarWhereWithAggregatesInput | cc_checklistScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cc_checklist"> | number
    n_proceso?: IntNullableWithAggregatesFilter<"cc_checklist"> | number | null
    cod_esp?: StringNullableWithAggregatesFilter<"cc_checklist"> | string | null
    cod_var?: StringNullableWithAggregatesFilter<"cc_checklist"> | string | null
    cod_pro?: StringNullableWithAggregatesFilter<"cc_checklist"> | string | null
    cod_linea?: StringNullableWithAggregatesFilter<"cc_checklist"> | string | null
    fecha?: DateTimeNullableWithAggregatesFilter<"cc_checklist"> | Date | string | null
    cal_encerado?: StringNullableWithAggregatesFilter<"cc_checklist"> | string | null
    porc_exp?: IntNullableWithAggregatesFilter<"cc_checklist"> | number | null
    cal_cajas?: StringNullableWithAggregatesFilter<"cc_checklist"> | string | null
    porc_plu_c?: StringNullableWithAggregatesFilter<"cc_checklist"> | string | null
    peso_caj?: DecimalNullableWithAggregatesFilter<"cc_checklist"> | Decimal | DecimalJsLike | number | string | null
    cal_palet?: StringNullableWithAggregatesFilter<"cc_checklist"> | string | null
    saturacion?: StringNullableWithAggregatesFilter<"cc_checklist"> | string | null
    porc_exp_c?: StringNullableWithAggregatesFilter<"cc_checklist"> | string | null
    usuario?: StringNullableWithAggregatesFilter<"cc_checklist"> | string | null
    porc_plu?: IntNullableWithAggregatesFilter<"cc_checklist"> | number | null
    cod_emp?: StringNullableWithAggregatesFilter<"cc_checklist"> | string | null
    cod_tem?: StringNullableWithAggregatesFilter<"cc_checklist"> | string | null
    cod_envop?: StringNullableWithAggregatesFilter<"cc_checklist"> | string | null
    peso_c?: StringNullableWithAggregatesFilter<"cc_checklist"> | string | null
    fec_muestra?: DateTimeNullableWithAggregatesFilter<"cc_checklist"> | Date | string | null
  }

  export type certificacionWhereInput = {
    AND?: certificacionWhereInput | certificacionWhereInput[]
    OR?: certificacionWhereInput[]
    NOT?: certificacionWhereInput | certificacionWhereInput[]
    id?: IntFilter<"certificacion"> | number
    exportadora?: StringFilter<"certificacion"> | string
    productor?: StringFilter<"certificacion"> | string
    ggn?: StringFilter<"certificacion"> | string
    fecha_emision?: DateTimeFilter<"certificacion"> | Date | string
    fecha_caducidad?: DateTimeFilter<"certificacion"> | Date | string
    vigencia?: StringFilter<"certificacion"> | string
    especie?: StringFilter<"certificacion"> | string
    mercados?: StringFilter<"certificacion"> | string
  }

  export type certificacionOrderByWithRelationInput = {
    id?: SortOrder
    exportadora?: SortOrder
    productor?: SortOrder
    ggn?: SortOrder
    fecha_emision?: SortOrder
    fecha_caducidad?: SortOrder
    vigencia?: SortOrder
    especie?: SortOrder
    mercados?: SortOrder
  }

  export type certificacionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: certificacionWhereInput | certificacionWhereInput[]
    OR?: certificacionWhereInput[]
    NOT?: certificacionWhereInput | certificacionWhereInput[]
    exportadora?: StringFilter<"certificacion"> | string
    productor?: StringFilter<"certificacion"> | string
    ggn?: StringFilter<"certificacion"> | string
    fecha_emision?: DateTimeFilter<"certificacion"> | Date | string
    fecha_caducidad?: DateTimeFilter<"certificacion"> | Date | string
    vigencia?: StringFilter<"certificacion"> | string
    especie?: StringFilter<"certificacion"> | string
    mercados?: StringFilter<"certificacion"> | string
  }, "id">

  export type certificacionOrderByWithAggregationInput = {
    id?: SortOrder
    exportadora?: SortOrder
    productor?: SortOrder
    ggn?: SortOrder
    fecha_emision?: SortOrder
    fecha_caducidad?: SortOrder
    vigencia?: SortOrder
    especie?: SortOrder
    mercados?: SortOrder
    _count?: certificacionCountOrderByAggregateInput
    _avg?: certificacionAvgOrderByAggregateInput
    _max?: certificacionMaxOrderByAggregateInput
    _min?: certificacionMinOrderByAggregateInput
    _sum?: certificacionSumOrderByAggregateInput
  }

  export type certificacionScalarWhereWithAggregatesInput = {
    AND?: certificacionScalarWhereWithAggregatesInput | certificacionScalarWhereWithAggregatesInput[]
    OR?: certificacionScalarWhereWithAggregatesInput[]
    NOT?: certificacionScalarWhereWithAggregatesInput | certificacionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"certificacion"> | number
    exportadora?: StringWithAggregatesFilter<"certificacion"> | string
    productor?: StringWithAggregatesFilter<"certificacion"> | string
    ggn?: StringWithAggregatesFilter<"certificacion"> | string
    fecha_emision?: DateTimeWithAggregatesFilter<"certificacion"> | Date | string
    fecha_caducidad?: DateTimeWithAggregatesFilter<"certificacion"> | Date | string
    vigencia?: StringWithAggregatesFilter<"certificacion"> | string
    especie?: StringWithAggregatesFilter<"certificacion"> | string
    mercados?: StringWithAggregatesFilter<"certificacion"> | string
  }

  export type correlativoWhereInput = {
    AND?: correlativoWhereInput | correlativoWhereInput[]
    OR?: correlativoWhereInput[]
    NOT?: correlativoWhereInput | correlativoWhereInput[]
    id_cor?: IntFilter<"correlativo"> | number
    id_tip_ins?: IntNullableFilter<"correlativo"> | number | null
    nro_sag?: IntNullableFilter<"correlativo"> | number | null
    cod_sdp?: StringNullableFilter<"correlativo"> | string | null
  }

  export type correlativoOrderByWithRelationInput = {
    id_cor?: SortOrder
    id_tip_ins?: SortOrderInput | SortOrder
    nro_sag?: SortOrderInput | SortOrder
    cod_sdp?: SortOrderInput | SortOrder
  }

  export type correlativoWhereUniqueInput = Prisma.AtLeast<{
    id_cor?: number
    AND?: correlativoWhereInput | correlativoWhereInput[]
    OR?: correlativoWhereInput[]
    NOT?: correlativoWhereInput | correlativoWhereInput[]
    id_tip_ins?: IntNullableFilter<"correlativo"> | number | null
    nro_sag?: IntNullableFilter<"correlativo"> | number | null
    cod_sdp?: StringNullableFilter<"correlativo"> | string | null
  }, "id_cor">

  export type correlativoOrderByWithAggregationInput = {
    id_cor?: SortOrder
    id_tip_ins?: SortOrderInput | SortOrder
    nro_sag?: SortOrderInput | SortOrder
    cod_sdp?: SortOrderInput | SortOrder
    _count?: correlativoCountOrderByAggregateInput
    _avg?: correlativoAvgOrderByAggregateInput
    _max?: correlativoMaxOrderByAggregateInput
    _min?: correlativoMinOrderByAggregateInput
    _sum?: correlativoSumOrderByAggregateInput
  }

  export type correlativoScalarWhereWithAggregatesInput = {
    AND?: correlativoScalarWhereWithAggregatesInput | correlativoScalarWhereWithAggregatesInput[]
    OR?: correlativoScalarWhereWithAggregatesInput[]
    NOT?: correlativoScalarWhereWithAggregatesInput | correlativoScalarWhereWithAggregatesInput[]
    id_cor?: IntWithAggregatesFilter<"correlativo"> | number
    id_tip_ins?: IntNullableWithAggregatesFilter<"correlativo"> | number | null
    nro_sag?: IntNullableWithAggregatesFilter<"correlativo"> | number | null
    cod_sdp?: StringNullableWithAggregatesFilter<"correlativo"> | string | null
  }

  export type env_x_sellarWhereInput = {
    AND?: env_x_sellarWhereInput | env_x_sellarWhereInput[]
    OR?: env_x_sellarWhereInput[]
    NOT?: env_x_sellarWhereInput | env_x_sellarWhereInput[]
    id?: IntFilter<"env_x_sellar"> | number
    cod_envop?: StringFilter<"env_x_sellar"> | string
    cod_esp?: StringFilter<"env_x_sellar"> | string
    cod_exp?: StringFilter<"env_x_sellar"> | string
  }

  export type env_x_sellarOrderByWithRelationInput = {
    id?: SortOrder
    cod_envop?: SortOrder
    cod_esp?: SortOrder
    cod_exp?: SortOrder
  }

  export type env_x_sellarWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: env_x_sellarWhereInput | env_x_sellarWhereInput[]
    OR?: env_x_sellarWhereInput[]
    NOT?: env_x_sellarWhereInput | env_x_sellarWhereInput[]
    cod_envop?: StringFilter<"env_x_sellar"> | string
    cod_esp?: StringFilter<"env_x_sellar"> | string
    cod_exp?: StringFilter<"env_x_sellar"> | string
  }, "id">

  export type env_x_sellarOrderByWithAggregationInput = {
    id?: SortOrder
    cod_envop?: SortOrder
    cod_esp?: SortOrder
    cod_exp?: SortOrder
    _count?: env_x_sellarCountOrderByAggregateInput
    _avg?: env_x_sellarAvgOrderByAggregateInput
    _max?: env_x_sellarMaxOrderByAggregateInput
    _min?: env_x_sellarMinOrderByAggregateInput
    _sum?: env_x_sellarSumOrderByAggregateInput
  }

  export type env_x_sellarScalarWhereWithAggregatesInput = {
    AND?: env_x_sellarScalarWhereWithAggregatesInput | env_x_sellarScalarWhereWithAggregatesInput[]
    OR?: env_x_sellarScalarWhereWithAggregatesInput[]
    NOT?: env_x_sellarScalarWhereWithAggregatesInput | env_x_sellarScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"env_x_sellar"> | number
    cod_envop?: StringWithAggregatesFilter<"env_x_sellar"> | string
    cod_esp?: StringWithAggregatesFilter<"env_x_sellar"> | string
    cod_exp?: StringWithAggregatesFilter<"env_x_sellar"> | string
  }

  export type estadosWhereInput = {
    AND?: estadosWhereInput | estadosWhereInput[]
    OR?: estadosWhereInput[]
    NOT?: estadosWhereInput | estadosWhereInput[]
    id_est_ins?: IntFilter<"estados"> | number
    des_est_ins?: StringNullableFilter<"estados"> | string | null
    tip_sdt?: StringNullableFilter<"estados"> | string | null
    id_tip_ins?: IntNullableFilter<"estados"> | number | null
  }

  export type estadosOrderByWithRelationInput = {
    id_est_ins?: SortOrder
    des_est_ins?: SortOrderInput | SortOrder
    tip_sdt?: SortOrderInput | SortOrder
    id_tip_ins?: SortOrderInput | SortOrder
  }

  export type estadosWhereUniqueInput = Prisma.AtLeast<{
    id_est_ins?: number
    AND?: estadosWhereInput | estadosWhereInput[]
    OR?: estadosWhereInput[]
    NOT?: estadosWhereInput | estadosWhereInput[]
    des_est_ins?: StringNullableFilter<"estados"> | string | null
    tip_sdt?: StringNullableFilter<"estados"> | string | null
    id_tip_ins?: IntNullableFilter<"estados"> | number | null
  }, "id_est_ins">

  export type estadosOrderByWithAggregationInput = {
    id_est_ins?: SortOrder
    des_est_ins?: SortOrderInput | SortOrder
    tip_sdt?: SortOrderInput | SortOrder
    id_tip_ins?: SortOrderInput | SortOrder
    _count?: estadosCountOrderByAggregateInput
    _avg?: estadosAvgOrderByAggregateInput
    _max?: estadosMaxOrderByAggregateInput
    _min?: estadosMinOrderByAggregateInput
    _sum?: estadosSumOrderByAggregateInput
  }

  export type estadosScalarWhereWithAggregatesInput = {
    AND?: estadosScalarWhereWithAggregatesInput | estadosScalarWhereWithAggregatesInput[]
    OR?: estadosScalarWhereWithAggregatesInput[]
    NOT?: estadosScalarWhereWithAggregatesInput | estadosScalarWhereWithAggregatesInput[]
    id_est_ins?: IntWithAggregatesFilter<"estados"> | number
    des_est_ins?: StringNullableWithAggregatesFilter<"estados"> | string | null
    tip_sdt?: StringNullableWithAggregatesFilter<"estados"> | string | null
    id_tip_ins?: IntNullableWithAggregatesFilter<"estados"> | number | null
  }

  export type foliosWhereInput = {
    AND?: foliosWhereInput | foliosWhereInput[]
    OR?: foliosWhereInput[]
    NOT?: foliosWhereInput | foliosWhereInput[]
    folio?: StringFilter<"folios"> | string
    nom_var?: StringNullableFilter<"folios"> | string | null
    cod_var?: StringNullableFilter<"folios"> | string | null
    cajas?: IntNullableFilter<"folios"> | number | null
    fecha?: DateTimeNullableFilter<"folios"> | Date | string | null
    calibre?: StringNullableFilter<"folios"> | string | null
    embalaje?: StringNullableFilter<"folios"> | string | null
  }

  export type foliosOrderByWithRelationInput = {
    folio?: SortOrder
    nom_var?: SortOrderInput | SortOrder
    cod_var?: SortOrderInput | SortOrder
    cajas?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    calibre?: SortOrderInput | SortOrder
    embalaje?: SortOrderInput | SortOrder
  }

  export type foliosWhereUniqueInput = Prisma.AtLeast<{
    folio?: string
    AND?: foliosWhereInput | foliosWhereInput[]
    OR?: foliosWhereInput[]
    NOT?: foliosWhereInput | foliosWhereInput[]
    nom_var?: StringNullableFilter<"folios"> | string | null
    cod_var?: StringNullableFilter<"folios"> | string | null
    cajas?: IntNullableFilter<"folios"> | number | null
    fecha?: DateTimeNullableFilter<"folios"> | Date | string | null
    calibre?: StringNullableFilter<"folios"> | string | null
    embalaje?: StringNullableFilter<"folios"> | string | null
  }, "folio">

  export type foliosOrderByWithAggregationInput = {
    folio?: SortOrder
    nom_var?: SortOrderInput | SortOrder
    cod_var?: SortOrderInput | SortOrder
    cajas?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    calibre?: SortOrderInput | SortOrder
    embalaje?: SortOrderInput | SortOrder
    _count?: foliosCountOrderByAggregateInput
    _avg?: foliosAvgOrderByAggregateInput
    _max?: foliosMaxOrderByAggregateInput
    _min?: foliosMinOrderByAggregateInput
    _sum?: foliosSumOrderByAggregateInput
  }

  export type foliosScalarWhereWithAggregatesInput = {
    AND?: foliosScalarWhereWithAggregatesInput | foliosScalarWhereWithAggregatesInput[]
    OR?: foliosScalarWhereWithAggregatesInput[]
    NOT?: foliosScalarWhereWithAggregatesInput | foliosScalarWhereWithAggregatesInput[]
    folio?: StringWithAggregatesFilter<"folios"> | string
    nom_var?: StringNullableWithAggregatesFilter<"folios"> | string | null
    cod_var?: StringNullableWithAggregatesFilter<"folios"> | string | null
    cajas?: IntNullableWithAggregatesFilter<"folios"> | number | null
    fecha?: DateTimeNullableWithAggregatesFilter<"folios"> | Date | string | null
    calibre?: StringNullableWithAggregatesFilter<"folios"> | string | null
    embalaje?: StringNullableWithAggregatesFilter<"folios"> | string | null
  }

  export type folios_frioWhereInput = {
    AND?: folios_frioWhereInput | folios_frioWhereInput[]
    OR?: folios_frioWhereInput[]
    NOT?: folios_frioWhereInput | folios_frioWhereInput[]
    folio?: StringFilter<"folios_frio"> | string
    nom_var?: StringNullableFilter<"folios_frio"> | string | null
    cod_var?: StringNullableFilter<"folios_frio"> | string | null
    cajas?: IntNullableFilter<"folios_frio"> | number | null
    fecha?: DateTimeNullableFilter<"folios_frio"> | Date | string | null
    calibre?: StringNullableFilter<"folios_frio"> | string | null
    embalaje?: StringNullableFilter<"folios_frio"> | string | null
  }

  export type folios_frioOrderByWithRelationInput = {
    folio?: SortOrder
    nom_var?: SortOrderInput | SortOrder
    cod_var?: SortOrderInput | SortOrder
    cajas?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    calibre?: SortOrderInput | SortOrder
    embalaje?: SortOrderInput | SortOrder
  }

  export type folios_frioWhereUniqueInput = Prisma.AtLeast<{
    folio?: string
    AND?: folios_frioWhereInput | folios_frioWhereInput[]
    OR?: folios_frioWhereInput[]
    NOT?: folios_frioWhereInput | folios_frioWhereInput[]
    nom_var?: StringNullableFilter<"folios_frio"> | string | null
    cod_var?: StringNullableFilter<"folios_frio"> | string | null
    cajas?: IntNullableFilter<"folios_frio"> | number | null
    fecha?: DateTimeNullableFilter<"folios_frio"> | Date | string | null
    calibre?: StringNullableFilter<"folios_frio"> | string | null
    embalaje?: StringNullableFilter<"folios_frio"> | string | null
  }, "folio">

  export type folios_frioOrderByWithAggregationInput = {
    folio?: SortOrder
    nom_var?: SortOrderInput | SortOrder
    cod_var?: SortOrderInput | SortOrder
    cajas?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    calibre?: SortOrderInput | SortOrder
    embalaje?: SortOrderInput | SortOrder
    _count?: folios_frioCountOrderByAggregateInput
    _avg?: folios_frioAvgOrderByAggregateInput
    _max?: folios_frioMaxOrderByAggregateInput
    _min?: folios_frioMinOrderByAggregateInput
    _sum?: folios_frioSumOrderByAggregateInput
  }

  export type folios_frioScalarWhereWithAggregatesInput = {
    AND?: folios_frioScalarWhereWithAggregatesInput | folios_frioScalarWhereWithAggregatesInput[]
    OR?: folios_frioScalarWhereWithAggregatesInput[]
    NOT?: folios_frioScalarWhereWithAggregatesInput | folios_frioScalarWhereWithAggregatesInput[]
    folio?: StringWithAggregatesFilter<"folios_frio"> | string
    nom_var?: StringNullableWithAggregatesFilter<"folios_frio"> | string | null
    cod_var?: StringNullableWithAggregatesFilter<"folios_frio"> | string | null
    cajas?: IntNullableWithAggregatesFilter<"folios_frio"> | number | null
    fecha?: DateTimeNullableWithAggregatesFilter<"folios_frio"> | Date | string | null
    calibre?: StringNullableWithAggregatesFilter<"folios_frio"> | string | null
    embalaje?: StringNullableWithAggregatesFilter<"folios_frio"> | string | null
  }

  export type folios_packWhereInput = {
    AND?: folios_packWhereInput | folios_packWhereInput[]
    OR?: folios_packWhereInput[]
    NOT?: folios_packWhereInput | folios_packWhereInput[]
    folio?: StringFilter<"folios_pack"> | string
    nom_var?: StringNullableFilter<"folios_pack"> | string | null
    cod_var?: StringNullableFilter<"folios_pack"> | string | null
    cajas?: IntNullableFilter<"folios_pack"> | number | null
    fecha?: DateTimeNullableFilter<"folios_pack"> | Date | string | null
    calibre?: StringNullableFilter<"folios_pack"> | string | null
    embalaje?: StringNullableFilter<"folios_pack"> | string | null
  }

  export type folios_packOrderByWithRelationInput = {
    folio?: SortOrder
    nom_var?: SortOrderInput | SortOrder
    cod_var?: SortOrderInput | SortOrder
    cajas?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    calibre?: SortOrderInput | SortOrder
    embalaje?: SortOrderInput | SortOrder
  }

  export type folios_packWhereUniqueInput = Prisma.AtLeast<{
    folio?: string
    AND?: folios_packWhereInput | folios_packWhereInput[]
    OR?: folios_packWhereInput[]
    NOT?: folios_packWhereInput | folios_packWhereInput[]
    nom_var?: StringNullableFilter<"folios_pack"> | string | null
    cod_var?: StringNullableFilter<"folios_pack"> | string | null
    cajas?: IntNullableFilter<"folios_pack"> | number | null
    fecha?: DateTimeNullableFilter<"folios_pack"> | Date | string | null
    calibre?: StringNullableFilter<"folios_pack"> | string | null
    embalaje?: StringNullableFilter<"folios_pack"> | string | null
  }, "folio">

  export type folios_packOrderByWithAggregationInput = {
    folio?: SortOrder
    nom_var?: SortOrderInput | SortOrder
    cod_var?: SortOrderInput | SortOrder
    cajas?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    calibre?: SortOrderInput | SortOrder
    embalaje?: SortOrderInput | SortOrder
    _count?: folios_packCountOrderByAggregateInput
    _avg?: folios_packAvgOrderByAggregateInput
    _max?: folios_packMaxOrderByAggregateInput
    _min?: folios_packMinOrderByAggregateInput
    _sum?: folios_packSumOrderByAggregateInput
  }

  export type folios_packScalarWhereWithAggregatesInput = {
    AND?: folios_packScalarWhereWithAggregatesInput | folios_packScalarWhereWithAggregatesInput[]
    OR?: folios_packScalarWhereWithAggregatesInput[]
    NOT?: folios_packScalarWhereWithAggregatesInput | folios_packScalarWhereWithAggregatesInput[]
    folio?: StringWithAggregatesFilter<"folios_pack"> | string
    nom_var?: StringNullableWithAggregatesFilter<"folios_pack"> | string | null
    cod_var?: StringNullableWithAggregatesFilter<"folios_pack"> | string | null
    cajas?: IntNullableWithAggregatesFilter<"folios_pack"> | number | null
    fecha?: DateTimeNullableWithAggregatesFilter<"folios_pack"> | Date | string | null
    calibre?: StringNullableWithAggregatesFilter<"folios_pack"> | string | null
    embalaje?: StringNullableWithAggregatesFilter<"folios_pack"> | string | null
  }

  export type folios_seWhereInput = {
    AND?: folios_seWhereInput | folios_seWhereInput[]
    OR?: folios_seWhereInput[]
    NOT?: folios_seWhereInput | folios_seWhereInput[]
    folio?: StringFilter<"folios_se"> | string
    nom_var?: StringNullableFilter<"folios_se"> | string | null
    cod_var?: StringNullableFilter<"folios_se"> | string | null
    cajas?: IntNullableFilter<"folios_se"> | number | null
    fecha?: DateTimeNullableFilter<"folios_se"> | Date | string | null
    calibre?: StringNullableFilter<"folios_se"> | string | null
    embalaje?: StringNullableFilter<"folios_se"> | string | null
  }

  export type folios_seOrderByWithRelationInput = {
    folio?: SortOrder
    nom_var?: SortOrderInput | SortOrder
    cod_var?: SortOrderInput | SortOrder
    cajas?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    calibre?: SortOrderInput | SortOrder
    embalaje?: SortOrderInput | SortOrder
  }

  export type folios_seWhereUniqueInput = Prisma.AtLeast<{
    folio?: string
    AND?: folios_seWhereInput | folios_seWhereInput[]
    OR?: folios_seWhereInput[]
    NOT?: folios_seWhereInput | folios_seWhereInput[]
    nom_var?: StringNullableFilter<"folios_se"> | string | null
    cod_var?: StringNullableFilter<"folios_se"> | string | null
    cajas?: IntNullableFilter<"folios_se"> | number | null
    fecha?: DateTimeNullableFilter<"folios_se"> | Date | string | null
    calibre?: StringNullableFilter<"folios_se"> | string | null
    embalaje?: StringNullableFilter<"folios_se"> | string | null
  }, "folio">

  export type folios_seOrderByWithAggregationInput = {
    folio?: SortOrder
    nom_var?: SortOrderInput | SortOrder
    cod_var?: SortOrderInput | SortOrder
    cajas?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    calibre?: SortOrderInput | SortOrder
    embalaje?: SortOrderInput | SortOrder
    _count?: folios_seCountOrderByAggregateInput
    _avg?: folios_seAvgOrderByAggregateInput
    _max?: folios_seMaxOrderByAggregateInput
    _min?: folios_seMinOrderByAggregateInput
    _sum?: folios_seSumOrderByAggregateInput
  }

  export type folios_seScalarWhereWithAggregatesInput = {
    AND?: folios_seScalarWhereWithAggregatesInput | folios_seScalarWhereWithAggregatesInput[]
    OR?: folios_seScalarWhereWithAggregatesInput[]
    NOT?: folios_seScalarWhereWithAggregatesInput | folios_seScalarWhereWithAggregatesInput[]
    folio?: StringWithAggregatesFilter<"folios_se"> | string
    nom_var?: StringNullableWithAggregatesFilter<"folios_se"> | string | null
    cod_var?: StringNullableWithAggregatesFilter<"folios_se"> | string | null
    cajas?: IntNullableWithAggregatesFilter<"folios_se"> | number | null
    fecha?: DateTimeNullableWithAggregatesFilter<"folios_se"> | Date | string | null
    calibre?: StringNullableWithAggregatesFilter<"folios_se"> | string | null
    embalaje?: StringNullableWithAggregatesFilter<"folios_se"> | string | null
  }

  export type fr_repa_cabWhereInput = {
    AND?: fr_repa_cabWhereInput | fr_repa_cabWhereInput[]
    OR?: fr_repa_cabWhereInput[]
    NOT?: fr_repa_cabWhereInput | fr_repa_cabWhereInput[]
    id?: IntFilter<"fr_repa_cab"> | number
    fec_rep?: DateTimeNullableFilter<"fr_repa_cab"> | Date | string | null
    id_tip_rep?: IntNullableFilter<"fr_repa_cab"> | number | null
    fr_cod_pac?: StringNullableFilter<"fr_repa_cab"> | string | null
    fr_cod_fri?: StringNullableFilter<"fr_repa_cab"> | string | null
    fr_usu?: StringNullableFilter<"fr_repa_cab"> | string | null
    fr_rep_sag?: BytesNullableFilter<"fr_repa_cab"> | Buffer | null
    fr_cod_tem?: StringNullableFilter<"fr_repa_cab"> | string | null
    fr_cod_emp?: StringNullableFilter<"fr_repa_cab"> | string | null
    fr_tra_sdt?: StringNullableFilter<"fr_repa_cab"> | string | null
    fr_nro_rep?: IntNullableFilter<"fr_repa_cab"> | number | null
    fr_cod_esp?: StringNullableFilter<"fr_repa_cab"> | string | null
  }

  export type fr_repa_cabOrderByWithRelationInput = {
    id?: SortOrder
    fec_rep?: SortOrderInput | SortOrder
    id_tip_rep?: SortOrderInput | SortOrder
    fr_cod_pac?: SortOrderInput | SortOrder
    fr_cod_fri?: SortOrderInput | SortOrder
    fr_usu?: SortOrderInput | SortOrder
    fr_rep_sag?: SortOrderInput | SortOrder
    fr_cod_tem?: SortOrderInput | SortOrder
    fr_cod_emp?: SortOrderInput | SortOrder
    fr_tra_sdt?: SortOrderInput | SortOrder
    fr_nro_rep?: SortOrderInput | SortOrder
    fr_cod_esp?: SortOrderInput | SortOrder
  }

  export type fr_repa_cabWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: fr_repa_cabWhereInput | fr_repa_cabWhereInput[]
    OR?: fr_repa_cabWhereInput[]
    NOT?: fr_repa_cabWhereInput | fr_repa_cabWhereInput[]
    fec_rep?: DateTimeNullableFilter<"fr_repa_cab"> | Date | string | null
    id_tip_rep?: IntNullableFilter<"fr_repa_cab"> | number | null
    fr_cod_pac?: StringNullableFilter<"fr_repa_cab"> | string | null
    fr_cod_fri?: StringNullableFilter<"fr_repa_cab"> | string | null
    fr_usu?: StringNullableFilter<"fr_repa_cab"> | string | null
    fr_rep_sag?: BytesNullableFilter<"fr_repa_cab"> | Buffer | null
    fr_cod_tem?: StringNullableFilter<"fr_repa_cab"> | string | null
    fr_cod_emp?: StringNullableFilter<"fr_repa_cab"> | string | null
    fr_tra_sdt?: StringNullableFilter<"fr_repa_cab"> | string | null
    fr_nro_rep?: IntNullableFilter<"fr_repa_cab"> | number | null
    fr_cod_esp?: StringNullableFilter<"fr_repa_cab"> | string | null
  }, "id">

  export type fr_repa_cabOrderByWithAggregationInput = {
    id?: SortOrder
    fec_rep?: SortOrderInput | SortOrder
    id_tip_rep?: SortOrderInput | SortOrder
    fr_cod_pac?: SortOrderInput | SortOrder
    fr_cod_fri?: SortOrderInput | SortOrder
    fr_usu?: SortOrderInput | SortOrder
    fr_rep_sag?: SortOrderInput | SortOrder
    fr_cod_tem?: SortOrderInput | SortOrder
    fr_cod_emp?: SortOrderInput | SortOrder
    fr_tra_sdt?: SortOrderInput | SortOrder
    fr_nro_rep?: SortOrderInput | SortOrder
    fr_cod_esp?: SortOrderInput | SortOrder
    _count?: fr_repa_cabCountOrderByAggregateInput
    _avg?: fr_repa_cabAvgOrderByAggregateInput
    _max?: fr_repa_cabMaxOrderByAggregateInput
    _min?: fr_repa_cabMinOrderByAggregateInput
    _sum?: fr_repa_cabSumOrderByAggregateInput
  }

  export type fr_repa_cabScalarWhereWithAggregatesInput = {
    AND?: fr_repa_cabScalarWhereWithAggregatesInput | fr_repa_cabScalarWhereWithAggregatesInput[]
    OR?: fr_repa_cabScalarWhereWithAggregatesInput[]
    NOT?: fr_repa_cabScalarWhereWithAggregatesInput | fr_repa_cabScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"fr_repa_cab"> | number
    fec_rep?: DateTimeNullableWithAggregatesFilter<"fr_repa_cab"> | Date | string | null
    id_tip_rep?: IntNullableWithAggregatesFilter<"fr_repa_cab"> | number | null
    fr_cod_pac?: StringNullableWithAggregatesFilter<"fr_repa_cab"> | string | null
    fr_cod_fri?: StringNullableWithAggregatesFilter<"fr_repa_cab"> | string | null
    fr_usu?: StringNullableWithAggregatesFilter<"fr_repa_cab"> | string | null
    fr_rep_sag?: BytesNullableWithAggregatesFilter<"fr_repa_cab"> | Buffer | null
    fr_cod_tem?: StringNullableWithAggregatesFilter<"fr_repa_cab"> | string | null
    fr_cod_emp?: StringNullableWithAggregatesFilter<"fr_repa_cab"> | string | null
    fr_tra_sdt?: StringNullableWithAggregatesFilter<"fr_repa_cab"> | string | null
    fr_nro_rep?: IntNullableWithAggregatesFilter<"fr_repa_cab"> | number | null
    fr_cod_esp?: StringNullableWithAggregatesFilter<"fr_repa_cab"> | string | null
  }

  export type fr_repa_detWhereInput = {
    AND?: fr_repa_detWhereInput | fr_repa_detWhereInput[]
    OR?: fr_repa_detWhereInput[]
    NOT?: fr_repa_detWhereInput | fr_repa_detWhereInput[]
    id?: IntFilter<"fr_repa_det"> | number
    id_rep_cab?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_lote?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cor_sdt?: DecimalNullableFilter<"fr_repa_det"> | Decimal | DecimalJsLike | number | string | null
    fr_pla_sdt?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_est_sdt?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_fec_pac?: DateTimeNullableFilter<"fr_repa_det"> | Date | string | null
    fr_fec_rpa?: DateTimeNullableFilter<"fr_repa_det"> | Date | string | null
    fr_gui_sdt?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_cod_pro?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_esp?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_var?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_hor_rec?: DateTimeNullableFilter<"fr_repa_det"> | Date | string | null
    fr_con?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_tip_lot?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_alt_pal?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_env?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_eti?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_emb?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_envop?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_plu?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_caj?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_cod_cat?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_cal?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_nro_mix?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_fec_sem?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_bp?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_pre?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_cua?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_proceso?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_con_fri?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_fol_ori?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_var_eti?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_tip_tra?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_pro_eti?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_exp?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_pk_ori?: IntNullableFilter<"fr_repa_det"> | number | null
    id_tip_io?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_caj_usa?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_tip_mov?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_fec_sag?: DateTimeNullableFilter<"fr_repa_det"> | Date | string | null
    fr_guia_sag?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_cer_sag?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_sol_sag?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_tip_sag?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_mer?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_mer1?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_mer2?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_mer3?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_mer4?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_fec_fum?: DateTimeNullableFilter<"fr_repa_det"> | Date | string | null
    fr_guia_fum?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_cer_fum?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_tipo_fum?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_pfrio?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_correlativo_rec?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_cod_linea?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_peso_original?: DecimalNullableFilter<"fr_repa_det"> | Decimal | DecimalJsLike | number | string | null
  }

  export type fr_repa_detOrderByWithRelationInput = {
    id?: SortOrder
    id_rep_cab?: SortOrderInput | SortOrder
    fr_lote?: SortOrderInput | SortOrder
    fr_cor_sdt?: SortOrderInput | SortOrder
    fr_pla_sdt?: SortOrderInput | SortOrder
    fr_est_sdt?: SortOrderInput | SortOrder
    fr_fec_pac?: SortOrderInput | SortOrder
    fr_fec_rpa?: SortOrderInput | SortOrder
    fr_gui_sdt?: SortOrderInput | SortOrder
    fr_cod_pro?: SortOrderInput | SortOrder
    fr_cod_esp?: SortOrderInput | SortOrder
    fr_cod_var?: SortOrderInput | SortOrder
    fr_hor_rec?: SortOrderInput | SortOrder
    fr_con?: SortOrderInput | SortOrder
    fr_tip_lot?: SortOrderInput | SortOrder
    fr_alt_pal?: SortOrderInput | SortOrder
    fr_cod_env?: SortOrderInput | SortOrder
    fr_cod_eti?: SortOrderInput | SortOrder
    fr_cod_emb?: SortOrderInput | SortOrder
    fr_cod_envop?: SortOrderInput | SortOrder
    fr_plu?: SortOrderInput | SortOrder
    fr_caj?: SortOrderInput | SortOrder
    fr_cod_cat?: SortOrderInput | SortOrder
    fr_cod_cal?: SortOrderInput | SortOrder
    fr_nro_mix?: SortOrderInput | SortOrder
    fr_fec_sem?: SortOrderInput | SortOrder
    fr_cod_bp?: SortOrderInput | SortOrder
    fr_cod_pre?: SortOrderInput | SortOrder
    fr_cod_cua?: SortOrderInput | SortOrder
    fr_proceso?: SortOrderInput | SortOrder
    fr_con_fri?: SortOrderInput | SortOrder
    fr_fol_ori?: SortOrderInput | SortOrder
    fr_cod_var_eti?: SortOrderInput | SortOrder
    fr_cod_tip_tra?: SortOrderInput | SortOrder
    fr_cod_pro_eti?: SortOrderInput | SortOrder
    fr_cod_exp?: SortOrderInput | SortOrder
    fr_pk_ori?: SortOrderInput | SortOrder
    id_tip_io?: SortOrderInput | SortOrder
    fr_caj_usa?: SortOrderInput | SortOrder
    fr_tip_mov?: SortOrderInput | SortOrder
    fr_fec_sag?: SortOrderInput | SortOrder
    fr_guia_sag?: SortOrderInput | SortOrder
    fr_cer_sag?: SortOrderInput | SortOrder
    fr_sol_sag?: SortOrderInput | SortOrder
    fr_tip_sag?: SortOrderInput | SortOrder
    fr_cod_mer?: SortOrderInput | SortOrder
    fr_cod_mer1?: SortOrderInput | SortOrder
    fr_cod_mer2?: SortOrderInput | SortOrder
    fr_cod_mer3?: SortOrderInput | SortOrder
    fr_cod_mer4?: SortOrderInput | SortOrder
    fr_fec_fum?: SortOrderInput | SortOrder
    fr_guia_fum?: SortOrderInput | SortOrder
    fr_cer_fum?: SortOrderInput | SortOrder
    fr_cod_tipo_fum?: SortOrderInput | SortOrder
    fr_pfrio?: SortOrderInput | SortOrder
    fr_correlativo_rec?: SortOrderInput | SortOrder
    fr_cod_linea?: SortOrderInput | SortOrder
    fr_peso_original?: SortOrderInput | SortOrder
  }

  export type fr_repa_detWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: fr_repa_detWhereInput | fr_repa_detWhereInput[]
    OR?: fr_repa_detWhereInput[]
    NOT?: fr_repa_detWhereInput | fr_repa_detWhereInput[]
    id_rep_cab?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_lote?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cor_sdt?: DecimalNullableFilter<"fr_repa_det"> | Decimal | DecimalJsLike | number | string | null
    fr_pla_sdt?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_est_sdt?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_fec_pac?: DateTimeNullableFilter<"fr_repa_det"> | Date | string | null
    fr_fec_rpa?: DateTimeNullableFilter<"fr_repa_det"> | Date | string | null
    fr_gui_sdt?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_cod_pro?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_esp?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_var?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_hor_rec?: DateTimeNullableFilter<"fr_repa_det"> | Date | string | null
    fr_con?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_tip_lot?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_alt_pal?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_env?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_eti?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_emb?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_envop?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_plu?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_caj?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_cod_cat?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_cal?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_nro_mix?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_fec_sem?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_bp?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_pre?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_cua?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_proceso?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_con_fri?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_fol_ori?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_var_eti?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_tip_tra?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_pro_eti?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_exp?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_pk_ori?: IntNullableFilter<"fr_repa_det"> | number | null
    id_tip_io?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_caj_usa?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_tip_mov?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_fec_sag?: DateTimeNullableFilter<"fr_repa_det"> | Date | string | null
    fr_guia_sag?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_cer_sag?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_sol_sag?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_tip_sag?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_mer?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_mer1?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_mer2?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_mer3?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_mer4?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_fec_fum?: DateTimeNullableFilter<"fr_repa_det"> | Date | string | null
    fr_guia_fum?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_cer_fum?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_cod_tipo_fum?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_pfrio?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_correlativo_rec?: IntNullableFilter<"fr_repa_det"> | number | null
    fr_cod_linea?: StringNullableFilter<"fr_repa_det"> | string | null
    fr_peso_original?: DecimalNullableFilter<"fr_repa_det"> | Decimal | DecimalJsLike | number | string | null
  }, "id">

  export type fr_repa_detOrderByWithAggregationInput = {
    id?: SortOrder
    id_rep_cab?: SortOrderInput | SortOrder
    fr_lote?: SortOrderInput | SortOrder
    fr_cor_sdt?: SortOrderInput | SortOrder
    fr_pla_sdt?: SortOrderInput | SortOrder
    fr_est_sdt?: SortOrderInput | SortOrder
    fr_fec_pac?: SortOrderInput | SortOrder
    fr_fec_rpa?: SortOrderInput | SortOrder
    fr_gui_sdt?: SortOrderInput | SortOrder
    fr_cod_pro?: SortOrderInput | SortOrder
    fr_cod_esp?: SortOrderInput | SortOrder
    fr_cod_var?: SortOrderInput | SortOrder
    fr_hor_rec?: SortOrderInput | SortOrder
    fr_con?: SortOrderInput | SortOrder
    fr_tip_lot?: SortOrderInput | SortOrder
    fr_alt_pal?: SortOrderInput | SortOrder
    fr_cod_env?: SortOrderInput | SortOrder
    fr_cod_eti?: SortOrderInput | SortOrder
    fr_cod_emb?: SortOrderInput | SortOrder
    fr_cod_envop?: SortOrderInput | SortOrder
    fr_plu?: SortOrderInput | SortOrder
    fr_caj?: SortOrderInput | SortOrder
    fr_cod_cat?: SortOrderInput | SortOrder
    fr_cod_cal?: SortOrderInput | SortOrder
    fr_nro_mix?: SortOrderInput | SortOrder
    fr_fec_sem?: SortOrderInput | SortOrder
    fr_cod_bp?: SortOrderInput | SortOrder
    fr_cod_pre?: SortOrderInput | SortOrder
    fr_cod_cua?: SortOrderInput | SortOrder
    fr_proceso?: SortOrderInput | SortOrder
    fr_con_fri?: SortOrderInput | SortOrder
    fr_fol_ori?: SortOrderInput | SortOrder
    fr_cod_var_eti?: SortOrderInput | SortOrder
    fr_cod_tip_tra?: SortOrderInput | SortOrder
    fr_cod_pro_eti?: SortOrderInput | SortOrder
    fr_cod_exp?: SortOrderInput | SortOrder
    fr_pk_ori?: SortOrderInput | SortOrder
    id_tip_io?: SortOrderInput | SortOrder
    fr_caj_usa?: SortOrderInput | SortOrder
    fr_tip_mov?: SortOrderInput | SortOrder
    fr_fec_sag?: SortOrderInput | SortOrder
    fr_guia_sag?: SortOrderInput | SortOrder
    fr_cer_sag?: SortOrderInput | SortOrder
    fr_sol_sag?: SortOrderInput | SortOrder
    fr_tip_sag?: SortOrderInput | SortOrder
    fr_cod_mer?: SortOrderInput | SortOrder
    fr_cod_mer1?: SortOrderInput | SortOrder
    fr_cod_mer2?: SortOrderInput | SortOrder
    fr_cod_mer3?: SortOrderInput | SortOrder
    fr_cod_mer4?: SortOrderInput | SortOrder
    fr_fec_fum?: SortOrderInput | SortOrder
    fr_guia_fum?: SortOrderInput | SortOrder
    fr_cer_fum?: SortOrderInput | SortOrder
    fr_cod_tipo_fum?: SortOrderInput | SortOrder
    fr_pfrio?: SortOrderInput | SortOrder
    fr_correlativo_rec?: SortOrderInput | SortOrder
    fr_cod_linea?: SortOrderInput | SortOrder
    fr_peso_original?: SortOrderInput | SortOrder
    _count?: fr_repa_detCountOrderByAggregateInput
    _avg?: fr_repa_detAvgOrderByAggregateInput
    _max?: fr_repa_detMaxOrderByAggregateInput
    _min?: fr_repa_detMinOrderByAggregateInput
    _sum?: fr_repa_detSumOrderByAggregateInput
  }

  export type fr_repa_detScalarWhereWithAggregatesInput = {
    AND?: fr_repa_detScalarWhereWithAggregatesInput | fr_repa_detScalarWhereWithAggregatesInput[]
    OR?: fr_repa_detScalarWhereWithAggregatesInput[]
    NOT?: fr_repa_detScalarWhereWithAggregatesInput | fr_repa_detScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"fr_repa_det"> | number
    id_rep_cab?: IntNullableWithAggregatesFilter<"fr_repa_det"> | number | null
    fr_lote?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cor_sdt?: DecimalNullableWithAggregatesFilter<"fr_repa_det"> | Decimal | DecimalJsLike | number | string | null
    fr_pla_sdt?: IntNullableWithAggregatesFilter<"fr_repa_det"> | number | null
    fr_est_sdt?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_fec_pac?: DateTimeNullableWithAggregatesFilter<"fr_repa_det"> | Date | string | null
    fr_fec_rpa?: DateTimeNullableWithAggregatesFilter<"fr_repa_det"> | Date | string | null
    fr_gui_sdt?: IntNullableWithAggregatesFilter<"fr_repa_det"> | number | null
    fr_cod_pro?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_esp?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_var?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_hor_rec?: DateTimeNullableWithAggregatesFilter<"fr_repa_det"> | Date | string | null
    fr_con?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_tip_lot?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_alt_pal?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_env?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_eti?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_emb?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_envop?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_plu?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_caj?: IntNullableWithAggregatesFilter<"fr_repa_det"> | number | null
    fr_cod_cat?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_cal?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_nro_mix?: IntNullableWithAggregatesFilter<"fr_repa_det"> | number | null
    fr_fec_sem?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_bp?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_pre?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_cua?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_proceso?: IntNullableWithAggregatesFilter<"fr_repa_det"> | number | null
    fr_con_fri?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_fol_ori?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_var_eti?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_tip_tra?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_pro_eti?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_exp?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_pk_ori?: IntNullableWithAggregatesFilter<"fr_repa_det"> | number | null
    id_tip_io?: IntNullableWithAggregatesFilter<"fr_repa_det"> | number | null
    fr_caj_usa?: IntNullableWithAggregatesFilter<"fr_repa_det"> | number | null
    fr_tip_mov?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_fec_sag?: DateTimeNullableWithAggregatesFilter<"fr_repa_det"> | Date | string | null
    fr_guia_sag?: IntNullableWithAggregatesFilter<"fr_repa_det"> | number | null
    fr_cer_sag?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_sol_sag?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_tip_sag?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_mer?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_mer1?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_mer2?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_mer3?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_mer4?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_fec_fum?: DateTimeNullableWithAggregatesFilter<"fr_repa_det"> | Date | string | null
    fr_guia_fum?: IntNullableWithAggregatesFilter<"fr_repa_det"> | number | null
    fr_cer_fum?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_cod_tipo_fum?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_pfrio?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_correlativo_rec?: IntNullableWithAggregatesFilter<"fr_repa_det"> | number | null
    fr_cod_linea?: StringNullableWithAggregatesFilter<"fr_repa_det"> | string | null
    fr_peso_original?: DecimalNullableWithAggregatesFilter<"fr_repa_det"> | Decimal | DecimalJsLike | number | string | null
  }

  export type Gr_Tipo_CobroWhereInput = {
    AND?: Gr_Tipo_CobroWhereInput | Gr_Tipo_CobroWhereInput[]
    OR?: Gr_Tipo_CobroWhereInput[]
    NOT?: Gr_Tipo_CobroWhereInput | Gr_Tipo_CobroWhereInput[]
    id?: IntFilter<"Gr_Tipo_Cobro"> | number
    Descripcion?: StringNullableFilter<"Gr_Tipo_Cobro"> | string | null
    tipo_c?: IntNullableFilter<"Gr_Tipo_Cobro"> | number | null
  }

  export type Gr_Tipo_CobroOrderByWithRelationInput = {
    id?: SortOrder
    Descripcion?: SortOrderInput | SortOrder
    tipo_c?: SortOrderInput | SortOrder
  }

  export type Gr_Tipo_CobroWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Gr_Tipo_CobroWhereInput | Gr_Tipo_CobroWhereInput[]
    OR?: Gr_Tipo_CobroWhereInput[]
    NOT?: Gr_Tipo_CobroWhereInput | Gr_Tipo_CobroWhereInput[]
    Descripcion?: StringNullableFilter<"Gr_Tipo_Cobro"> | string | null
    tipo_c?: IntNullableFilter<"Gr_Tipo_Cobro"> | number | null
  }, "id">

  export type Gr_Tipo_CobroOrderByWithAggregationInput = {
    id?: SortOrder
    Descripcion?: SortOrderInput | SortOrder
    tipo_c?: SortOrderInput | SortOrder
    _count?: Gr_Tipo_CobroCountOrderByAggregateInput
    _avg?: Gr_Tipo_CobroAvgOrderByAggregateInput
    _max?: Gr_Tipo_CobroMaxOrderByAggregateInput
    _min?: Gr_Tipo_CobroMinOrderByAggregateInput
    _sum?: Gr_Tipo_CobroSumOrderByAggregateInput
  }

  export type Gr_Tipo_CobroScalarWhereWithAggregatesInput = {
    AND?: Gr_Tipo_CobroScalarWhereWithAggregatesInput | Gr_Tipo_CobroScalarWhereWithAggregatesInput[]
    OR?: Gr_Tipo_CobroScalarWhereWithAggregatesInput[]
    NOT?: Gr_Tipo_CobroScalarWhereWithAggregatesInput | Gr_Tipo_CobroScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Gr_Tipo_Cobro"> | number
    Descripcion?: StringNullableWithAggregatesFilter<"Gr_Tipo_Cobro"> | string | null
    tipo_c?: IntNullableWithAggregatesFilter<"Gr_Tipo_Cobro"> | number | null
  }

  export type insp_cabWhereInput = {
    AND?: insp_cabWhereInput | insp_cabWhereInput[]
    OR?: insp_cabWhereInput[]
    NOT?: insp_cabWhereInput | insp_cabWhereInput[]
    id_ins?: IntFilter<"insp_cab"> | number
    nro_sag?: IntNullableFilter<"insp_cab"> | number | null
    cod_csp?: StringNullableFilter<"insp_cab"> | string | null
    id_tip_ins?: IntNullableFilter<"insp_cab"> | number | null
    fec_doc?: DateTimeNullableFilter<"insp_cab"> | Date | string | null
    fec_ins?: DateTimeNullableFilter<"insp_cab"> | Date | string | null
    id_usuario?: StringNullableFilter<"insp_cab"> | string | null
    cod_mer?: StringNullableFilter<"insp_cab"> | string | null
    cod_mer1?: StringNullableFilter<"insp_cab"> | string | null
    cod_mer2?: StringNullableFilter<"insp_cab"> | string | null
    cod_mer3?: StringNullableFilter<"insp_cab"> | string | null
    obs_insp?: StringNullableFilter<"insp_cab"> | string | null
    id_est_ins?: IntNullableFilter<"insp_cab"> | number | null
  }

  export type insp_cabOrderByWithRelationInput = {
    id_ins?: SortOrder
    nro_sag?: SortOrderInput | SortOrder
    cod_csp?: SortOrderInput | SortOrder
    id_tip_ins?: SortOrderInput | SortOrder
    fec_doc?: SortOrderInput | SortOrder
    fec_ins?: SortOrderInput | SortOrder
    id_usuario?: SortOrderInput | SortOrder
    cod_mer?: SortOrderInput | SortOrder
    cod_mer1?: SortOrderInput | SortOrder
    cod_mer2?: SortOrderInput | SortOrder
    cod_mer3?: SortOrderInput | SortOrder
    obs_insp?: SortOrderInput | SortOrder
    id_est_ins?: SortOrderInput | SortOrder
  }

  export type insp_cabWhereUniqueInput = Prisma.AtLeast<{
    id_ins?: number
    AND?: insp_cabWhereInput | insp_cabWhereInput[]
    OR?: insp_cabWhereInput[]
    NOT?: insp_cabWhereInput | insp_cabWhereInput[]
    nro_sag?: IntNullableFilter<"insp_cab"> | number | null
    cod_csp?: StringNullableFilter<"insp_cab"> | string | null
    id_tip_ins?: IntNullableFilter<"insp_cab"> | number | null
    fec_doc?: DateTimeNullableFilter<"insp_cab"> | Date | string | null
    fec_ins?: DateTimeNullableFilter<"insp_cab"> | Date | string | null
    id_usuario?: StringNullableFilter<"insp_cab"> | string | null
    cod_mer?: StringNullableFilter<"insp_cab"> | string | null
    cod_mer1?: StringNullableFilter<"insp_cab"> | string | null
    cod_mer2?: StringNullableFilter<"insp_cab"> | string | null
    cod_mer3?: StringNullableFilter<"insp_cab"> | string | null
    obs_insp?: StringNullableFilter<"insp_cab"> | string | null
    id_est_ins?: IntNullableFilter<"insp_cab"> | number | null
  }, "id_ins">

  export type insp_cabOrderByWithAggregationInput = {
    id_ins?: SortOrder
    nro_sag?: SortOrderInput | SortOrder
    cod_csp?: SortOrderInput | SortOrder
    id_tip_ins?: SortOrderInput | SortOrder
    fec_doc?: SortOrderInput | SortOrder
    fec_ins?: SortOrderInput | SortOrder
    id_usuario?: SortOrderInput | SortOrder
    cod_mer?: SortOrderInput | SortOrder
    cod_mer1?: SortOrderInput | SortOrder
    cod_mer2?: SortOrderInput | SortOrder
    cod_mer3?: SortOrderInput | SortOrder
    obs_insp?: SortOrderInput | SortOrder
    id_est_ins?: SortOrderInput | SortOrder
    _count?: insp_cabCountOrderByAggregateInput
    _avg?: insp_cabAvgOrderByAggregateInput
    _max?: insp_cabMaxOrderByAggregateInput
    _min?: insp_cabMinOrderByAggregateInput
    _sum?: insp_cabSumOrderByAggregateInput
  }

  export type insp_cabScalarWhereWithAggregatesInput = {
    AND?: insp_cabScalarWhereWithAggregatesInput | insp_cabScalarWhereWithAggregatesInput[]
    OR?: insp_cabScalarWhereWithAggregatesInput[]
    NOT?: insp_cabScalarWhereWithAggregatesInput | insp_cabScalarWhereWithAggregatesInput[]
    id_ins?: IntWithAggregatesFilter<"insp_cab"> | number
    nro_sag?: IntNullableWithAggregatesFilter<"insp_cab"> | number | null
    cod_csp?: StringNullableWithAggregatesFilter<"insp_cab"> | string | null
    id_tip_ins?: IntNullableWithAggregatesFilter<"insp_cab"> | number | null
    fec_doc?: DateTimeNullableWithAggregatesFilter<"insp_cab"> | Date | string | null
    fec_ins?: DateTimeNullableWithAggregatesFilter<"insp_cab"> | Date | string | null
    id_usuario?: StringNullableWithAggregatesFilter<"insp_cab"> | string | null
    cod_mer?: StringNullableWithAggregatesFilter<"insp_cab"> | string | null
    cod_mer1?: StringNullableWithAggregatesFilter<"insp_cab"> | string | null
    cod_mer2?: StringNullableWithAggregatesFilter<"insp_cab"> | string | null
    cod_mer3?: StringNullableWithAggregatesFilter<"insp_cab"> | string | null
    obs_insp?: StringNullableWithAggregatesFilter<"insp_cab"> | string | null
    id_est_ins?: IntNullableWithAggregatesFilter<"insp_cab"> | number | null
  }

  export type mae_sta_elenaWhereInput = {
    AND?: mae_sta_elenaWhereInput | mae_sta_elenaWhereInput[]
    OR?: mae_sta_elenaWhereInput[]
    NOT?: mae_sta_elenaWhereInput | mae_sta_elenaWhereInput[]
    cod_emb?: StringFilter<"mae_sta_elena"> | string
  }

  export type mae_sta_elenaOrderByWithRelationInput = {
    cod_emb?: SortOrder
  }

  export type mae_sta_elenaWhereUniqueInput = Prisma.AtLeast<{
    cod_emb?: string
    AND?: mae_sta_elenaWhereInput | mae_sta_elenaWhereInput[]
    OR?: mae_sta_elenaWhereInput[]
    NOT?: mae_sta_elenaWhereInput | mae_sta_elenaWhereInput[]
  }, "cod_emb">

  export type mae_sta_elenaOrderByWithAggregationInput = {
    cod_emb?: SortOrder
    _count?: mae_sta_elenaCountOrderByAggregateInput
    _max?: mae_sta_elenaMaxOrderByAggregateInput
    _min?: mae_sta_elenaMinOrderByAggregateInput
  }

  export type mae_sta_elenaScalarWhereWithAggregatesInput = {
    AND?: mae_sta_elenaScalarWhereWithAggregatesInput | mae_sta_elenaScalarWhereWithAggregatesInput[]
    OR?: mae_sta_elenaScalarWhereWithAggregatesInput[]
    NOT?: mae_sta_elenaScalarWhereWithAggregatesInput | mae_sta_elenaScalarWhereWithAggregatesInput[]
    cod_emb?: StringWithAggregatesFilter<"mae_sta_elena"> | string
  }

  export type maestro_pluWhereInput = {
    AND?: maestro_pluWhereInput | maestro_pluWhereInput[]
    OR?: maestro_pluWhereInput[]
    NOT?: maestro_pluWhereInput | maestro_pluWhereInput[]
    cod_envop?: StringFilter<"maestro_plu"> | string
    cod_cal?: StringFilter<"maestro_plu"> | string
    cod_plu?: StringFilter<"maestro_plu"> | string
  }

  export type maestro_pluOrderByWithRelationInput = {
    cod_envop?: SortOrder
    cod_cal?: SortOrder
    cod_plu?: SortOrder
  }

  export type maestro_pluWhereUniqueInput = Prisma.AtLeast<{
    cod_envop_cod_cal?: maestro_pluCod_envopCod_calCompoundUniqueInput
    AND?: maestro_pluWhereInput | maestro_pluWhereInput[]
    OR?: maestro_pluWhereInput[]
    NOT?: maestro_pluWhereInput | maestro_pluWhereInput[]
    cod_envop?: StringFilter<"maestro_plu"> | string
    cod_cal?: StringFilter<"maestro_plu"> | string
    cod_plu?: StringFilter<"maestro_plu"> | string
  }, "cod_envop_cod_cal">

  export type maestro_pluOrderByWithAggregationInput = {
    cod_envop?: SortOrder
    cod_cal?: SortOrder
    cod_plu?: SortOrder
    _count?: maestro_pluCountOrderByAggregateInput
    _max?: maestro_pluMaxOrderByAggregateInput
    _min?: maestro_pluMinOrderByAggregateInput
  }

  export type maestro_pluScalarWhereWithAggregatesInput = {
    AND?: maestro_pluScalarWhereWithAggregatesInput | maestro_pluScalarWhereWithAggregatesInput[]
    OR?: maestro_pluScalarWhereWithAggregatesInput[]
    NOT?: maestro_pluScalarWhereWithAggregatesInput | maestro_pluScalarWhereWithAggregatesInput[]
    cod_envop?: StringWithAggregatesFilter<"maestro_plu"> | string
    cod_cal?: StringWithAggregatesFilter<"maestro_plu"> | string
    cod_plu?: StringWithAggregatesFilter<"maestro_plu"> | string
  }

  export type pk_desver_cabWhereInput = {
    AND?: pk_desver_cabWhereInput | pk_desver_cabWhereInput[]
    OR?: pk_desver_cabWhereInput[]
    NOT?: pk_desver_cabWhereInput | pk_desver_cabWhereInput[]
    id?: IntFilter<"pk_desver_cab"> | number
    pro_nro?: IntNullableFilter<"pk_desver_cab"> | number | null
    fec_ini?: DateTimeNullableFilter<"pk_desver_cab"> | Date | string | null
    fec_fin?: DateTimeNullableFilter<"pk_desver_cab"> | Date | string | null
    usu_res?: StringNullableFilter<"pk_desver_cab"> | string | null
    pes_ini?: FloatNullableFilter<"pk_desver_cab"> | number | null
    pes_fin?: FloatNullableFilter<"pk_desver_cab"> | number | null
    cod_esp?: StringNullableFilter<"pk_desver_cab"> | string | null
    fec_ven?: DateTimeNullableFilter<"pk_desver_cab"> | Date | string | null
  }

  export type pk_desver_cabOrderByWithRelationInput = {
    id?: SortOrder
    pro_nro?: SortOrderInput | SortOrder
    fec_ini?: SortOrderInput | SortOrder
    fec_fin?: SortOrderInput | SortOrder
    usu_res?: SortOrderInput | SortOrder
    pes_ini?: SortOrderInput | SortOrder
    pes_fin?: SortOrderInput | SortOrder
    cod_esp?: SortOrderInput | SortOrder
    fec_ven?: SortOrderInput | SortOrder
  }

  export type pk_desver_cabWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pk_desver_cabWhereInput | pk_desver_cabWhereInput[]
    OR?: pk_desver_cabWhereInput[]
    NOT?: pk_desver_cabWhereInput | pk_desver_cabWhereInput[]
    pro_nro?: IntNullableFilter<"pk_desver_cab"> | number | null
    fec_ini?: DateTimeNullableFilter<"pk_desver_cab"> | Date | string | null
    fec_fin?: DateTimeNullableFilter<"pk_desver_cab"> | Date | string | null
    usu_res?: StringNullableFilter<"pk_desver_cab"> | string | null
    pes_ini?: FloatNullableFilter<"pk_desver_cab"> | number | null
    pes_fin?: FloatNullableFilter<"pk_desver_cab"> | number | null
    cod_esp?: StringNullableFilter<"pk_desver_cab"> | string | null
    fec_ven?: DateTimeNullableFilter<"pk_desver_cab"> | Date | string | null
  }, "id">

  export type pk_desver_cabOrderByWithAggregationInput = {
    id?: SortOrder
    pro_nro?: SortOrderInput | SortOrder
    fec_ini?: SortOrderInput | SortOrder
    fec_fin?: SortOrderInput | SortOrder
    usu_res?: SortOrderInput | SortOrder
    pes_ini?: SortOrderInput | SortOrder
    pes_fin?: SortOrderInput | SortOrder
    cod_esp?: SortOrderInput | SortOrder
    fec_ven?: SortOrderInput | SortOrder
    _count?: pk_desver_cabCountOrderByAggregateInput
    _avg?: pk_desver_cabAvgOrderByAggregateInput
    _max?: pk_desver_cabMaxOrderByAggregateInput
    _min?: pk_desver_cabMinOrderByAggregateInput
    _sum?: pk_desver_cabSumOrderByAggregateInput
  }

  export type pk_desver_cabScalarWhereWithAggregatesInput = {
    AND?: pk_desver_cabScalarWhereWithAggregatesInput | pk_desver_cabScalarWhereWithAggregatesInput[]
    OR?: pk_desver_cabScalarWhereWithAggregatesInput[]
    NOT?: pk_desver_cabScalarWhereWithAggregatesInput | pk_desver_cabScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pk_desver_cab"> | number
    pro_nro?: IntNullableWithAggregatesFilter<"pk_desver_cab"> | number | null
    fec_ini?: DateTimeNullableWithAggregatesFilter<"pk_desver_cab"> | Date | string | null
    fec_fin?: DateTimeNullableWithAggregatesFilter<"pk_desver_cab"> | Date | string | null
    usu_res?: StringNullableWithAggregatesFilter<"pk_desver_cab"> | string | null
    pes_ini?: FloatNullableWithAggregatesFilter<"pk_desver_cab"> | number | null
    pes_fin?: FloatNullableWithAggregatesFilter<"pk_desver_cab"> | number | null
    cod_esp?: StringNullableWithAggregatesFilter<"pk_desver_cab"> | string | null
    fec_ven?: DateTimeNullableWithAggregatesFilter<"pk_desver_cab"> | Date | string | null
  }

  export type pk_desver_detWhereInput = {
    AND?: pk_desver_detWhereInput | pk_desver_detWhereInput[]
    OR?: pk_desver_detWhereInput[]
    NOT?: pk_desver_detWhereInput | pk_desver_detWhereInput[]
    id?: IntFilter<"pk_desver_det"> | number
    id_cab?: IntNullableFilter<"pk_desver_det"> | number | null
    folio?: StringNullableFilter<"pk_desver_det"> | string | null
    cod_var?: StringNullableFilter<"pk_desver_det"> | string | null
    cod_esp?: StringNullableFilter<"pk_desver_det"> | string | null
    peso_neto?: FloatNullableFilter<"pk_desver_det"> | number | null
    peso_fin?: FloatNullableFilter<"pk_desver_det"> | number | null
    cod_cal?: StringNullableFilter<"pk_desver_det"> | string | null
  }

  export type pk_desver_detOrderByWithRelationInput = {
    id?: SortOrder
    id_cab?: SortOrderInput | SortOrder
    folio?: SortOrderInput | SortOrder
    cod_var?: SortOrderInput | SortOrder
    cod_esp?: SortOrderInput | SortOrder
    peso_neto?: SortOrderInput | SortOrder
    peso_fin?: SortOrderInput | SortOrder
    cod_cal?: SortOrderInput | SortOrder
  }

  export type pk_desver_detWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pk_desver_detWhereInput | pk_desver_detWhereInput[]
    OR?: pk_desver_detWhereInput[]
    NOT?: pk_desver_detWhereInput | pk_desver_detWhereInput[]
    id_cab?: IntNullableFilter<"pk_desver_det"> | number | null
    folio?: StringNullableFilter<"pk_desver_det"> | string | null
    cod_var?: StringNullableFilter<"pk_desver_det"> | string | null
    cod_esp?: StringNullableFilter<"pk_desver_det"> | string | null
    peso_neto?: FloatNullableFilter<"pk_desver_det"> | number | null
    peso_fin?: FloatNullableFilter<"pk_desver_det"> | number | null
    cod_cal?: StringNullableFilter<"pk_desver_det"> | string | null
  }, "id">

  export type pk_desver_detOrderByWithAggregationInput = {
    id?: SortOrder
    id_cab?: SortOrderInput | SortOrder
    folio?: SortOrderInput | SortOrder
    cod_var?: SortOrderInput | SortOrder
    cod_esp?: SortOrderInput | SortOrder
    peso_neto?: SortOrderInput | SortOrder
    peso_fin?: SortOrderInput | SortOrder
    cod_cal?: SortOrderInput | SortOrder
    _count?: pk_desver_detCountOrderByAggregateInput
    _avg?: pk_desver_detAvgOrderByAggregateInput
    _max?: pk_desver_detMaxOrderByAggregateInput
    _min?: pk_desver_detMinOrderByAggregateInput
    _sum?: pk_desver_detSumOrderByAggregateInput
  }

  export type pk_desver_detScalarWhereWithAggregatesInput = {
    AND?: pk_desver_detScalarWhereWithAggregatesInput | pk_desver_detScalarWhereWithAggregatesInput[]
    OR?: pk_desver_detScalarWhereWithAggregatesInput[]
    NOT?: pk_desver_detScalarWhereWithAggregatesInput | pk_desver_detScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pk_desver_det"> | number
    id_cab?: IntNullableWithAggregatesFilter<"pk_desver_det"> | number | null
    folio?: StringNullableWithAggregatesFilter<"pk_desver_det"> | string | null
    cod_var?: StringNullableWithAggregatesFilter<"pk_desver_det"> | string | null
    cod_esp?: StringNullableWithAggregatesFilter<"pk_desver_det"> | string | null
    peso_neto?: FloatNullableWithAggregatesFilter<"pk_desver_det"> | number | null
    peso_fin?: FloatNullableWithAggregatesFilter<"pk_desver_det"> | number | null
    cod_cal?: StringNullableWithAggregatesFilter<"pk_desver_det"> | string | null
  }

  export type sys_logWhereInput = {
    AND?: sys_logWhereInput | sys_logWhereInput[]
    OR?: sys_logWhereInput[]
    NOT?: sys_logWhereInput | sys_logWhereInput[]
    id?: IntFilter<"sys_log"> | number
    tip_eve?: StringNullableFilter<"sys_log"> | string | null
    usu_sys?: StringNullableFilter<"sys_log"> | string | null
    ip_pc?: StringNullableFilter<"sys_log"> | string | null
    fecha_log?: DateTimeNullableFilter<"sys_log"> | Date | string | null
    folio?: StringNullableFilter<"sys_log"> | string | null
    modulo?: StringNullableFilter<"sys_log"> | string | null
  }

  export type sys_logOrderByWithRelationInput = {
    id?: SortOrder
    tip_eve?: SortOrderInput | SortOrder
    usu_sys?: SortOrderInput | SortOrder
    ip_pc?: SortOrderInput | SortOrder
    fecha_log?: SortOrderInput | SortOrder
    folio?: SortOrderInput | SortOrder
    modulo?: SortOrderInput | SortOrder
  }

  export type sys_logWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: sys_logWhereInput | sys_logWhereInput[]
    OR?: sys_logWhereInput[]
    NOT?: sys_logWhereInput | sys_logWhereInput[]
    tip_eve?: StringNullableFilter<"sys_log"> | string | null
    usu_sys?: StringNullableFilter<"sys_log"> | string | null
    ip_pc?: StringNullableFilter<"sys_log"> | string | null
    fecha_log?: DateTimeNullableFilter<"sys_log"> | Date | string | null
    folio?: StringNullableFilter<"sys_log"> | string | null
    modulo?: StringNullableFilter<"sys_log"> | string | null
  }, "id">

  export type sys_logOrderByWithAggregationInput = {
    id?: SortOrder
    tip_eve?: SortOrderInput | SortOrder
    usu_sys?: SortOrderInput | SortOrder
    ip_pc?: SortOrderInput | SortOrder
    fecha_log?: SortOrderInput | SortOrder
    folio?: SortOrderInput | SortOrder
    modulo?: SortOrderInput | SortOrder
    _count?: sys_logCountOrderByAggregateInput
    _avg?: sys_logAvgOrderByAggregateInput
    _max?: sys_logMaxOrderByAggregateInput
    _min?: sys_logMinOrderByAggregateInput
    _sum?: sys_logSumOrderByAggregateInput
  }

  export type sys_logScalarWhereWithAggregatesInput = {
    AND?: sys_logScalarWhereWithAggregatesInput | sys_logScalarWhereWithAggregatesInput[]
    OR?: sys_logScalarWhereWithAggregatesInput[]
    NOT?: sys_logScalarWhereWithAggregatesInput | sys_logScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sys_log"> | number
    tip_eve?: StringNullableWithAggregatesFilter<"sys_log"> | string | null
    usu_sys?: StringNullableWithAggregatesFilter<"sys_log"> | string | null
    ip_pc?: StringNullableWithAggregatesFilter<"sys_log"> | string | null
    fecha_log?: DateTimeNullableWithAggregatesFilter<"sys_log"> | Date | string | null
    folio?: StringNullableWithAggregatesFilter<"sys_log"> | string | null
    modulo?: StringNullableWithAggregatesFilter<"sys_log"> | string | null
  }

  export type sysdiagramsWhereInput = {
    AND?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    OR?: sysdiagramsWhereInput[]
    NOT?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    name?: StringFilter<"sysdiagrams"> | string
    principal_id?: IntFilter<"sysdiagrams"> | number
    diagram_id?: IntFilter<"sysdiagrams"> | number
    version?: IntNullableFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableFilter<"sysdiagrams"> | Buffer | null
  }

  export type sysdiagramsOrderByWithRelationInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrderInput | SortOrder
    definition?: SortOrderInput | SortOrder
  }

  export type sysdiagramsWhereUniqueInput = Prisma.AtLeast<{
    diagram_id?: number
    principal_id_name?: sysdiagramsPrincipal_idNameCompoundUniqueInput
    AND?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    OR?: sysdiagramsWhereInput[]
    NOT?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    name?: StringFilter<"sysdiagrams"> | string
    principal_id?: IntFilter<"sysdiagrams"> | number
    version?: IntNullableFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableFilter<"sysdiagrams"> | Buffer | null
  }, "diagram_id" | "principal_id_name">

  export type sysdiagramsOrderByWithAggregationInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrderInput | SortOrder
    definition?: SortOrderInput | SortOrder
    _count?: sysdiagramsCountOrderByAggregateInput
    _avg?: sysdiagramsAvgOrderByAggregateInput
    _max?: sysdiagramsMaxOrderByAggregateInput
    _min?: sysdiagramsMinOrderByAggregateInput
    _sum?: sysdiagramsSumOrderByAggregateInput
  }

  export type sysdiagramsScalarWhereWithAggregatesInput = {
    AND?: sysdiagramsScalarWhereWithAggregatesInput | sysdiagramsScalarWhereWithAggregatesInput[]
    OR?: sysdiagramsScalarWhereWithAggregatesInput[]
    NOT?: sysdiagramsScalarWhereWithAggregatesInput | sysdiagramsScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"sysdiagrams"> | string
    principal_id?: IntWithAggregatesFilter<"sysdiagrams"> | number
    diagram_id?: IntWithAggregatesFilter<"sysdiagrams"> | number
    version?: IntNullableWithAggregatesFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableWithAggregatesFilter<"sysdiagrams"> | Buffer | null
  }

  export type tipo_insWhereInput = {
    AND?: tipo_insWhereInput | tipo_insWhereInput[]
    OR?: tipo_insWhereInput[]
    NOT?: tipo_insWhereInput | tipo_insWhereInput[]
    id_tip_ins?: IntFilter<"tipo_ins"> | number
    des_tip_ins?: StringNullableFilter<"tipo_ins"> | string | null
  }

  export type tipo_insOrderByWithRelationInput = {
    id_tip_ins?: SortOrder
    des_tip_ins?: SortOrderInput | SortOrder
  }

  export type tipo_insWhereUniqueInput = Prisma.AtLeast<{
    id_tip_ins?: number
    AND?: tipo_insWhereInput | tipo_insWhereInput[]
    OR?: tipo_insWhereInput[]
    NOT?: tipo_insWhereInput | tipo_insWhereInput[]
    des_tip_ins?: StringNullableFilter<"tipo_ins"> | string | null
  }, "id_tip_ins">

  export type tipo_insOrderByWithAggregationInput = {
    id_tip_ins?: SortOrder
    des_tip_ins?: SortOrderInput | SortOrder
    _count?: tipo_insCountOrderByAggregateInput
    _avg?: tipo_insAvgOrderByAggregateInput
    _max?: tipo_insMaxOrderByAggregateInput
    _min?: tipo_insMinOrderByAggregateInput
    _sum?: tipo_insSumOrderByAggregateInput
  }

  export type tipo_insScalarWhereWithAggregatesInput = {
    AND?: tipo_insScalarWhereWithAggregatesInput | tipo_insScalarWhereWithAggregatesInput[]
    OR?: tipo_insScalarWhereWithAggregatesInput[]
    NOT?: tipo_insScalarWhereWithAggregatesInput | tipo_insScalarWhereWithAggregatesInput[]
    id_tip_ins?: IntWithAggregatesFilter<"tipo_ins"> | number
    des_tip_ins?: StringNullableWithAggregatesFilter<"tipo_ins"> | string | null
  }

  export type traductor_calibreWhereInput = {
    AND?: traductor_calibreWhereInput | traductor_calibreWhereInput[]
    OR?: traductor_calibreWhereInput[]
    NOT?: traductor_calibreWhereInput | traductor_calibreWhereInput[]
    id?: IntFilter<"traductor_calibre"> | number
    n_calibre_std?: StringNullableFilter<"traductor_calibre"> | string | null
    val_calibre?: IntNullableFilter<"traductor_calibre"> | number | null
    cod_exp?: StringNullableFilter<"traductor_calibre"> | string | null
    n_calibre?: StringNullableFilter<"traductor_calibre"> | string | null
  }

  export type traductor_calibreOrderByWithRelationInput = {
    id?: SortOrder
    n_calibre_std?: SortOrderInput | SortOrder
    val_calibre?: SortOrderInput | SortOrder
    cod_exp?: SortOrderInput | SortOrder
    n_calibre?: SortOrderInput | SortOrder
  }

  export type traductor_calibreWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: traductor_calibreWhereInput | traductor_calibreWhereInput[]
    OR?: traductor_calibreWhereInput[]
    NOT?: traductor_calibreWhereInput | traductor_calibreWhereInput[]
    n_calibre_std?: StringNullableFilter<"traductor_calibre"> | string | null
    val_calibre?: IntNullableFilter<"traductor_calibre"> | number | null
    cod_exp?: StringNullableFilter<"traductor_calibre"> | string | null
    n_calibre?: StringNullableFilter<"traductor_calibre"> | string | null
  }, "id">

  export type traductor_calibreOrderByWithAggregationInput = {
    id?: SortOrder
    n_calibre_std?: SortOrderInput | SortOrder
    val_calibre?: SortOrderInput | SortOrder
    cod_exp?: SortOrderInput | SortOrder
    n_calibre?: SortOrderInput | SortOrder
    _count?: traductor_calibreCountOrderByAggregateInput
    _avg?: traductor_calibreAvgOrderByAggregateInput
    _max?: traductor_calibreMaxOrderByAggregateInput
    _min?: traductor_calibreMinOrderByAggregateInput
    _sum?: traductor_calibreSumOrderByAggregateInput
  }

  export type traductor_calibreScalarWhereWithAggregatesInput = {
    AND?: traductor_calibreScalarWhereWithAggregatesInput | traductor_calibreScalarWhereWithAggregatesInput[]
    OR?: traductor_calibreScalarWhereWithAggregatesInput[]
    NOT?: traductor_calibreScalarWhereWithAggregatesInput | traductor_calibreScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"traductor_calibre"> | number
    n_calibre_std?: StringNullableWithAggregatesFilter<"traductor_calibre"> | string | null
    val_calibre?: IntNullableWithAggregatesFilter<"traductor_calibre"> | number | null
    cod_exp?: StringNullableWithAggregatesFilter<"traductor_calibre"> | string | null
    n_calibre?: StringNullableWithAggregatesFilter<"traductor_calibre"> | string | null
  }

  export type validacion_palletsWhereInput = {
    AND?: validacion_palletsWhereInput | validacion_palletsWhereInput[]
    OR?: validacion_palletsWhereInput[]
    NOT?: validacion_palletsWhereInput | validacion_palletsWhereInput[]
    id?: IntFilter<"validacion_pallets"> | number
    numero_pallet?: StringNullableFilter<"validacion_pallets"> | string | null
    temporada?: IntNullableFilter<"validacion_pallets"> | number | null
  }

  export type validacion_palletsOrderByWithRelationInput = {
    id?: SortOrder
    numero_pallet?: SortOrderInput | SortOrder
    temporada?: SortOrderInput | SortOrder
  }

  export type validacion_palletsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: validacion_palletsWhereInput | validacion_palletsWhereInput[]
    OR?: validacion_palletsWhereInput[]
    NOT?: validacion_palletsWhereInput | validacion_palletsWhereInput[]
    numero_pallet?: StringNullableFilter<"validacion_pallets"> | string | null
    temporada?: IntNullableFilter<"validacion_pallets"> | number | null
  }, "id">

  export type validacion_palletsOrderByWithAggregationInput = {
    id?: SortOrder
    numero_pallet?: SortOrderInput | SortOrder
    temporada?: SortOrderInput | SortOrder
    _count?: validacion_palletsCountOrderByAggregateInput
    _avg?: validacion_palletsAvgOrderByAggregateInput
    _max?: validacion_palletsMaxOrderByAggregateInput
    _min?: validacion_palletsMinOrderByAggregateInput
    _sum?: validacion_palletsSumOrderByAggregateInput
  }

  export type validacion_palletsScalarWhereWithAggregatesInput = {
    AND?: validacion_palletsScalarWhereWithAggregatesInput | validacion_palletsScalarWhereWithAggregatesInput[]
    OR?: validacion_palletsScalarWhereWithAggregatesInput[]
    NOT?: validacion_palletsScalarWhereWithAggregatesInput | validacion_palletsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"validacion_pallets"> | number
    numero_pallet?: StringNullableWithAggregatesFilter<"validacion_pallets"> | string | null
    temporada?: IntNullableWithAggregatesFilter<"validacion_pallets"> | number | null
  }

  export type existencias_cajasWhereInput = {
    AND?: existencias_cajasWhereInput | existencias_cajasWhereInput[]
    OR?: existencias_cajasWhereInput[]
    NOT?: existencias_cajasWhereInput | existencias_cajasWhereInput[]
    Camara?: StringNullableFilter<"existencias_cajas"> | string | null
    Especie?: StringNullableFilter<"existencias_cajas"> | string | null
    Fecha_packing?: DateTimeNullableFilter<"existencias_cajas"> | Date | string | null
    Hora_Packing?: StringNullableFilter<"existencias_cajas"> | string | null
    Packing?: StringFilter<"existencias_cajas"> | string
    Folio?: StringFilter<"existencias_cajas"> | string
    Productor?: StringNullableFilter<"existencias_cajas"> | string | null
    CSG?: StringNullableFilter<"existencias_cajas"> | string | null
    Marca?: StringFilter<"existencias_cajas"> | string
    Embalaje?: StringFilter<"existencias_cajas"> | string
    Linea?: StringNullableFilter<"existencias_cajas"> | string | null
    Exportadora?: StringNullableFilter<"existencias_cajas"> | string | null
    Jornada?: StringNullableFilter<"existencias_cajas"> | string | null
    Variedad?: StringNullableFilter<"existencias_cajas"> | string | null
    Calibre?: StringFilter<"existencias_cajas"> | string
    Categoria?: StringNullableFilter<"existencias_cajas"> | string | null
    Cajas?: IntFilter<"existencias_cajas"> | number
    Proceso?: IntFilter<"existencias_cajas"> | number
  }

  export type existencias_cajasOrderByWithRelationInput = {
    Camara?: SortOrderInput | SortOrder
    Especie?: SortOrderInput | SortOrder
    Fecha_packing?: SortOrderInput | SortOrder
    Hora_Packing?: SortOrderInput | SortOrder
    Packing?: SortOrder
    Folio?: SortOrder
    Productor?: SortOrderInput | SortOrder
    CSG?: SortOrderInput | SortOrder
    Marca?: SortOrder
    Embalaje?: SortOrder
    Linea?: SortOrderInput | SortOrder
    Exportadora?: SortOrderInput | SortOrder
    Jornada?: SortOrderInput | SortOrder
    Variedad?: SortOrderInput | SortOrder
    Calibre?: SortOrder
    Categoria?: SortOrderInput | SortOrder
    Cajas?: SortOrder
    Proceso?: SortOrder
  }

  export type existencias_cajasWhereUniqueInput = Prisma.AtLeast<{
    Folio?: string
    AND?: existencias_cajasWhereInput | existencias_cajasWhereInput[]
    OR?: existencias_cajasWhereInput[]
    NOT?: existencias_cajasWhereInput | existencias_cajasWhereInput[]
    Camara?: StringNullableFilter<"existencias_cajas"> | string | null
    Especie?: StringNullableFilter<"existencias_cajas"> | string | null
    Fecha_packing?: DateTimeNullableFilter<"existencias_cajas"> | Date | string | null
    Hora_Packing?: StringNullableFilter<"existencias_cajas"> | string | null
    Packing?: StringFilter<"existencias_cajas"> | string
    Productor?: StringNullableFilter<"existencias_cajas"> | string | null
    CSG?: StringNullableFilter<"existencias_cajas"> | string | null
    Marca?: StringFilter<"existencias_cajas"> | string
    Embalaje?: StringFilter<"existencias_cajas"> | string
    Linea?: StringNullableFilter<"existencias_cajas"> | string | null
    Exportadora?: StringNullableFilter<"existencias_cajas"> | string | null
    Jornada?: StringNullableFilter<"existencias_cajas"> | string | null
    Variedad?: StringNullableFilter<"existencias_cajas"> | string | null
    Calibre?: StringFilter<"existencias_cajas"> | string
    Categoria?: StringNullableFilter<"existencias_cajas"> | string | null
    Cajas?: IntFilter<"existencias_cajas"> | number
    Proceso?: IntFilter<"existencias_cajas"> | number
  }, "Folio">

  export type existencias_cajasOrderByWithAggregationInput = {
    Camara?: SortOrderInput | SortOrder
    Especie?: SortOrderInput | SortOrder
    Fecha_packing?: SortOrderInput | SortOrder
    Hora_Packing?: SortOrderInput | SortOrder
    Packing?: SortOrder
    Folio?: SortOrder
    Productor?: SortOrderInput | SortOrder
    CSG?: SortOrderInput | SortOrder
    Marca?: SortOrder
    Embalaje?: SortOrder
    Linea?: SortOrderInput | SortOrder
    Exportadora?: SortOrderInput | SortOrder
    Jornada?: SortOrderInput | SortOrder
    Variedad?: SortOrderInput | SortOrder
    Calibre?: SortOrder
    Categoria?: SortOrderInput | SortOrder
    Cajas?: SortOrder
    Proceso?: SortOrder
    _count?: existencias_cajasCountOrderByAggregateInput
    _avg?: existencias_cajasAvgOrderByAggregateInput
    _max?: existencias_cajasMaxOrderByAggregateInput
    _min?: existencias_cajasMinOrderByAggregateInput
    _sum?: existencias_cajasSumOrderByAggregateInput
  }

  export type existencias_cajasScalarWhereWithAggregatesInput = {
    AND?: existencias_cajasScalarWhereWithAggregatesInput | existencias_cajasScalarWhereWithAggregatesInput[]
    OR?: existencias_cajasScalarWhereWithAggregatesInput[]
    NOT?: existencias_cajasScalarWhereWithAggregatesInput | existencias_cajasScalarWhereWithAggregatesInput[]
    Camara?: StringNullableWithAggregatesFilter<"existencias_cajas"> | string | null
    Especie?: StringNullableWithAggregatesFilter<"existencias_cajas"> | string | null
    Fecha_packing?: DateTimeNullableWithAggregatesFilter<"existencias_cajas"> | Date | string | null
    Hora_Packing?: StringNullableWithAggregatesFilter<"existencias_cajas"> | string | null
    Packing?: StringWithAggregatesFilter<"existencias_cajas"> | string
    Folio?: StringWithAggregatesFilter<"existencias_cajas"> | string
    Productor?: StringNullableWithAggregatesFilter<"existencias_cajas"> | string | null
    CSG?: StringNullableWithAggregatesFilter<"existencias_cajas"> | string | null
    Marca?: StringWithAggregatesFilter<"existencias_cajas"> | string
    Embalaje?: StringWithAggregatesFilter<"existencias_cajas"> | string
    Linea?: StringNullableWithAggregatesFilter<"existencias_cajas"> | string | null
    Exportadora?: StringNullableWithAggregatesFilter<"existencias_cajas"> | string | null
    Jornada?: StringNullableWithAggregatesFilter<"existencias_cajas"> | string | null
    Variedad?: StringNullableWithAggregatesFilter<"existencias_cajas"> | string | null
    Calibre?: StringWithAggregatesFilter<"existencias_cajas"> | string
    Categoria?: StringNullableWithAggregatesFilter<"existencias_cajas"> | string | null
    Cajas?: IntWithAggregatesFilter<"existencias_cajas"> | number
    Proceso?: IntWithAggregatesFilter<"existencias_cajas"> | number
  }

  export type existenciamix_cajasWhereInput = {
    AND?: existenciamix_cajasWhereInput | existenciamix_cajasWhereInput[]
    OR?: existenciamix_cajasWhereInput[]
    NOT?: existenciamix_cajasWhereInput | existenciamix_cajasWhereInput[]
    Camara?: StringNullableFilter<"existenciamix_cajas"> | string | null
    Fecha_Packing?: StringNullableFilter<"existenciamix_cajas"> | string | null
    Hora_Packing?: StringNullableFilter<"existenciamix_cajas"> | string | null
    Packing?: StringFilter<"existenciamix_cajas"> | string
    Folio?: StringFilter<"existenciamix_cajas"> | string
    Productor?: StringNullableFilter<"existenciamix_cajas"> | string | null
    CSG?: StringNullableFilter<"existenciamix_cajas"> | string | null
    Cuartel?: StringNullableFilter<"existenciamix_cajas"> | string | null
    Variedad?: StringNullableFilter<"existenciamix_cajas"> | string | null
    Embalaje?: StringFilter<"existenciamix_cajas"> | string
    Etiqueta?: StringNullableFilter<"existenciamix_cajas"> | string | null
    Calibre?: StringFilter<"existenciamix_cajas"> | string
    Categoria?: StringNullableFilter<"existenciamix_cajas"> | string | null
    Cajas?: IntFilter<"existenciamix_cajas"> | number
    Proceso?: IntFilter<"existenciamix_cajas"> | number
  }

  export type existenciamix_cajasOrderByWithRelationInput = {
    Camara?: SortOrderInput | SortOrder
    Fecha_Packing?: SortOrderInput | SortOrder
    Hora_Packing?: SortOrderInput | SortOrder
    Packing?: SortOrder
    Folio?: SortOrder
    Productor?: SortOrderInput | SortOrder
    CSG?: SortOrderInput | SortOrder
    Cuartel?: SortOrderInput | SortOrder
    Variedad?: SortOrderInput | SortOrder
    Embalaje?: SortOrder
    Etiqueta?: SortOrderInput | SortOrder
    Calibre?: SortOrder
    Categoria?: SortOrderInput | SortOrder
    Cajas?: SortOrder
    Proceso?: SortOrder
  }

  export type existenciamix_cajasWhereUniqueInput = Prisma.AtLeast<{
    Folio?: string
    AND?: existenciamix_cajasWhereInput | existenciamix_cajasWhereInput[]
    OR?: existenciamix_cajasWhereInput[]
    NOT?: existenciamix_cajasWhereInput | existenciamix_cajasWhereInput[]
    Camara?: StringNullableFilter<"existenciamix_cajas"> | string | null
    Fecha_Packing?: StringNullableFilter<"existenciamix_cajas"> | string | null
    Hora_Packing?: StringNullableFilter<"existenciamix_cajas"> | string | null
    Packing?: StringFilter<"existenciamix_cajas"> | string
    Productor?: StringNullableFilter<"existenciamix_cajas"> | string | null
    CSG?: StringNullableFilter<"existenciamix_cajas"> | string | null
    Cuartel?: StringNullableFilter<"existenciamix_cajas"> | string | null
    Variedad?: StringNullableFilter<"existenciamix_cajas"> | string | null
    Embalaje?: StringFilter<"existenciamix_cajas"> | string
    Etiqueta?: StringNullableFilter<"existenciamix_cajas"> | string | null
    Calibre?: StringFilter<"existenciamix_cajas"> | string
    Categoria?: StringNullableFilter<"existenciamix_cajas"> | string | null
    Cajas?: IntFilter<"existenciamix_cajas"> | number
    Proceso?: IntFilter<"existenciamix_cajas"> | number
  }, "Folio">

  export type existenciamix_cajasOrderByWithAggregationInput = {
    Camara?: SortOrderInput | SortOrder
    Fecha_Packing?: SortOrderInput | SortOrder
    Hora_Packing?: SortOrderInput | SortOrder
    Packing?: SortOrder
    Folio?: SortOrder
    Productor?: SortOrderInput | SortOrder
    CSG?: SortOrderInput | SortOrder
    Cuartel?: SortOrderInput | SortOrder
    Variedad?: SortOrderInput | SortOrder
    Embalaje?: SortOrder
    Etiqueta?: SortOrderInput | SortOrder
    Calibre?: SortOrder
    Categoria?: SortOrderInput | SortOrder
    Cajas?: SortOrder
    Proceso?: SortOrder
    _count?: existenciamix_cajasCountOrderByAggregateInput
    _avg?: existenciamix_cajasAvgOrderByAggregateInput
    _max?: existenciamix_cajasMaxOrderByAggregateInput
    _min?: existenciamix_cajasMinOrderByAggregateInput
    _sum?: existenciamix_cajasSumOrderByAggregateInput
  }

  export type existenciamix_cajasScalarWhereWithAggregatesInput = {
    AND?: existenciamix_cajasScalarWhereWithAggregatesInput | existenciamix_cajasScalarWhereWithAggregatesInput[]
    OR?: existenciamix_cajasScalarWhereWithAggregatesInput[]
    NOT?: existenciamix_cajasScalarWhereWithAggregatesInput | existenciamix_cajasScalarWhereWithAggregatesInput[]
    Camara?: StringNullableWithAggregatesFilter<"existenciamix_cajas"> | string | null
    Fecha_Packing?: StringNullableWithAggregatesFilter<"existenciamix_cajas"> | string | null
    Hora_Packing?: StringNullableWithAggregatesFilter<"existenciamix_cajas"> | string | null
    Packing?: StringWithAggregatesFilter<"existenciamix_cajas"> | string
    Folio?: StringWithAggregatesFilter<"existenciamix_cajas"> | string
    Productor?: StringNullableWithAggregatesFilter<"existenciamix_cajas"> | string | null
    CSG?: StringNullableWithAggregatesFilter<"existenciamix_cajas"> | string | null
    Cuartel?: StringNullableWithAggregatesFilter<"existenciamix_cajas"> | string | null
    Variedad?: StringNullableWithAggregatesFilter<"existenciamix_cajas"> | string | null
    Embalaje?: StringWithAggregatesFilter<"existenciamix_cajas"> | string
    Etiqueta?: StringNullableWithAggregatesFilter<"existenciamix_cajas"> | string | null
    Calibre?: StringWithAggregatesFilter<"existenciamix_cajas"> | string
    Categoria?: StringNullableWithAggregatesFilter<"existenciamix_cajas"> | string | null
    Cajas?: IntWithAggregatesFilter<"existenciamix_cajas"> | number
    Proceso?: IntWithAggregatesFilter<"existenciamix_cajas"> | number
  }

  export type capacidad_lineasCreateInput = {
    cod_linea?: string | null
    cod_esp?: string | null
    nro_vias?: number | null
    capacidad_vias?: Decimal | DecimalJsLike | number | string | null
  }

  export type capacidad_lineasUncheckedCreateInput = {
    id?: number
    cod_linea?: string | null
    cod_esp?: string | null
    nro_vias?: number | null
    capacidad_vias?: Decimal | DecimalJsLike | number | string | null
  }

  export type capacidad_lineasUpdateInput = {
    cod_linea?: NullableStringFieldUpdateOperationsInput | string | null
    cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    nro_vias?: NullableIntFieldUpdateOperationsInput | number | null
    capacidad_vias?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type capacidad_lineasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cod_linea?: NullableStringFieldUpdateOperationsInput | string | null
    cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    nro_vias?: NullableIntFieldUpdateOperationsInput | number | null
    capacidad_vias?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type capacidad_lineasCreateManyInput = {
    cod_linea?: string | null
    cod_esp?: string | null
    nro_vias?: number | null
    capacidad_vias?: Decimal | DecimalJsLike | number | string | null
  }

  export type capacidad_lineasUpdateManyMutationInput = {
    cod_linea?: NullableStringFieldUpdateOperationsInput | string | null
    cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    nro_vias?: NullableIntFieldUpdateOperationsInput | number | null
    capacidad_vias?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type capacidad_lineasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cod_linea?: NullableStringFieldUpdateOperationsInput | string | null
    cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    nro_vias?: NullableIntFieldUpdateOperationsInput | number | null
    capacidad_vias?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type cc_checklistCreateInput = {
    n_proceso?: number | null
    cod_esp?: string | null
    cod_var?: string | null
    cod_pro?: string | null
    cod_linea?: string | null
    fecha?: Date | string | null
    cal_encerado?: string | null
    porc_exp?: number | null
    cal_cajas?: string | null
    porc_plu_c?: string | null
    peso_caj?: Decimal | DecimalJsLike | number | string | null
    cal_palet?: string | null
    saturacion?: string | null
    porc_exp_c?: string | null
    usuario?: string | null
    porc_plu?: number | null
    cod_emp?: string | null
    cod_tem?: string | null
    cod_envop?: string | null
    peso_c?: string | null
    fec_muestra?: Date | string | null
  }

  export type cc_checklistUncheckedCreateInput = {
    id?: number
    n_proceso?: number | null
    cod_esp?: string | null
    cod_var?: string | null
    cod_pro?: string | null
    cod_linea?: string | null
    fecha?: Date | string | null
    cal_encerado?: string | null
    porc_exp?: number | null
    cal_cajas?: string | null
    porc_plu_c?: string | null
    peso_caj?: Decimal | DecimalJsLike | number | string | null
    cal_palet?: string | null
    saturacion?: string | null
    porc_exp_c?: string | null
    usuario?: string | null
    porc_plu?: number | null
    cod_emp?: string | null
    cod_tem?: string | null
    cod_envop?: string | null
    peso_c?: string | null
    fec_muestra?: Date | string | null
  }

  export type cc_checklistUpdateInput = {
    n_proceso?: NullableIntFieldUpdateOperationsInput | number | null
    cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_pro?: NullableStringFieldUpdateOperationsInput | string | null
    cod_linea?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cal_encerado?: NullableStringFieldUpdateOperationsInput | string | null
    porc_exp?: NullableIntFieldUpdateOperationsInput | number | null
    cal_cajas?: NullableStringFieldUpdateOperationsInput | string | null
    porc_plu_c?: NullableStringFieldUpdateOperationsInput | string | null
    peso_caj?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cal_palet?: NullableStringFieldUpdateOperationsInput | string | null
    saturacion?: NullableStringFieldUpdateOperationsInput | string | null
    porc_exp_c?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: NullableStringFieldUpdateOperationsInput | string | null
    porc_plu?: NullableIntFieldUpdateOperationsInput | number | null
    cod_emp?: NullableStringFieldUpdateOperationsInput | string | null
    cod_tem?: NullableStringFieldUpdateOperationsInput | string | null
    cod_envop?: NullableStringFieldUpdateOperationsInput | string | null
    peso_c?: NullableStringFieldUpdateOperationsInput | string | null
    fec_muestra?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cc_checklistUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    n_proceso?: NullableIntFieldUpdateOperationsInput | number | null
    cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_pro?: NullableStringFieldUpdateOperationsInput | string | null
    cod_linea?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cal_encerado?: NullableStringFieldUpdateOperationsInput | string | null
    porc_exp?: NullableIntFieldUpdateOperationsInput | number | null
    cal_cajas?: NullableStringFieldUpdateOperationsInput | string | null
    porc_plu_c?: NullableStringFieldUpdateOperationsInput | string | null
    peso_caj?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cal_palet?: NullableStringFieldUpdateOperationsInput | string | null
    saturacion?: NullableStringFieldUpdateOperationsInput | string | null
    porc_exp_c?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: NullableStringFieldUpdateOperationsInput | string | null
    porc_plu?: NullableIntFieldUpdateOperationsInput | number | null
    cod_emp?: NullableStringFieldUpdateOperationsInput | string | null
    cod_tem?: NullableStringFieldUpdateOperationsInput | string | null
    cod_envop?: NullableStringFieldUpdateOperationsInput | string | null
    peso_c?: NullableStringFieldUpdateOperationsInput | string | null
    fec_muestra?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cc_checklistCreateManyInput = {
    n_proceso?: number | null
    cod_esp?: string | null
    cod_var?: string | null
    cod_pro?: string | null
    cod_linea?: string | null
    fecha?: Date | string | null
    cal_encerado?: string | null
    porc_exp?: number | null
    cal_cajas?: string | null
    porc_plu_c?: string | null
    peso_caj?: Decimal | DecimalJsLike | number | string | null
    cal_palet?: string | null
    saturacion?: string | null
    porc_exp_c?: string | null
    usuario?: string | null
    porc_plu?: number | null
    cod_emp?: string | null
    cod_tem?: string | null
    cod_envop?: string | null
    peso_c?: string | null
    fec_muestra?: Date | string | null
  }

  export type cc_checklistUpdateManyMutationInput = {
    n_proceso?: NullableIntFieldUpdateOperationsInput | number | null
    cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_pro?: NullableStringFieldUpdateOperationsInput | string | null
    cod_linea?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cal_encerado?: NullableStringFieldUpdateOperationsInput | string | null
    porc_exp?: NullableIntFieldUpdateOperationsInput | number | null
    cal_cajas?: NullableStringFieldUpdateOperationsInput | string | null
    porc_plu_c?: NullableStringFieldUpdateOperationsInput | string | null
    peso_caj?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cal_palet?: NullableStringFieldUpdateOperationsInput | string | null
    saturacion?: NullableStringFieldUpdateOperationsInput | string | null
    porc_exp_c?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: NullableStringFieldUpdateOperationsInput | string | null
    porc_plu?: NullableIntFieldUpdateOperationsInput | number | null
    cod_emp?: NullableStringFieldUpdateOperationsInput | string | null
    cod_tem?: NullableStringFieldUpdateOperationsInput | string | null
    cod_envop?: NullableStringFieldUpdateOperationsInput | string | null
    peso_c?: NullableStringFieldUpdateOperationsInput | string | null
    fec_muestra?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cc_checklistUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    n_proceso?: NullableIntFieldUpdateOperationsInput | number | null
    cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_pro?: NullableStringFieldUpdateOperationsInput | string | null
    cod_linea?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cal_encerado?: NullableStringFieldUpdateOperationsInput | string | null
    porc_exp?: NullableIntFieldUpdateOperationsInput | number | null
    cal_cajas?: NullableStringFieldUpdateOperationsInput | string | null
    porc_plu_c?: NullableStringFieldUpdateOperationsInput | string | null
    peso_caj?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cal_palet?: NullableStringFieldUpdateOperationsInput | string | null
    saturacion?: NullableStringFieldUpdateOperationsInput | string | null
    porc_exp_c?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: NullableStringFieldUpdateOperationsInput | string | null
    porc_plu?: NullableIntFieldUpdateOperationsInput | number | null
    cod_emp?: NullableStringFieldUpdateOperationsInput | string | null
    cod_tem?: NullableStringFieldUpdateOperationsInput | string | null
    cod_envop?: NullableStringFieldUpdateOperationsInput | string | null
    peso_c?: NullableStringFieldUpdateOperationsInput | string | null
    fec_muestra?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type certificacionCreateInput = {
    exportadora: string
    productor: string
    ggn: string
    fecha_emision: Date | string
    fecha_caducidad: Date | string
    vigencia: string
    especie: string
    mercados: string
  }

  export type certificacionUncheckedCreateInput = {
    id?: number
    exportadora: string
    productor: string
    ggn: string
    fecha_emision: Date | string
    fecha_caducidad: Date | string
    vigencia: string
    especie: string
    mercados: string
  }

  export type certificacionUpdateInput = {
    exportadora?: StringFieldUpdateOperationsInput | string
    productor?: StringFieldUpdateOperationsInput | string
    ggn?: StringFieldUpdateOperationsInput | string
    fecha_emision?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_caducidad?: DateTimeFieldUpdateOperationsInput | Date | string
    vigencia?: StringFieldUpdateOperationsInput | string
    especie?: StringFieldUpdateOperationsInput | string
    mercados?: StringFieldUpdateOperationsInput | string
  }

  export type certificacionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    exportadora?: StringFieldUpdateOperationsInput | string
    productor?: StringFieldUpdateOperationsInput | string
    ggn?: StringFieldUpdateOperationsInput | string
    fecha_emision?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_caducidad?: DateTimeFieldUpdateOperationsInput | Date | string
    vigencia?: StringFieldUpdateOperationsInput | string
    especie?: StringFieldUpdateOperationsInput | string
    mercados?: StringFieldUpdateOperationsInput | string
  }

  export type certificacionCreateManyInput = {
    exportadora: string
    productor: string
    ggn: string
    fecha_emision: Date | string
    fecha_caducidad: Date | string
    vigencia: string
    especie: string
    mercados: string
  }

  export type certificacionUpdateManyMutationInput = {
    exportadora?: StringFieldUpdateOperationsInput | string
    productor?: StringFieldUpdateOperationsInput | string
    ggn?: StringFieldUpdateOperationsInput | string
    fecha_emision?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_caducidad?: DateTimeFieldUpdateOperationsInput | Date | string
    vigencia?: StringFieldUpdateOperationsInput | string
    especie?: StringFieldUpdateOperationsInput | string
    mercados?: StringFieldUpdateOperationsInput | string
  }

  export type certificacionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    exportadora?: StringFieldUpdateOperationsInput | string
    productor?: StringFieldUpdateOperationsInput | string
    ggn?: StringFieldUpdateOperationsInput | string
    fecha_emision?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_caducidad?: DateTimeFieldUpdateOperationsInput | Date | string
    vigencia?: StringFieldUpdateOperationsInput | string
    especie?: StringFieldUpdateOperationsInput | string
    mercados?: StringFieldUpdateOperationsInput | string
  }

  export type correlativoCreateInput = {
    id_tip_ins?: number | null
    nro_sag?: number | null
    cod_sdp?: string | null
  }

  export type correlativoUncheckedCreateInput = {
    id_cor?: number
    id_tip_ins?: number | null
    nro_sag?: number | null
    cod_sdp?: string | null
  }

  export type correlativoUpdateInput = {
    id_tip_ins?: NullableIntFieldUpdateOperationsInput | number | null
    nro_sag?: NullableIntFieldUpdateOperationsInput | number | null
    cod_sdp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type correlativoUncheckedUpdateInput = {
    id_cor?: IntFieldUpdateOperationsInput | number
    id_tip_ins?: NullableIntFieldUpdateOperationsInput | number | null
    nro_sag?: NullableIntFieldUpdateOperationsInput | number | null
    cod_sdp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type correlativoCreateManyInput = {
    id_tip_ins?: number | null
    nro_sag?: number | null
    cod_sdp?: string | null
  }

  export type correlativoUpdateManyMutationInput = {
    id_tip_ins?: NullableIntFieldUpdateOperationsInput | number | null
    nro_sag?: NullableIntFieldUpdateOperationsInput | number | null
    cod_sdp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type correlativoUncheckedUpdateManyInput = {
    id_cor?: IntFieldUpdateOperationsInput | number
    id_tip_ins?: NullableIntFieldUpdateOperationsInput | number | null
    nro_sag?: NullableIntFieldUpdateOperationsInput | number | null
    cod_sdp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type env_x_sellarCreateInput = {
    cod_envop: string
    cod_esp: string
    cod_exp: string
  }

  export type env_x_sellarUncheckedCreateInput = {
    id?: number
    cod_envop: string
    cod_esp: string
    cod_exp: string
  }

  export type env_x_sellarUpdateInput = {
    cod_envop?: StringFieldUpdateOperationsInput | string
    cod_esp?: StringFieldUpdateOperationsInput | string
    cod_exp?: StringFieldUpdateOperationsInput | string
  }

  export type env_x_sellarUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cod_envop?: StringFieldUpdateOperationsInput | string
    cod_esp?: StringFieldUpdateOperationsInput | string
    cod_exp?: StringFieldUpdateOperationsInput | string
  }

  export type env_x_sellarCreateManyInput = {
    cod_envop: string
    cod_esp: string
    cod_exp: string
  }

  export type env_x_sellarUpdateManyMutationInput = {
    cod_envop?: StringFieldUpdateOperationsInput | string
    cod_esp?: StringFieldUpdateOperationsInput | string
    cod_exp?: StringFieldUpdateOperationsInput | string
  }

  export type env_x_sellarUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cod_envop?: StringFieldUpdateOperationsInput | string
    cod_esp?: StringFieldUpdateOperationsInput | string
    cod_exp?: StringFieldUpdateOperationsInput | string
  }

  export type estadosCreateInput = {
    des_est_ins?: string | null
    tip_sdt?: string | null
    id_tip_ins?: number | null
  }

  export type estadosUncheckedCreateInput = {
    id_est_ins?: number
    des_est_ins?: string | null
    tip_sdt?: string | null
    id_tip_ins?: number | null
  }

  export type estadosUpdateInput = {
    des_est_ins?: NullableStringFieldUpdateOperationsInput | string | null
    tip_sdt?: NullableStringFieldUpdateOperationsInput | string | null
    id_tip_ins?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type estadosUncheckedUpdateInput = {
    id_est_ins?: IntFieldUpdateOperationsInput | number
    des_est_ins?: NullableStringFieldUpdateOperationsInput | string | null
    tip_sdt?: NullableStringFieldUpdateOperationsInput | string | null
    id_tip_ins?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type estadosCreateManyInput = {
    des_est_ins?: string | null
    tip_sdt?: string | null
    id_tip_ins?: number | null
  }

  export type estadosUpdateManyMutationInput = {
    des_est_ins?: NullableStringFieldUpdateOperationsInput | string | null
    tip_sdt?: NullableStringFieldUpdateOperationsInput | string | null
    id_tip_ins?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type estadosUncheckedUpdateManyInput = {
    id_est_ins?: IntFieldUpdateOperationsInput | number
    des_est_ins?: NullableStringFieldUpdateOperationsInput | string | null
    tip_sdt?: NullableStringFieldUpdateOperationsInput | string | null
    id_tip_ins?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type foliosCreateInput = {
    folio: string
    nom_var?: string | null
    cod_var?: string | null
    cajas?: number | null
    fecha?: Date | string | null
    calibre?: string | null
    embalaje?: string | null
  }

  export type foliosUncheckedCreateInput = {
    folio: string
    nom_var?: string | null
    cod_var?: string | null
    cajas?: number | null
    fecha?: Date | string | null
    calibre?: string | null
    embalaje?: string | null
  }

  export type foliosUpdateInput = {
    folio?: StringFieldUpdateOperationsInput | string
    nom_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cajas?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calibre?: NullableStringFieldUpdateOperationsInput | string | null
    embalaje?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type foliosUncheckedUpdateInput = {
    folio?: StringFieldUpdateOperationsInput | string
    nom_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cajas?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calibre?: NullableStringFieldUpdateOperationsInput | string | null
    embalaje?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type foliosCreateManyInput = {
    folio: string
    nom_var?: string | null
    cod_var?: string | null
    cajas?: number | null
    fecha?: Date | string | null
    calibre?: string | null
    embalaje?: string | null
  }

  export type foliosUpdateManyMutationInput = {
    folio?: StringFieldUpdateOperationsInput | string
    nom_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cajas?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calibre?: NullableStringFieldUpdateOperationsInput | string | null
    embalaje?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type foliosUncheckedUpdateManyInput = {
    folio?: StringFieldUpdateOperationsInput | string
    nom_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cajas?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calibre?: NullableStringFieldUpdateOperationsInput | string | null
    embalaje?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type folios_frioCreateInput = {
    folio: string
    nom_var?: string | null
    cod_var?: string | null
    cajas?: number | null
    fecha?: Date | string | null
    calibre?: string | null
    embalaje?: string | null
  }

  export type folios_frioUncheckedCreateInput = {
    folio: string
    nom_var?: string | null
    cod_var?: string | null
    cajas?: number | null
    fecha?: Date | string | null
    calibre?: string | null
    embalaje?: string | null
  }

  export type folios_frioUpdateInput = {
    folio?: StringFieldUpdateOperationsInput | string
    nom_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cajas?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calibre?: NullableStringFieldUpdateOperationsInput | string | null
    embalaje?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type folios_frioUncheckedUpdateInput = {
    folio?: StringFieldUpdateOperationsInput | string
    nom_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cajas?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calibre?: NullableStringFieldUpdateOperationsInput | string | null
    embalaje?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type folios_frioCreateManyInput = {
    folio: string
    nom_var?: string | null
    cod_var?: string | null
    cajas?: number | null
    fecha?: Date | string | null
    calibre?: string | null
    embalaje?: string | null
  }

  export type folios_frioUpdateManyMutationInput = {
    folio?: StringFieldUpdateOperationsInput | string
    nom_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cajas?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calibre?: NullableStringFieldUpdateOperationsInput | string | null
    embalaje?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type folios_frioUncheckedUpdateManyInput = {
    folio?: StringFieldUpdateOperationsInput | string
    nom_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cajas?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calibre?: NullableStringFieldUpdateOperationsInput | string | null
    embalaje?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type folios_packCreateInput = {
    folio: string
    nom_var?: string | null
    cod_var?: string | null
    cajas?: number | null
    fecha?: Date | string | null
    calibre?: string | null
    embalaje?: string | null
  }

  export type folios_packUncheckedCreateInput = {
    folio: string
    nom_var?: string | null
    cod_var?: string | null
    cajas?: number | null
    fecha?: Date | string | null
    calibre?: string | null
    embalaje?: string | null
  }

  export type folios_packUpdateInput = {
    folio?: StringFieldUpdateOperationsInput | string
    nom_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cajas?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calibre?: NullableStringFieldUpdateOperationsInput | string | null
    embalaje?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type folios_packUncheckedUpdateInput = {
    folio?: StringFieldUpdateOperationsInput | string
    nom_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cajas?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calibre?: NullableStringFieldUpdateOperationsInput | string | null
    embalaje?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type folios_packCreateManyInput = {
    folio: string
    nom_var?: string | null
    cod_var?: string | null
    cajas?: number | null
    fecha?: Date | string | null
    calibre?: string | null
    embalaje?: string | null
  }

  export type folios_packUpdateManyMutationInput = {
    folio?: StringFieldUpdateOperationsInput | string
    nom_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cajas?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calibre?: NullableStringFieldUpdateOperationsInput | string | null
    embalaje?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type folios_packUncheckedUpdateManyInput = {
    folio?: StringFieldUpdateOperationsInput | string
    nom_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cajas?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calibre?: NullableStringFieldUpdateOperationsInput | string | null
    embalaje?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type folios_seCreateInput = {
    folio: string
    nom_var?: string | null
    cod_var?: string | null
    cajas?: number | null
    fecha?: Date | string | null
    calibre?: string | null
    embalaje?: string | null
  }

  export type folios_seUncheckedCreateInput = {
    folio: string
    nom_var?: string | null
    cod_var?: string | null
    cajas?: number | null
    fecha?: Date | string | null
    calibre?: string | null
    embalaje?: string | null
  }

  export type folios_seUpdateInput = {
    folio?: StringFieldUpdateOperationsInput | string
    nom_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cajas?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calibre?: NullableStringFieldUpdateOperationsInput | string | null
    embalaje?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type folios_seUncheckedUpdateInput = {
    folio?: StringFieldUpdateOperationsInput | string
    nom_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cajas?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calibre?: NullableStringFieldUpdateOperationsInput | string | null
    embalaje?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type folios_seCreateManyInput = {
    folio: string
    nom_var?: string | null
    cod_var?: string | null
    cajas?: number | null
    fecha?: Date | string | null
    calibre?: string | null
    embalaje?: string | null
  }

  export type folios_seUpdateManyMutationInput = {
    folio?: StringFieldUpdateOperationsInput | string
    nom_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cajas?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calibre?: NullableStringFieldUpdateOperationsInput | string | null
    embalaje?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type folios_seUncheckedUpdateManyInput = {
    folio?: StringFieldUpdateOperationsInput | string
    nom_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cajas?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calibre?: NullableStringFieldUpdateOperationsInput | string | null
    embalaje?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fr_repa_cabCreateInput = {
    fec_rep?: Date | string | null
    id_tip_rep?: number | null
    fr_cod_pac?: string | null
    fr_cod_fri?: string | null
    fr_usu?: string | null
    fr_rep_sag?: Buffer | null
    fr_cod_tem?: string | null
    fr_cod_emp?: string | null
    fr_tra_sdt?: string | null
    fr_nro_rep?: number | null
    fr_cod_esp?: string | null
  }

  export type fr_repa_cabUncheckedCreateInput = {
    id?: number
    fec_rep?: Date | string | null
    id_tip_rep?: number | null
    fr_cod_pac?: string | null
    fr_cod_fri?: string | null
    fr_usu?: string | null
    fr_rep_sag?: Buffer | null
    fr_cod_tem?: string | null
    fr_cod_emp?: string | null
    fr_tra_sdt?: string | null
    fr_nro_rep?: number | null
    fr_cod_esp?: string | null
  }

  export type fr_repa_cabUpdateInput = {
    fec_rep?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_tip_rep?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_pac?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_fri?: NullableStringFieldUpdateOperationsInput | string | null
    fr_usu?: NullableStringFieldUpdateOperationsInput | string | null
    fr_rep_sag?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fr_cod_tem?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_emp?: NullableStringFieldUpdateOperationsInput | string | null
    fr_tra_sdt?: NullableStringFieldUpdateOperationsInput | string | null
    fr_nro_rep?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fr_repa_cabUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fec_rep?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_tip_rep?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_pac?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_fri?: NullableStringFieldUpdateOperationsInput | string | null
    fr_usu?: NullableStringFieldUpdateOperationsInput | string | null
    fr_rep_sag?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fr_cod_tem?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_emp?: NullableStringFieldUpdateOperationsInput | string | null
    fr_tra_sdt?: NullableStringFieldUpdateOperationsInput | string | null
    fr_nro_rep?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fr_repa_cabCreateManyInput = {
    fec_rep?: Date | string | null
    id_tip_rep?: number | null
    fr_cod_pac?: string | null
    fr_cod_fri?: string | null
    fr_usu?: string | null
    fr_rep_sag?: Buffer | null
    fr_cod_tem?: string | null
    fr_cod_emp?: string | null
    fr_tra_sdt?: string | null
    fr_nro_rep?: number | null
    fr_cod_esp?: string | null
  }

  export type fr_repa_cabUpdateManyMutationInput = {
    fec_rep?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_tip_rep?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_pac?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_fri?: NullableStringFieldUpdateOperationsInput | string | null
    fr_usu?: NullableStringFieldUpdateOperationsInput | string | null
    fr_rep_sag?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fr_cod_tem?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_emp?: NullableStringFieldUpdateOperationsInput | string | null
    fr_tra_sdt?: NullableStringFieldUpdateOperationsInput | string | null
    fr_nro_rep?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fr_repa_cabUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fec_rep?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_tip_rep?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_pac?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_fri?: NullableStringFieldUpdateOperationsInput | string | null
    fr_usu?: NullableStringFieldUpdateOperationsInput | string | null
    fr_rep_sag?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fr_cod_tem?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_emp?: NullableStringFieldUpdateOperationsInput | string | null
    fr_tra_sdt?: NullableStringFieldUpdateOperationsInput | string | null
    fr_nro_rep?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fr_repa_detCreateInput = {
    id_rep_cab?: number | null
    fr_lote?: string | null
    fr_cor_sdt?: Decimal | DecimalJsLike | number | string | null
    fr_pla_sdt?: number | null
    fr_est_sdt?: string | null
    fr_fec_pac?: Date | string | null
    fr_fec_rpa?: Date | string | null
    fr_gui_sdt?: number | null
    fr_cod_pro?: string | null
    fr_cod_esp?: string | null
    fr_cod_var?: string | null
    fr_hor_rec?: Date | string | null
    fr_con?: string | null
    fr_tip_lot?: string | null
    fr_alt_pal?: string | null
    fr_cod_env?: string | null
    fr_cod_eti?: string | null
    fr_cod_emb?: string | null
    fr_cod_envop?: string | null
    fr_plu?: string | null
    fr_caj?: number | null
    fr_cod_cat?: string | null
    fr_cod_cal?: string | null
    fr_nro_mix?: number | null
    fr_fec_sem?: string | null
    fr_cod_bp?: string | null
    fr_cod_pre?: string | null
    fr_cod_cua?: string | null
    fr_proceso?: number | null
    fr_con_fri?: string | null
    fr_fol_ori?: string | null
    fr_cod_var_eti?: string | null
    fr_cod_tip_tra?: string | null
    fr_cod_pro_eti?: string | null
    fr_cod_exp?: string | null
    fr_pk_ori?: number | null
    id_tip_io?: number | null
    fr_caj_usa?: number | null
    fr_tip_mov?: string | null
    fr_fec_sag?: Date | string | null
    fr_guia_sag?: number | null
    fr_cer_sag?: string | null
    fr_sol_sag?: string | null
    fr_tip_sag?: string | null
    fr_cod_mer?: string | null
    fr_cod_mer1?: string | null
    fr_cod_mer2?: string | null
    fr_cod_mer3?: string | null
    fr_cod_mer4?: string | null
    fr_fec_fum?: Date | string | null
    fr_guia_fum?: number | null
    fr_cer_fum?: string | null
    fr_cod_tipo_fum?: string | null
    fr_pfrio?: string | null
    fr_correlativo_rec?: number | null
    fr_cod_linea?: string | null
    fr_peso_original?: Decimal | DecimalJsLike | number | string | null
  }

  export type fr_repa_detUncheckedCreateInput = {
    id?: number
    id_rep_cab?: number | null
    fr_lote?: string | null
    fr_cor_sdt?: Decimal | DecimalJsLike | number | string | null
    fr_pla_sdt?: number | null
    fr_est_sdt?: string | null
    fr_fec_pac?: Date | string | null
    fr_fec_rpa?: Date | string | null
    fr_gui_sdt?: number | null
    fr_cod_pro?: string | null
    fr_cod_esp?: string | null
    fr_cod_var?: string | null
    fr_hor_rec?: Date | string | null
    fr_con?: string | null
    fr_tip_lot?: string | null
    fr_alt_pal?: string | null
    fr_cod_env?: string | null
    fr_cod_eti?: string | null
    fr_cod_emb?: string | null
    fr_cod_envop?: string | null
    fr_plu?: string | null
    fr_caj?: number | null
    fr_cod_cat?: string | null
    fr_cod_cal?: string | null
    fr_nro_mix?: number | null
    fr_fec_sem?: string | null
    fr_cod_bp?: string | null
    fr_cod_pre?: string | null
    fr_cod_cua?: string | null
    fr_proceso?: number | null
    fr_con_fri?: string | null
    fr_fol_ori?: string | null
    fr_cod_var_eti?: string | null
    fr_cod_tip_tra?: string | null
    fr_cod_pro_eti?: string | null
    fr_cod_exp?: string | null
    fr_pk_ori?: number | null
    id_tip_io?: number | null
    fr_caj_usa?: number | null
    fr_tip_mov?: string | null
    fr_fec_sag?: Date | string | null
    fr_guia_sag?: number | null
    fr_cer_sag?: string | null
    fr_sol_sag?: string | null
    fr_tip_sag?: string | null
    fr_cod_mer?: string | null
    fr_cod_mer1?: string | null
    fr_cod_mer2?: string | null
    fr_cod_mer3?: string | null
    fr_cod_mer4?: string | null
    fr_fec_fum?: Date | string | null
    fr_guia_fum?: number | null
    fr_cer_fum?: string | null
    fr_cod_tipo_fum?: string | null
    fr_pfrio?: string | null
    fr_correlativo_rec?: number | null
    fr_cod_linea?: string | null
    fr_peso_original?: Decimal | DecimalJsLike | number | string | null
  }

  export type fr_repa_detUpdateInput = {
    id_rep_cab?: NullableIntFieldUpdateOperationsInput | number | null
    fr_lote?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cor_sdt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fr_pla_sdt?: NullableIntFieldUpdateOperationsInput | number | null
    fr_est_sdt?: NullableStringFieldUpdateOperationsInput | string | null
    fr_fec_pac?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_fec_rpa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_gui_sdt?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_pro?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    fr_hor_rec?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_con?: NullableStringFieldUpdateOperationsInput | string | null
    fr_tip_lot?: NullableStringFieldUpdateOperationsInput | string | null
    fr_alt_pal?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_env?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_eti?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_emb?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_envop?: NullableStringFieldUpdateOperationsInput | string | null
    fr_plu?: NullableStringFieldUpdateOperationsInput | string | null
    fr_caj?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_cat?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_cal?: NullableStringFieldUpdateOperationsInput | string | null
    fr_nro_mix?: NullableIntFieldUpdateOperationsInput | number | null
    fr_fec_sem?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_bp?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_pre?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_cua?: NullableStringFieldUpdateOperationsInput | string | null
    fr_proceso?: NullableIntFieldUpdateOperationsInput | number | null
    fr_con_fri?: NullableStringFieldUpdateOperationsInput | string | null
    fr_fol_ori?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_var_eti?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_tip_tra?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_pro_eti?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_exp?: NullableStringFieldUpdateOperationsInput | string | null
    fr_pk_ori?: NullableIntFieldUpdateOperationsInput | number | null
    id_tip_io?: NullableIntFieldUpdateOperationsInput | number | null
    fr_caj_usa?: NullableIntFieldUpdateOperationsInput | number | null
    fr_tip_mov?: NullableStringFieldUpdateOperationsInput | string | null
    fr_fec_sag?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_guia_sag?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cer_sag?: NullableStringFieldUpdateOperationsInput | string | null
    fr_sol_sag?: NullableStringFieldUpdateOperationsInput | string | null
    fr_tip_sag?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer1?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer2?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer3?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer4?: NullableStringFieldUpdateOperationsInput | string | null
    fr_fec_fum?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_guia_fum?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cer_fum?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_tipo_fum?: NullableStringFieldUpdateOperationsInput | string | null
    fr_pfrio?: NullableStringFieldUpdateOperationsInput | string | null
    fr_correlativo_rec?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_linea?: NullableStringFieldUpdateOperationsInput | string | null
    fr_peso_original?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type fr_repa_detUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_rep_cab?: NullableIntFieldUpdateOperationsInput | number | null
    fr_lote?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cor_sdt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fr_pla_sdt?: NullableIntFieldUpdateOperationsInput | number | null
    fr_est_sdt?: NullableStringFieldUpdateOperationsInput | string | null
    fr_fec_pac?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_fec_rpa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_gui_sdt?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_pro?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    fr_hor_rec?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_con?: NullableStringFieldUpdateOperationsInput | string | null
    fr_tip_lot?: NullableStringFieldUpdateOperationsInput | string | null
    fr_alt_pal?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_env?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_eti?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_emb?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_envop?: NullableStringFieldUpdateOperationsInput | string | null
    fr_plu?: NullableStringFieldUpdateOperationsInput | string | null
    fr_caj?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_cat?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_cal?: NullableStringFieldUpdateOperationsInput | string | null
    fr_nro_mix?: NullableIntFieldUpdateOperationsInput | number | null
    fr_fec_sem?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_bp?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_pre?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_cua?: NullableStringFieldUpdateOperationsInput | string | null
    fr_proceso?: NullableIntFieldUpdateOperationsInput | number | null
    fr_con_fri?: NullableStringFieldUpdateOperationsInput | string | null
    fr_fol_ori?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_var_eti?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_tip_tra?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_pro_eti?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_exp?: NullableStringFieldUpdateOperationsInput | string | null
    fr_pk_ori?: NullableIntFieldUpdateOperationsInput | number | null
    id_tip_io?: NullableIntFieldUpdateOperationsInput | number | null
    fr_caj_usa?: NullableIntFieldUpdateOperationsInput | number | null
    fr_tip_mov?: NullableStringFieldUpdateOperationsInput | string | null
    fr_fec_sag?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_guia_sag?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cer_sag?: NullableStringFieldUpdateOperationsInput | string | null
    fr_sol_sag?: NullableStringFieldUpdateOperationsInput | string | null
    fr_tip_sag?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer1?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer2?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer3?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer4?: NullableStringFieldUpdateOperationsInput | string | null
    fr_fec_fum?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_guia_fum?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cer_fum?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_tipo_fum?: NullableStringFieldUpdateOperationsInput | string | null
    fr_pfrio?: NullableStringFieldUpdateOperationsInput | string | null
    fr_correlativo_rec?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_linea?: NullableStringFieldUpdateOperationsInput | string | null
    fr_peso_original?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type fr_repa_detCreateManyInput = {
    id_rep_cab?: number | null
    fr_lote?: string | null
    fr_cor_sdt?: Decimal | DecimalJsLike | number | string | null
    fr_pla_sdt?: number | null
    fr_est_sdt?: string | null
    fr_fec_pac?: Date | string | null
    fr_fec_rpa?: Date | string | null
    fr_gui_sdt?: number | null
    fr_cod_pro?: string | null
    fr_cod_esp?: string | null
    fr_cod_var?: string | null
    fr_hor_rec?: Date | string | null
    fr_con?: string | null
    fr_tip_lot?: string | null
    fr_alt_pal?: string | null
    fr_cod_env?: string | null
    fr_cod_eti?: string | null
    fr_cod_emb?: string | null
    fr_cod_envop?: string | null
    fr_plu?: string | null
    fr_caj?: number | null
    fr_cod_cat?: string | null
    fr_cod_cal?: string | null
    fr_nro_mix?: number | null
    fr_fec_sem?: string | null
    fr_cod_bp?: string | null
    fr_cod_pre?: string | null
    fr_cod_cua?: string | null
    fr_proceso?: number | null
    fr_con_fri?: string | null
    fr_fol_ori?: string | null
    fr_cod_var_eti?: string | null
    fr_cod_tip_tra?: string | null
    fr_cod_pro_eti?: string | null
    fr_cod_exp?: string | null
    fr_pk_ori?: number | null
    id_tip_io?: number | null
    fr_caj_usa?: number | null
    fr_tip_mov?: string | null
    fr_fec_sag?: Date | string | null
    fr_guia_sag?: number | null
    fr_cer_sag?: string | null
    fr_sol_sag?: string | null
    fr_tip_sag?: string | null
    fr_cod_mer?: string | null
    fr_cod_mer1?: string | null
    fr_cod_mer2?: string | null
    fr_cod_mer3?: string | null
    fr_cod_mer4?: string | null
    fr_fec_fum?: Date | string | null
    fr_guia_fum?: number | null
    fr_cer_fum?: string | null
    fr_cod_tipo_fum?: string | null
    fr_pfrio?: string | null
    fr_correlativo_rec?: number | null
    fr_cod_linea?: string | null
    fr_peso_original?: Decimal | DecimalJsLike | number | string | null
  }

  export type fr_repa_detUpdateManyMutationInput = {
    id_rep_cab?: NullableIntFieldUpdateOperationsInput | number | null
    fr_lote?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cor_sdt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fr_pla_sdt?: NullableIntFieldUpdateOperationsInput | number | null
    fr_est_sdt?: NullableStringFieldUpdateOperationsInput | string | null
    fr_fec_pac?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_fec_rpa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_gui_sdt?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_pro?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    fr_hor_rec?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_con?: NullableStringFieldUpdateOperationsInput | string | null
    fr_tip_lot?: NullableStringFieldUpdateOperationsInput | string | null
    fr_alt_pal?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_env?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_eti?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_emb?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_envop?: NullableStringFieldUpdateOperationsInput | string | null
    fr_plu?: NullableStringFieldUpdateOperationsInput | string | null
    fr_caj?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_cat?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_cal?: NullableStringFieldUpdateOperationsInput | string | null
    fr_nro_mix?: NullableIntFieldUpdateOperationsInput | number | null
    fr_fec_sem?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_bp?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_pre?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_cua?: NullableStringFieldUpdateOperationsInput | string | null
    fr_proceso?: NullableIntFieldUpdateOperationsInput | number | null
    fr_con_fri?: NullableStringFieldUpdateOperationsInput | string | null
    fr_fol_ori?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_var_eti?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_tip_tra?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_pro_eti?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_exp?: NullableStringFieldUpdateOperationsInput | string | null
    fr_pk_ori?: NullableIntFieldUpdateOperationsInput | number | null
    id_tip_io?: NullableIntFieldUpdateOperationsInput | number | null
    fr_caj_usa?: NullableIntFieldUpdateOperationsInput | number | null
    fr_tip_mov?: NullableStringFieldUpdateOperationsInput | string | null
    fr_fec_sag?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_guia_sag?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cer_sag?: NullableStringFieldUpdateOperationsInput | string | null
    fr_sol_sag?: NullableStringFieldUpdateOperationsInput | string | null
    fr_tip_sag?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer1?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer2?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer3?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer4?: NullableStringFieldUpdateOperationsInput | string | null
    fr_fec_fum?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_guia_fum?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cer_fum?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_tipo_fum?: NullableStringFieldUpdateOperationsInput | string | null
    fr_pfrio?: NullableStringFieldUpdateOperationsInput | string | null
    fr_correlativo_rec?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_linea?: NullableStringFieldUpdateOperationsInput | string | null
    fr_peso_original?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type fr_repa_detUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_rep_cab?: NullableIntFieldUpdateOperationsInput | number | null
    fr_lote?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cor_sdt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fr_pla_sdt?: NullableIntFieldUpdateOperationsInput | number | null
    fr_est_sdt?: NullableStringFieldUpdateOperationsInput | string | null
    fr_fec_pac?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_fec_rpa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_gui_sdt?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_pro?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    fr_hor_rec?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_con?: NullableStringFieldUpdateOperationsInput | string | null
    fr_tip_lot?: NullableStringFieldUpdateOperationsInput | string | null
    fr_alt_pal?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_env?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_eti?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_emb?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_envop?: NullableStringFieldUpdateOperationsInput | string | null
    fr_plu?: NullableStringFieldUpdateOperationsInput | string | null
    fr_caj?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_cat?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_cal?: NullableStringFieldUpdateOperationsInput | string | null
    fr_nro_mix?: NullableIntFieldUpdateOperationsInput | number | null
    fr_fec_sem?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_bp?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_pre?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_cua?: NullableStringFieldUpdateOperationsInput | string | null
    fr_proceso?: NullableIntFieldUpdateOperationsInput | number | null
    fr_con_fri?: NullableStringFieldUpdateOperationsInput | string | null
    fr_fol_ori?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_var_eti?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_tip_tra?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_pro_eti?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_exp?: NullableStringFieldUpdateOperationsInput | string | null
    fr_pk_ori?: NullableIntFieldUpdateOperationsInput | number | null
    id_tip_io?: NullableIntFieldUpdateOperationsInput | number | null
    fr_caj_usa?: NullableIntFieldUpdateOperationsInput | number | null
    fr_tip_mov?: NullableStringFieldUpdateOperationsInput | string | null
    fr_fec_sag?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_guia_sag?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cer_sag?: NullableStringFieldUpdateOperationsInput | string | null
    fr_sol_sag?: NullableStringFieldUpdateOperationsInput | string | null
    fr_tip_sag?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer1?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer2?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer3?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_mer4?: NullableStringFieldUpdateOperationsInput | string | null
    fr_fec_fum?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fr_guia_fum?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cer_fum?: NullableStringFieldUpdateOperationsInput | string | null
    fr_cod_tipo_fum?: NullableStringFieldUpdateOperationsInput | string | null
    fr_pfrio?: NullableStringFieldUpdateOperationsInput | string | null
    fr_correlativo_rec?: NullableIntFieldUpdateOperationsInput | number | null
    fr_cod_linea?: NullableStringFieldUpdateOperationsInput | string | null
    fr_peso_original?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type Gr_Tipo_CobroCreateInput = {
    Descripcion?: string | null
    tipo_c?: number | null
  }

  export type Gr_Tipo_CobroUncheckedCreateInput = {
    id?: number
    Descripcion?: string | null
    tipo_c?: number | null
  }

  export type Gr_Tipo_CobroUpdateInput = {
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_c?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Gr_Tipo_CobroUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_c?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Gr_Tipo_CobroCreateManyInput = {
    Descripcion?: string | null
    tipo_c?: number | null
  }

  export type Gr_Tipo_CobroUpdateManyMutationInput = {
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_c?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Gr_Tipo_CobroUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_c?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type insp_cabCreateInput = {
    nro_sag?: number | null
    cod_csp?: string | null
    id_tip_ins?: number | null
    fec_doc?: Date | string | null
    fec_ins?: Date | string | null
    id_usuario?: string | null
    cod_mer?: string | null
    cod_mer1?: string | null
    cod_mer2?: string | null
    cod_mer3?: string | null
    obs_insp?: string | null
    id_est_ins?: number | null
  }

  export type insp_cabUncheckedCreateInput = {
    id_ins?: number
    nro_sag?: number | null
    cod_csp?: string | null
    id_tip_ins?: number | null
    fec_doc?: Date | string | null
    fec_ins?: Date | string | null
    id_usuario?: string | null
    cod_mer?: string | null
    cod_mer1?: string | null
    cod_mer2?: string | null
    cod_mer3?: string | null
    obs_insp?: string | null
    id_est_ins?: number | null
  }

  export type insp_cabUpdateInput = {
    nro_sag?: NullableIntFieldUpdateOperationsInput | number | null
    cod_csp?: NullableStringFieldUpdateOperationsInput | string | null
    id_tip_ins?: NullableIntFieldUpdateOperationsInput | number | null
    fec_doc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fec_ins?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_usuario?: NullableStringFieldUpdateOperationsInput | string | null
    cod_mer?: NullableStringFieldUpdateOperationsInput | string | null
    cod_mer1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_mer2?: NullableStringFieldUpdateOperationsInput | string | null
    cod_mer3?: NullableStringFieldUpdateOperationsInput | string | null
    obs_insp?: NullableStringFieldUpdateOperationsInput | string | null
    id_est_ins?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type insp_cabUncheckedUpdateInput = {
    id_ins?: IntFieldUpdateOperationsInput | number
    nro_sag?: NullableIntFieldUpdateOperationsInput | number | null
    cod_csp?: NullableStringFieldUpdateOperationsInput | string | null
    id_tip_ins?: NullableIntFieldUpdateOperationsInput | number | null
    fec_doc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fec_ins?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_usuario?: NullableStringFieldUpdateOperationsInput | string | null
    cod_mer?: NullableStringFieldUpdateOperationsInput | string | null
    cod_mer1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_mer2?: NullableStringFieldUpdateOperationsInput | string | null
    cod_mer3?: NullableStringFieldUpdateOperationsInput | string | null
    obs_insp?: NullableStringFieldUpdateOperationsInput | string | null
    id_est_ins?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type insp_cabCreateManyInput = {
    nro_sag?: number | null
    cod_csp?: string | null
    id_tip_ins?: number | null
    fec_doc?: Date | string | null
    fec_ins?: Date | string | null
    id_usuario?: string | null
    cod_mer?: string | null
    cod_mer1?: string | null
    cod_mer2?: string | null
    cod_mer3?: string | null
    obs_insp?: string | null
    id_est_ins?: number | null
  }

  export type insp_cabUpdateManyMutationInput = {
    nro_sag?: NullableIntFieldUpdateOperationsInput | number | null
    cod_csp?: NullableStringFieldUpdateOperationsInput | string | null
    id_tip_ins?: NullableIntFieldUpdateOperationsInput | number | null
    fec_doc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fec_ins?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_usuario?: NullableStringFieldUpdateOperationsInput | string | null
    cod_mer?: NullableStringFieldUpdateOperationsInput | string | null
    cod_mer1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_mer2?: NullableStringFieldUpdateOperationsInput | string | null
    cod_mer3?: NullableStringFieldUpdateOperationsInput | string | null
    obs_insp?: NullableStringFieldUpdateOperationsInput | string | null
    id_est_ins?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type insp_cabUncheckedUpdateManyInput = {
    id_ins?: IntFieldUpdateOperationsInput | number
    nro_sag?: NullableIntFieldUpdateOperationsInput | number | null
    cod_csp?: NullableStringFieldUpdateOperationsInput | string | null
    id_tip_ins?: NullableIntFieldUpdateOperationsInput | number | null
    fec_doc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fec_ins?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_usuario?: NullableStringFieldUpdateOperationsInput | string | null
    cod_mer?: NullableStringFieldUpdateOperationsInput | string | null
    cod_mer1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_mer2?: NullableStringFieldUpdateOperationsInput | string | null
    cod_mer3?: NullableStringFieldUpdateOperationsInput | string | null
    obs_insp?: NullableStringFieldUpdateOperationsInput | string | null
    id_est_ins?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mae_sta_elenaCreateInput = {
    cod_emb: string
  }

  export type mae_sta_elenaUncheckedCreateInput = {
    cod_emb: string
  }

  export type mae_sta_elenaUpdateInput = {
    cod_emb?: StringFieldUpdateOperationsInput | string
  }

  export type mae_sta_elenaUncheckedUpdateInput = {
    cod_emb?: StringFieldUpdateOperationsInput | string
  }

  export type mae_sta_elenaCreateManyInput = {
    cod_emb: string
  }

  export type mae_sta_elenaUpdateManyMutationInput = {
    cod_emb?: StringFieldUpdateOperationsInput | string
  }

  export type mae_sta_elenaUncheckedUpdateManyInput = {
    cod_emb?: StringFieldUpdateOperationsInput | string
  }

  export type maestro_pluCreateInput = {
    cod_envop: string
    cod_cal: string
    cod_plu: string
  }

  export type maestro_pluUncheckedCreateInput = {
    cod_envop: string
    cod_cal: string
    cod_plu: string
  }

  export type maestro_pluUpdateInput = {
    cod_envop?: StringFieldUpdateOperationsInput | string
    cod_cal?: StringFieldUpdateOperationsInput | string
    cod_plu?: StringFieldUpdateOperationsInput | string
  }

  export type maestro_pluUncheckedUpdateInput = {
    cod_envop?: StringFieldUpdateOperationsInput | string
    cod_cal?: StringFieldUpdateOperationsInput | string
    cod_plu?: StringFieldUpdateOperationsInput | string
  }

  export type maestro_pluCreateManyInput = {
    cod_envop: string
    cod_cal: string
    cod_plu: string
  }

  export type maestro_pluUpdateManyMutationInput = {
    cod_envop?: StringFieldUpdateOperationsInput | string
    cod_cal?: StringFieldUpdateOperationsInput | string
    cod_plu?: StringFieldUpdateOperationsInput | string
  }

  export type maestro_pluUncheckedUpdateManyInput = {
    cod_envop?: StringFieldUpdateOperationsInput | string
    cod_cal?: StringFieldUpdateOperationsInput | string
    cod_plu?: StringFieldUpdateOperationsInput | string
  }

  export type pk_desver_cabCreateInput = {
    pro_nro?: number | null
    fec_ini?: Date | string | null
    fec_fin?: Date | string | null
    usu_res?: string | null
    pes_ini?: number | null
    pes_fin?: number | null
    cod_esp?: string | null
    fec_ven?: Date | string | null
  }

  export type pk_desver_cabUncheckedCreateInput = {
    id?: number
    pro_nro?: number | null
    fec_ini?: Date | string | null
    fec_fin?: Date | string | null
    usu_res?: string | null
    pes_ini?: number | null
    pes_fin?: number | null
    cod_esp?: string | null
    fec_ven?: Date | string | null
  }

  export type pk_desver_cabUpdateInput = {
    pro_nro?: NullableIntFieldUpdateOperationsInput | number | null
    fec_ini?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fec_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usu_res?: NullableStringFieldUpdateOperationsInput | string | null
    pes_ini?: NullableFloatFieldUpdateOperationsInput | number | null
    pes_fin?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    fec_ven?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pk_desver_cabUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pro_nro?: NullableIntFieldUpdateOperationsInput | number | null
    fec_ini?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fec_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usu_res?: NullableStringFieldUpdateOperationsInput | string | null
    pes_ini?: NullableFloatFieldUpdateOperationsInput | number | null
    pes_fin?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    fec_ven?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pk_desver_cabCreateManyInput = {
    pro_nro?: number | null
    fec_ini?: Date | string | null
    fec_fin?: Date | string | null
    usu_res?: string | null
    pes_ini?: number | null
    pes_fin?: number | null
    cod_esp?: string | null
    fec_ven?: Date | string | null
  }

  export type pk_desver_cabUpdateManyMutationInput = {
    pro_nro?: NullableIntFieldUpdateOperationsInput | number | null
    fec_ini?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fec_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usu_res?: NullableStringFieldUpdateOperationsInput | string | null
    pes_ini?: NullableFloatFieldUpdateOperationsInput | number | null
    pes_fin?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    fec_ven?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pk_desver_cabUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pro_nro?: NullableIntFieldUpdateOperationsInput | number | null
    fec_ini?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fec_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usu_res?: NullableStringFieldUpdateOperationsInput | string | null
    pes_ini?: NullableFloatFieldUpdateOperationsInput | number | null
    pes_fin?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    fec_ven?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pk_desver_detCreateInput = {
    id_cab?: number | null
    folio?: string | null
    cod_var?: string | null
    cod_esp?: string | null
    peso_neto?: number | null
    peso_fin?: number | null
    cod_cal?: string | null
  }

  export type pk_desver_detUncheckedCreateInput = {
    id?: number
    id_cab?: number | null
    folio?: string | null
    cod_var?: string | null
    cod_esp?: string | null
    peso_neto?: number | null
    peso_fin?: number | null
    cod_cal?: string | null
  }

  export type pk_desver_detUpdateInput = {
    id_cab?: NullableIntFieldUpdateOperationsInput | number | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    peso_neto?: NullableFloatFieldUpdateOperationsInput | number | null
    peso_fin?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_cal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pk_desver_detUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_cab?: NullableIntFieldUpdateOperationsInput | number | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    peso_neto?: NullableFloatFieldUpdateOperationsInput | number | null
    peso_fin?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_cal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pk_desver_detCreateManyInput = {
    id_cab?: number | null
    folio?: string | null
    cod_var?: string | null
    cod_esp?: string | null
    peso_neto?: number | null
    peso_fin?: number | null
    cod_cal?: string | null
  }

  export type pk_desver_detUpdateManyMutationInput = {
    id_cab?: NullableIntFieldUpdateOperationsInput | number | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    peso_neto?: NullableFloatFieldUpdateOperationsInput | number | null
    peso_fin?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_cal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pk_desver_detUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_cab?: NullableIntFieldUpdateOperationsInput | number | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    cod_var?: NullableStringFieldUpdateOperationsInput | string | null
    cod_esp?: NullableStringFieldUpdateOperationsInput | string | null
    peso_neto?: NullableFloatFieldUpdateOperationsInput | number | null
    peso_fin?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_cal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sys_logCreateInput = {
    tip_eve?: string | null
    usu_sys?: string | null
    ip_pc?: string | null
    fecha_log?: Date | string | null
    folio?: string | null
    modulo?: string | null
  }

  export type sys_logUncheckedCreateInput = {
    id?: number
    tip_eve?: string | null
    usu_sys?: string | null
    ip_pc?: string | null
    fecha_log?: Date | string | null
    folio?: string | null
    modulo?: string | null
  }

  export type sys_logUpdateInput = {
    tip_eve?: NullableStringFieldUpdateOperationsInput | string | null
    usu_sys?: NullableStringFieldUpdateOperationsInput | string | null
    ip_pc?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_log?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    modulo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sys_logUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tip_eve?: NullableStringFieldUpdateOperationsInput | string | null
    usu_sys?: NullableStringFieldUpdateOperationsInput | string | null
    ip_pc?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_log?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    modulo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sys_logCreateManyInput = {
    tip_eve?: string | null
    usu_sys?: string | null
    ip_pc?: string | null
    fecha_log?: Date | string | null
    folio?: string | null
    modulo?: string | null
  }

  export type sys_logUpdateManyMutationInput = {
    tip_eve?: NullableStringFieldUpdateOperationsInput | string | null
    usu_sys?: NullableStringFieldUpdateOperationsInput | string | null
    ip_pc?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_log?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    modulo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sys_logUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tip_eve?: NullableStringFieldUpdateOperationsInput | string | null
    usu_sys?: NullableStringFieldUpdateOperationsInput | string | null
    ip_pc?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_log?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    folio?: NullableStringFieldUpdateOperationsInput | string | null
    modulo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sysdiagramsCreateInput = {
    name: string
    principal_id: number
    version?: number | null
    definition?: Buffer | null
  }

  export type sysdiagramsUncheckedCreateInput = {
    name: string
    principal_id: number
    diagram_id?: number
    version?: number | null
    definition?: Buffer | null
  }

  export type sysdiagramsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type sysdiagramsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    diagram_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type sysdiagramsCreateManyInput = {
    name: string
    principal_id: number
    version?: number | null
    definition?: Buffer | null
  }

  export type sysdiagramsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type sysdiagramsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    diagram_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type tipo_insCreateInput = {
    des_tip_ins?: string | null
  }

  export type tipo_insUncheckedCreateInput = {
    id_tip_ins?: number
    des_tip_ins?: string | null
  }

  export type tipo_insUpdateInput = {
    des_tip_ins?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipo_insUncheckedUpdateInput = {
    id_tip_ins?: IntFieldUpdateOperationsInput | number
    des_tip_ins?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipo_insCreateManyInput = {
    des_tip_ins?: string | null
  }

  export type tipo_insUpdateManyMutationInput = {
    des_tip_ins?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipo_insUncheckedUpdateManyInput = {
    id_tip_ins?: IntFieldUpdateOperationsInput | number
    des_tip_ins?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type traductor_calibreCreateInput = {
    n_calibre_std?: string | null
    val_calibre?: number | null
    cod_exp?: string | null
    n_calibre?: string | null
  }

  export type traductor_calibreUncheckedCreateInput = {
    id?: number
    n_calibre_std?: string | null
    val_calibre?: number | null
    cod_exp?: string | null
    n_calibre?: string | null
  }

  export type traductor_calibreUpdateInput = {
    n_calibre_std?: NullableStringFieldUpdateOperationsInput | string | null
    val_calibre?: NullableIntFieldUpdateOperationsInput | number | null
    cod_exp?: NullableStringFieldUpdateOperationsInput | string | null
    n_calibre?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type traductor_calibreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    n_calibre_std?: NullableStringFieldUpdateOperationsInput | string | null
    val_calibre?: NullableIntFieldUpdateOperationsInput | number | null
    cod_exp?: NullableStringFieldUpdateOperationsInput | string | null
    n_calibre?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type traductor_calibreCreateManyInput = {
    n_calibre_std?: string | null
    val_calibre?: number | null
    cod_exp?: string | null
    n_calibre?: string | null
  }

  export type traductor_calibreUpdateManyMutationInput = {
    n_calibre_std?: NullableStringFieldUpdateOperationsInput | string | null
    val_calibre?: NullableIntFieldUpdateOperationsInput | number | null
    cod_exp?: NullableStringFieldUpdateOperationsInput | string | null
    n_calibre?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type traductor_calibreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    n_calibre_std?: NullableStringFieldUpdateOperationsInput | string | null
    val_calibre?: NullableIntFieldUpdateOperationsInput | number | null
    cod_exp?: NullableStringFieldUpdateOperationsInput | string | null
    n_calibre?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type validacion_palletsCreateInput = {
    numero_pallet?: string | null
    temporada?: number | null
  }

  export type validacion_palletsUncheckedCreateInput = {
    id?: number
    numero_pallet?: string | null
    temporada?: number | null
  }

  export type validacion_palletsUpdateInput = {
    numero_pallet?: NullableStringFieldUpdateOperationsInput | string | null
    temporada?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type validacion_palletsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_pallet?: NullableStringFieldUpdateOperationsInput | string | null
    temporada?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type validacion_palletsCreateManyInput = {
    numero_pallet?: string | null
    temporada?: number | null
  }

  export type validacion_palletsUpdateManyMutationInput = {
    numero_pallet?: NullableStringFieldUpdateOperationsInput | string | null
    temporada?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type validacion_palletsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_pallet?: NullableStringFieldUpdateOperationsInput | string | null
    temporada?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type existencias_cajasCreateInput = {
    Camara?: string | null
    Especie?: string | null
    Fecha_packing?: Date | string | null
    Hora_Packing?: string | null
    Packing: string
    Folio: string
    Productor?: string | null
    CSG?: string | null
    Marca: string
    Embalaje: string
    Linea?: string | null
    Exportadora?: string | null
    Jornada?: string | null
    Variedad?: string | null
    Calibre: string
    Categoria?: string | null
    Cajas: number
    Proceso: number
  }

  export type existencias_cajasUncheckedCreateInput = {
    Camara?: string | null
    Especie?: string | null
    Fecha_packing?: Date | string | null
    Hora_Packing?: string | null
    Packing: string
    Folio: string
    Productor?: string | null
    CSG?: string | null
    Marca: string
    Embalaje: string
    Linea?: string | null
    Exportadora?: string | null
    Jornada?: string | null
    Variedad?: string | null
    Calibre: string
    Categoria?: string | null
    Cajas: number
    Proceso: number
  }

  export type existencias_cajasUpdateInput = {
    Camara?: NullableStringFieldUpdateOperationsInput | string | null
    Especie?: NullableStringFieldUpdateOperationsInput | string | null
    Fecha_packing?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Hora_Packing?: NullableStringFieldUpdateOperationsInput | string | null
    Packing?: StringFieldUpdateOperationsInput | string
    Folio?: StringFieldUpdateOperationsInput | string
    Productor?: NullableStringFieldUpdateOperationsInput | string | null
    CSG?: NullableStringFieldUpdateOperationsInput | string | null
    Marca?: StringFieldUpdateOperationsInput | string
    Embalaje?: StringFieldUpdateOperationsInput | string
    Linea?: NullableStringFieldUpdateOperationsInput | string | null
    Exportadora?: NullableStringFieldUpdateOperationsInput | string | null
    Jornada?: NullableStringFieldUpdateOperationsInput | string | null
    Variedad?: NullableStringFieldUpdateOperationsInput | string | null
    Calibre?: StringFieldUpdateOperationsInput | string
    Categoria?: NullableStringFieldUpdateOperationsInput | string | null
    Cajas?: IntFieldUpdateOperationsInput | number
    Proceso?: IntFieldUpdateOperationsInput | number
  }

  export type existencias_cajasUncheckedUpdateInput = {
    Camara?: NullableStringFieldUpdateOperationsInput | string | null
    Especie?: NullableStringFieldUpdateOperationsInput | string | null
    Fecha_packing?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Hora_Packing?: NullableStringFieldUpdateOperationsInput | string | null
    Packing?: StringFieldUpdateOperationsInput | string
    Folio?: StringFieldUpdateOperationsInput | string
    Productor?: NullableStringFieldUpdateOperationsInput | string | null
    CSG?: NullableStringFieldUpdateOperationsInput | string | null
    Marca?: StringFieldUpdateOperationsInput | string
    Embalaje?: StringFieldUpdateOperationsInput | string
    Linea?: NullableStringFieldUpdateOperationsInput | string | null
    Exportadora?: NullableStringFieldUpdateOperationsInput | string | null
    Jornada?: NullableStringFieldUpdateOperationsInput | string | null
    Variedad?: NullableStringFieldUpdateOperationsInput | string | null
    Calibre?: StringFieldUpdateOperationsInput | string
    Categoria?: NullableStringFieldUpdateOperationsInput | string | null
    Cajas?: IntFieldUpdateOperationsInput | number
    Proceso?: IntFieldUpdateOperationsInput | number
  }

  export type existencias_cajasCreateManyInput = {
    Camara?: string | null
    Especie?: string | null
    Fecha_packing?: Date | string | null
    Hora_Packing?: string | null
    Packing: string
    Folio: string
    Productor?: string | null
    CSG?: string | null
    Marca: string
    Embalaje: string
    Linea?: string | null
    Exportadora?: string | null
    Jornada?: string | null
    Variedad?: string | null
    Calibre: string
    Categoria?: string | null
    Cajas: number
    Proceso: number
  }

  export type existencias_cajasUpdateManyMutationInput = {
    Camara?: NullableStringFieldUpdateOperationsInput | string | null
    Especie?: NullableStringFieldUpdateOperationsInput | string | null
    Fecha_packing?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Hora_Packing?: NullableStringFieldUpdateOperationsInput | string | null
    Packing?: StringFieldUpdateOperationsInput | string
    Folio?: StringFieldUpdateOperationsInput | string
    Productor?: NullableStringFieldUpdateOperationsInput | string | null
    CSG?: NullableStringFieldUpdateOperationsInput | string | null
    Marca?: StringFieldUpdateOperationsInput | string
    Embalaje?: StringFieldUpdateOperationsInput | string
    Linea?: NullableStringFieldUpdateOperationsInput | string | null
    Exportadora?: NullableStringFieldUpdateOperationsInput | string | null
    Jornada?: NullableStringFieldUpdateOperationsInput | string | null
    Variedad?: NullableStringFieldUpdateOperationsInput | string | null
    Calibre?: StringFieldUpdateOperationsInput | string
    Categoria?: NullableStringFieldUpdateOperationsInput | string | null
    Cajas?: IntFieldUpdateOperationsInput | number
    Proceso?: IntFieldUpdateOperationsInput | number
  }

  export type existencias_cajasUncheckedUpdateManyInput = {
    Camara?: NullableStringFieldUpdateOperationsInput | string | null
    Especie?: NullableStringFieldUpdateOperationsInput | string | null
    Fecha_packing?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Hora_Packing?: NullableStringFieldUpdateOperationsInput | string | null
    Packing?: StringFieldUpdateOperationsInput | string
    Folio?: StringFieldUpdateOperationsInput | string
    Productor?: NullableStringFieldUpdateOperationsInput | string | null
    CSG?: NullableStringFieldUpdateOperationsInput | string | null
    Marca?: StringFieldUpdateOperationsInput | string
    Embalaje?: StringFieldUpdateOperationsInput | string
    Linea?: NullableStringFieldUpdateOperationsInput | string | null
    Exportadora?: NullableStringFieldUpdateOperationsInput | string | null
    Jornada?: NullableStringFieldUpdateOperationsInput | string | null
    Variedad?: NullableStringFieldUpdateOperationsInput | string | null
    Calibre?: StringFieldUpdateOperationsInput | string
    Categoria?: NullableStringFieldUpdateOperationsInput | string | null
    Cajas?: IntFieldUpdateOperationsInput | number
    Proceso?: IntFieldUpdateOperationsInput | number
  }

  export type existenciamix_cajasCreateInput = {
    Camara?: string | null
    Fecha_Packing?: string | null
    Hora_Packing?: string | null
    Packing: string
    Folio: string
    Productor?: string | null
    CSG?: string | null
    Cuartel?: string | null
    Variedad?: string | null
    Embalaje: string
    Etiqueta?: string | null
    Calibre: string
    Categoria?: string | null
    Cajas: number
    Proceso: number
  }

  export type existenciamix_cajasUncheckedCreateInput = {
    Camara?: string | null
    Fecha_Packing?: string | null
    Hora_Packing?: string | null
    Packing: string
    Folio: string
    Productor?: string | null
    CSG?: string | null
    Cuartel?: string | null
    Variedad?: string | null
    Embalaje: string
    Etiqueta?: string | null
    Calibre: string
    Categoria?: string | null
    Cajas: number
    Proceso: number
  }

  export type existenciamix_cajasUpdateInput = {
    Camara?: NullableStringFieldUpdateOperationsInput | string | null
    Fecha_Packing?: NullableStringFieldUpdateOperationsInput | string | null
    Hora_Packing?: NullableStringFieldUpdateOperationsInput | string | null
    Packing?: StringFieldUpdateOperationsInput | string
    Folio?: StringFieldUpdateOperationsInput | string
    Productor?: NullableStringFieldUpdateOperationsInput | string | null
    CSG?: NullableStringFieldUpdateOperationsInput | string | null
    Cuartel?: NullableStringFieldUpdateOperationsInput | string | null
    Variedad?: NullableStringFieldUpdateOperationsInput | string | null
    Embalaje?: StringFieldUpdateOperationsInput | string
    Etiqueta?: NullableStringFieldUpdateOperationsInput | string | null
    Calibre?: StringFieldUpdateOperationsInput | string
    Categoria?: NullableStringFieldUpdateOperationsInput | string | null
    Cajas?: IntFieldUpdateOperationsInput | number
    Proceso?: IntFieldUpdateOperationsInput | number
  }

  export type existenciamix_cajasUncheckedUpdateInput = {
    Camara?: NullableStringFieldUpdateOperationsInput | string | null
    Fecha_Packing?: NullableStringFieldUpdateOperationsInput | string | null
    Hora_Packing?: NullableStringFieldUpdateOperationsInput | string | null
    Packing?: StringFieldUpdateOperationsInput | string
    Folio?: StringFieldUpdateOperationsInput | string
    Productor?: NullableStringFieldUpdateOperationsInput | string | null
    CSG?: NullableStringFieldUpdateOperationsInput | string | null
    Cuartel?: NullableStringFieldUpdateOperationsInput | string | null
    Variedad?: NullableStringFieldUpdateOperationsInput | string | null
    Embalaje?: StringFieldUpdateOperationsInput | string
    Etiqueta?: NullableStringFieldUpdateOperationsInput | string | null
    Calibre?: StringFieldUpdateOperationsInput | string
    Categoria?: NullableStringFieldUpdateOperationsInput | string | null
    Cajas?: IntFieldUpdateOperationsInput | number
    Proceso?: IntFieldUpdateOperationsInput | number
  }

  export type existenciamix_cajasCreateManyInput = {
    Camara?: string | null
    Fecha_Packing?: string | null
    Hora_Packing?: string | null
    Packing: string
    Folio: string
    Productor?: string | null
    CSG?: string | null
    Cuartel?: string | null
    Variedad?: string | null
    Embalaje: string
    Etiqueta?: string | null
    Calibre: string
    Categoria?: string | null
    Cajas: number
    Proceso: number
  }

  export type existenciamix_cajasUpdateManyMutationInput = {
    Camara?: NullableStringFieldUpdateOperationsInput | string | null
    Fecha_Packing?: NullableStringFieldUpdateOperationsInput | string | null
    Hora_Packing?: NullableStringFieldUpdateOperationsInput | string | null
    Packing?: StringFieldUpdateOperationsInput | string
    Folio?: StringFieldUpdateOperationsInput | string
    Productor?: NullableStringFieldUpdateOperationsInput | string | null
    CSG?: NullableStringFieldUpdateOperationsInput | string | null
    Cuartel?: NullableStringFieldUpdateOperationsInput | string | null
    Variedad?: NullableStringFieldUpdateOperationsInput | string | null
    Embalaje?: StringFieldUpdateOperationsInput | string
    Etiqueta?: NullableStringFieldUpdateOperationsInput | string | null
    Calibre?: StringFieldUpdateOperationsInput | string
    Categoria?: NullableStringFieldUpdateOperationsInput | string | null
    Cajas?: IntFieldUpdateOperationsInput | number
    Proceso?: IntFieldUpdateOperationsInput | number
  }

  export type existenciamix_cajasUncheckedUpdateManyInput = {
    Camara?: NullableStringFieldUpdateOperationsInput | string | null
    Fecha_Packing?: NullableStringFieldUpdateOperationsInput | string | null
    Hora_Packing?: NullableStringFieldUpdateOperationsInput | string | null
    Packing?: StringFieldUpdateOperationsInput | string
    Folio?: StringFieldUpdateOperationsInput | string
    Productor?: NullableStringFieldUpdateOperationsInput | string | null
    CSG?: NullableStringFieldUpdateOperationsInput | string | null
    Cuartel?: NullableStringFieldUpdateOperationsInput | string | null
    Variedad?: NullableStringFieldUpdateOperationsInput | string | null
    Embalaje?: StringFieldUpdateOperationsInput | string
    Etiqueta?: NullableStringFieldUpdateOperationsInput | string | null
    Calibre?: StringFieldUpdateOperationsInput | string
    Categoria?: NullableStringFieldUpdateOperationsInput | string | null
    Cajas?: IntFieldUpdateOperationsInput | number
    Proceso?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type capacidad_lineasCountOrderByAggregateInput = {
    id?: SortOrder
    cod_linea?: SortOrder
    cod_esp?: SortOrder
    nro_vias?: SortOrder
    capacidad_vias?: SortOrder
  }

  export type capacidad_lineasAvgOrderByAggregateInput = {
    id?: SortOrder
    nro_vias?: SortOrder
    capacidad_vias?: SortOrder
  }

  export type capacidad_lineasMaxOrderByAggregateInput = {
    id?: SortOrder
    cod_linea?: SortOrder
    cod_esp?: SortOrder
    nro_vias?: SortOrder
    capacidad_vias?: SortOrder
  }

  export type capacidad_lineasMinOrderByAggregateInput = {
    id?: SortOrder
    cod_linea?: SortOrder
    cod_esp?: SortOrder
    nro_vias?: SortOrder
    capacidad_vias?: SortOrder
  }

  export type capacidad_lineasSumOrderByAggregateInput = {
    id?: SortOrder
    nro_vias?: SortOrder
    capacidad_vias?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type cc_checklistCountOrderByAggregateInput = {
    id?: SortOrder
    n_proceso?: SortOrder
    cod_esp?: SortOrder
    cod_var?: SortOrder
    cod_pro?: SortOrder
    cod_linea?: SortOrder
    fecha?: SortOrder
    cal_encerado?: SortOrder
    porc_exp?: SortOrder
    cal_cajas?: SortOrder
    porc_plu_c?: SortOrder
    peso_caj?: SortOrder
    cal_palet?: SortOrder
    saturacion?: SortOrder
    porc_exp_c?: SortOrder
    usuario?: SortOrder
    porc_plu?: SortOrder
    cod_emp?: SortOrder
    cod_tem?: SortOrder
    cod_envop?: SortOrder
    peso_c?: SortOrder
    fec_muestra?: SortOrder
  }

  export type cc_checklistAvgOrderByAggregateInput = {
    id?: SortOrder
    n_proceso?: SortOrder
    porc_exp?: SortOrder
    peso_caj?: SortOrder
    porc_plu?: SortOrder
  }

  export type cc_checklistMaxOrderByAggregateInput = {
    id?: SortOrder
    n_proceso?: SortOrder
    cod_esp?: SortOrder
    cod_var?: SortOrder
    cod_pro?: SortOrder
    cod_linea?: SortOrder
    fecha?: SortOrder
    cal_encerado?: SortOrder
    porc_exp?: SortOrder
    cal_cajas?: SortOrder
    porc_plu_c?: SortOrder
    peso_caj?: SortOrder
    cal_palet?: SortOrder
    saturacion?: SortOrder
    porc_exp_c?: SortOrder
    usuario?: SortOrder
    porc_plu?: SortOrder
    cod_emp?: SortOrder
    cod_tem?: SortOrder
    cod_envop?: SortOrder
    peso_c?: SortOrder
    fec_muestra?: SortOrder
  }

  export type cc_checklistMinOrderByAggregateInput = {
    id?: SortOrder
    n_proceso?: SortOrder
    cod_esp?: SortOrder
    cod_var?: SortOrder
    cod_pro?: SortOrder
    cod_linea?: SortOrder
    fecha?: SortOrder
    cal_encerado?: SortOrder
    porc_exp?: SortOrder
    cal_cajas?: SortOrder
    porc_plu_c?: SortOrder
    peso_caj?: SortOrder
    cal_palet?: SortOrder
    saturacion?: SortOrder
    porc_exp_c?: SortOrder
    usuario?: SortOrder
    porc_plu?: SortOrder
    cod_emp?: SortOrder
    cod_tem?: SortOrder
    cod_envop?: SortOrder
    peso_c?: SortOrder
    fec_muestra?: SortOrder
  }

  export type cc_checklistSumOrderByAggregateInput = {
    id?: SortOrder
    n_proceso?: SortOrder
    porc_exp?: SortOrder
    peso_caj?: SortOrder
    porc_plu?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type certificacionCountOrderByAggregateInput = {
    id?: SortOrder
    exportadora?: SortOrder
    productor?: SortOrder
    ggn?: SortOrder
    fecha_emision?: SortOrder
    fecha_caducidad?: SortOrder
    vigencia?: SortOrder
    especie?: SortOrder
    mercados?: SortOrder
  }

  export type certificacionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type certificacionMaxOrderByAggregateInput = {
    id?: SortOrder
    exportadora?: SortOrder
    productor?: SortOrder
    ggn?: SortOrder
    fecha_emision?: SortOrder
    fecha_caducidad?: SortOrder
    vigencia?: SortOrder
    especie?: SortOrder
    mercados?: SortOrder
  }

  export type certificacionMinOrderByAggregateInput = {
    id?: SortOrder
    exportadora?: SortOrder
    productor?: SortOrder
    ggn?: SortOrder
    fecha_emision?: SortOrder
    fecha_caducidad?: SortOrder
    vigencia?: SortOrder
    especie?: SortOrder
    mercados?: SortOrder
  }

  export type certificacionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type correlativoCountOrderByAggregateInput = {
    id_cor?: SortOrder
    id_tip_ins?: SortOrder
    nro_sag?: SortOrder
    cod_sdp?: SortOrder
  }

  export type correlativoAvgOrderByAggregateInput = {
    id_cor?: SortOrder
    id_tip_ins?: SortOrder
    nro_sag?: SortOrder
  }

  export type correlativoMaxOrderByAggregateInput = {
    id_cor?: SortOrder
    id_tip_ins?: SortOrder
    nro_sag?: SortOrder
    cod_sdp?: SortOrder
  }

  export type correlativoMinOrderByAggregateInput = {
    id_cor?: SortOrder
    id_tip_ins?: SortOrder
    nro_sag?: SortOrder
    cod_sdp?: SortOrder
  }

  export type correlativoSumOrderByAggregateInput = {
    id_cor?: SortOrder
    id_tip_ins?: SortOrder
    nro_sag?: SortOrder
  }

  export type env_x_sellarCountOrderByAggregateInput = {
    id?: SortOrder
    cod_envop?: SortOrder
    cod_esp?: SortOrder
    cod_exp?: SortOrder
  }

  export type env_x_sellarAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type env_x_sellarMaxOrderByAggregateInput = {
    id?: SortOrder
    cod_envop?: SortOrder
    cod_esp?: SortOrder
    cod_exp?: SortOrder
  }

  export type env_x_sellarMinOrderByAggregateInput = {
    id?: SortOrder
    cod_envop?: SortOrder
    cod_esp?: SortOrder
    cod_exp?: SortOrder
  }

  export type env_x_sellarSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type estadosCountOrderByAggregateInput = {
    id_est_ins?: SortOrder
    des_est_ins?: SortOrder
    tip_sdt?: SortOrder
    id_tip_ins?: SortOrder
  }

  export type estadosAvgOrderByAggregateInput = {
    id_est_ins?: SortOrder
    id_tip_ins?: SortOrder
  }

  export type estadosMaxOrderByAggregateInput = {
    id_est_ins?: SortOrder
    des_est_ins?: SortOrder
    tip_sdt?: SortOrder
    id_tip_ins?: SortOrder
  }

  export type estadosMinOrderByAggregateInput = {
    id_est_ins?: SortOrder
    des_est_ins?: SortOrder
    tip_sdt?: SortOrder
    id_tip_ins?: SortOrder
  }

  export type estadosSumOrderByAggregateInput = {
    id_est_ins?: SortOrder
    id_tip_ins?: SortOrder
  }

  export type foliosCountOrderByAggregateInput = {
    folio?: SortOrder
    nom_var?: SortOrder
    cod_var?: SortOrder
    cajas?: SortOrder
    fecha?: SortOrder
    calibre?: SortOrder
    embalaje?: SortOrder
  }

  export type foliosAvgOrderByAggregateInput = {
    cajas?: SortOrder
  }

  export type foliosMaxOrderByAggregateInput = {
    folio?: SortOrder
    nom_var?: SortOrder
    cod_var?: SortOrder
    cajas?: SortOrder
    fecha?: SortOrder
    calibre?: SortOrder
    embalaje?: SortOrder
  }

  export type foliosMinOrderByAggregateInput = {
    folio?: SortOrder
    nom_var?: SortOrder
    cod_var?: SortOrder
    cajas?: SortOrder
    fecha?: SortOrder
    calibre?: SortOrder
    embalaje?: SortOrder
  }

  export type foliosSumOrderByAggregateInput = {
    cajas?: SortOrder
  }

  export type folios_frioCountOrderByAggregateInput = {
    folio?: SortOrder
    nom_var?: SortOrder
    cod_var?: SortOrder
    cajas?: SortOrder
    fecha?: SortOrder
    calibre?: SortOrder
    embalaje?: SortOrder
  }

  export type folios_frioAvgOrderByAggregateInput = {
    cajas?: SortOrder
  }

  export type folios_frioMaxOrderByAggregateInput = {
    folio?: SortOrder
    nom_var?: SortOrder
    cod_var?: SortOrder
    cajas?: SortOrder
    fecha?: SortOrder
    calibre?: SortOrder
    embalaje?: SortOrder
  }

  export type folios_frioMinOrderByAggregateInput = {
    folio?: SortOrder
    nom_var?: SortOrder
    cod_var?: SortOrder
    cajas?: SortOrder
    fecha?: SortOrder
    calibre?: SortOrder
    embalaje?: SortOrder
  }

  export type folios_frioSumOrderByAggregateInput = {
    cajas?: SortOrder
  }

  export type folios_packCountOrderByAggregateInput = {
    folio?: SortOrder
    nom_var?: SortOrder
    cod_var?: SortOrder
    cajas?: SortOrder
    fecha?: SortOrder
    calibre?: SortOrder
    embalaje?: SortOrder
  }

  export type folios_packAvgOrderByAggregateInput = {
    cajas?: SortOrder
  }

  export type folios_packMaxOrderByAggregateInput = {
    folio?: SortOrder
    nom_var?: SortOrder
    cod_var?: SortOrder
    cajas?: SortOrder
    fecha?: SortOrder
    calibre?: SortOrder
    embalaje?: SortOrder
  }

  export type folios_packMinOrderByAggregateInput = {
    folio?: SortOrder
    nom_var?: SortOrder
    cod_var?: SortOrder
    cajas?: SortOrder
    fecha?: SortOrder
    calibre?: SortOrder
    embalaje?: SortOrder
  }

  export type folios_packSumOrderByAggregateInput = {
    cajas?: SortOrder
  }

  export type folios_seCountOrderByAggregateInput = {
    folio?: SortOrder
    nom_var?: SortOrder
    cod_var?: SortOrder
    cajas?: SortOrder
    fecha?: SortOrder
    calibre?: SortOrder
    embalaje?: SortOrder
  }

  export type folios_seAvgOrderByAggregateInput = {
    cajas?: SortOrder
  }

  export type folios_seMaxOrderByAggregateInput = {
    folio?: SortOrder
    nom_var?: SortOrder
    cod_var?: SortOrder
    cajas?: SortOrder
    fecha?: SortOrder
    calibre?: SortOrder
    embalaje?: SortOrder
  }

  export type folios_seMinOrderByAggregateInput = {
    folio?: SortOrder
    nom_var?: SortOrder
    cod_var?: SortOrder
    cajas?: SortOrder
    fecha?: SortOrder
    calibre?: SortOrder
    embalaje?: SortOrder
  }

  export type folios_seSumOrderByAggregateInput = {
    cajas?: SortOrder
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type fr_repa_cabCountOrderByAggregateInput = {
    id?: SortOrder
    fec_rep?: SortOrder
    id_tip_rep?: SortOrder
    fr_cod_pac?: SortOrder
    fr_cod_fri?: SortOrder
    fr_usu?: SortOrder
    fr_rep_sag?: SortOrder
    fr_cod_tem?: SortOrder
    fr_cod_emp?: SortOrder
    fr_tra_sdt?: SortOrder
    fr_nro_rep?: SortOrder
    fr_cod_esp?: SortOrder
  }

  export type fr_repa_cabAvgOrderByAggregateInput = {
    id?: SortOrder
    id_tip_rep?: SortOrder
    fr_nro_rep?: SortOrder
  }

  export type fr_repa_cabMaxOrderByAggregateInput = {
    id?: SortOrder
    fec_rep?: SortOrder
    id_tip_rep?: SortOrder
    fr_cod_pac?: SortOrder
    fr_cod_fri?: SortOrder
    fr_usu?: SortOrder
    fr_rep_sag?: SortOrder
    fr_cod_tem?: SortOrder
    fr_cod_emp?: SortOrder
    fr_tra_sdt?: SortOrder
    fr_nro_rep?: SortOrder
    fr_cod_esp?: SortOrder
  }

  export type fr_repa_cabMinOrderByAggregateInput = {
    id?: SortOrder
    fec_rep?: SortOrder
    id_tip_rep?: SortOrder
    fr_cod_pac?: SortOrder
    fr_cod_fri?: SortOrder
    fr_usu?: SortOrder
    fr_rep_sag?: SortOrder
    fr_cod_tem?: SortOrder
    fr_cod_emp?: SortOrder
    fr_tra_sdt?: SortOrder
    fr_nro_rep?: SortOrder
    fr_cod_esp?: SortOrder
  }

  export type fr_repa_cabSumOrderByAggregateInput = {
    id?: SortOrder
    id_tip_rep?: SortOrder
    fr_nro_rep?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type fr_repa_detCountOrderByAggregateInput = {
    id?: SortOrder
    id_rep_cab?: SortOrder
    fr_lote?: SortOrder
    fr_cor_sdt?: SortOrder
    fr_pla_sdt?: SortOrder
    fr_est_sdt?: SortOrder
    fr_fec_pac?: SortOrder
    fr_fec_rpa?: SortOrder
    fr_gui_sdt?: SortOrder
    fr_cod_pro?: SortOrder
    fr_cod_esp?: SortOrder
    fr_cod_var?: SortOrder
    fr_hor_rec?: SortOrder
    fr_con?: SortOrder
    fr_tip_lot?: SortOrder
    fr_alt_pal?: SortOrder
    fr_cod_env?: SortOrder
    fr_cod_eti?: SortOrder
    fr_cod_emb?: SortOrder
    fr_cod_envop?: SortOrder
    fr_plu?: SortOrder
    fr_caj?: SortOrder
    fr_cod_cat?: SortOrder
    fr_cod_cal?: SortOrder
    fr_nro_mix?: SortOrder
    fr_fec_sem?: SortOrder
    fr_cod_bp?: SortOrder
    fr_cod_pre?: SortOrder
    fr_cod_cua?: SortOrder
    fr_proceso?: SortOrder
    fr_con_fri?: SortOrder
    fr_fol_ori?: SortOrder
    fr_cod_var_eti?: SortOrder
    fr_cod_tip_tra?: SortOrder
    fr_cod_pro_eti?: SortOrder
    fr_cod_exp?: SortOrder
    fr_pk_ori?: SortOrder
    id_tip_io?: SortOrder
    fr_caj_usa?: SortOrder
    fr_tip_mov?: SortOrder
    fr_fec_sag?: SortOrder
    fr_guia_sag?: SortOrder
    fr_cer_sag?: SortOrder
    fr_sol_sag?: SortOrder
    fr_tip_sag?: SortOrder
    fr_cod_mer?: SortOrder
    fr_cod_mer1?: SortOrder
    fr_cod_mer2?: SortOrder
    fr_cod_mer3?: SortOrder
    fr_cod_mer4?: SortOrder
    fr_fec_fum?: SortOrder
    fr_guia_fum?: SortOrder
    fr_cer_fum?: SortOrder
    fr_cod_tipo_fum?: SortOrder
    fr_pfrio?: SortOrder
    fr_correlativo_rec?: SortOrder
    fr_cod_linea?: SortOrder
    fr_peso_original?: SortOrder
  }

  export type fr_repa_detAvgOrderByAggregateInput = {
    id?: SortOrder
    id_rep_cab?: SortOrder
    fr_cor_sdt?: SortOrder
    fr_pla_sdt?: SortOrder
    fr_gui_sdt?: SortOrder
    fr_caj?: SortOrder
    fr_nro_mix?: SortOrder
    fr_proceso?: SortOrder
    fr_pk_ori?: SortOrder
    id_tip_io?: SortOrder
    fr_caj_usa?: SortOrder
    fr_guia_sag?: SortOrder
    fr_guia_fum?: SortOrder
    fr_correlativo_rec?: SortOrder
    fr_peso_original?: SortOrder
  }

  export type fr_repa_detMaxOrderByAggregateInput = {
    id?: SortOrder
    id_rep_cab?: SortOrder
    fr_lote?: SortOrder
    fr_cor_sdt?: SortOrder
    fr_pla_sdt?: SortOrder
    fr_est_sdt?: SortOrder
    fr_fec_pac?: SortOrder
    fr_fec_rpa?: SortOrder
    fr_gui_sdt?: SortOrder
    fr_cod_pro?: SortOrder
    fr_cod_esp?: SortOrder
    fr_cod_var?: SortOrder
    fr_hor_rec?: SortOrder
    fr_con?: SortOrder
    fr_tip_lot?: SortOrder
    fr_alt_pal?: SortOrder
    fr_cod_env?: SortOrder
    fr_cod_eti?: SortOrder
    fr_cod_emb?: SortOrder
    fr_cod_envop?: SortOrder
    fr_plu?: SortOrder
    fr_caj?: SortOrder
    fr_cod_cat?: SortOrder
    fr_cod_cal?: SortOrder
    fr_nro_mix?: SortOrder
    fr_fec_sem?: SortOrder
    fr_cod_bp?: SortOrder
    fr_cod_pre?: SortOrder
    fr_cod_cua?: SortOrder
    fr_proceso?: SortOrder
    fr_con_fri?: SortOrder
    fr_fol_ori?: SortOrder
    fr_cod_var_eti?: SortOrder
    fr_cod_tip_tra?: SortOrder
    fr_cod_pro_eti?: SortOrder
    fr_cod_exp?: SortOrder
    fr_pk_ori?: SortOrder
    id_tip_io?: SortOrder
    fr_caj_usa?: SortOrder
    fr_tip_mov?: SortOrder
    fr_fec_sag?: SortOrder
    fr_guia_sag?: SortOrder
    fr_cer_sag?: SortOrder
    fr_sol_sag?: SortOrder
    fr_tip_sag?: SortOrder
    fr_cod_mer?: SortOrder
    fr_cod_mer1?: SortOrder
    fr_cod_mer2?: SortOrder
    fr_cod_mer3?: SortOrder
    fr_cod_mer4?: SortOrder
    fr_fec_fum?: SortOrder
    fr_guia_fum?: SortOrder
    fr_cer_fum?: SortOrder
    fr_cod_tipo_fum?: SortOrder
    fr_pfrio?: SortOrder
    fr_correlativo_rec?: SortOrder
    fr_cod_linea?: SortOrder
    fr_peso_original?: SortOrder
  }

  export type fr_repa_detMinOrderByAggregateInput = {
    id?: SortOrder
    id_rep_cab?: SortOrder
    fr_lote?: SortOrder
    fr_cor_sdt?: SortOrder
    fr_pla_sdt?: SortOrder
    fr_est_sdt?: SortOrder
    fr_fec_pac?: SortOrder
    fr_fec_rpa?: SortOrder
    fr_gui_sdt?: SortOrder
    fr_cod_pro?: SortOrder
    fr_cod_esp?: SortOrder
    fr_cod_var?: SortOrder
    fr_hor_rec?: SortOrder
    fr_con?: SortOrder
    fr_tip_lot?: SortOrder
    fr_alt_pal?: SortOrder
    fr_cod_env?: SortOrder
    fr_cod_eti?: SortOrder
    fr_cod_emb?: SortOrder
    fr_cod_envop?: SortOrder
    fr_plu?: SortOrder
    fr_caj?: SortOrder
    fr_cod_cat?: SortOrder
    fr_cod_cal?: SortOrder
    fr_nro_mix?: SortOrder
    fr_fec_sem?: SortOrder
    fr_cod_bp?: SortOrder
    fr_cod_pre?: SortOrder
    fr_cod_cua?: SortOrder
    fr_proceso?: SortOrder
    fr_con_fri?: SortOrder
    fr_fol_ori?: SortOrder
    fr_cod_var_eti?: SortOrder
    fr_cod_tip_tra?: SortOrder
    fr_cod_pro_eti?: SortOrder
    fr_cod_exp?: SortOrder
    fr_pk_ori?: SortOrder
    id_tip_io?: SortOrder
    fr_caj_usa?: SortOrder
    fr_tip_mov?: SortOrder
    fr_fec_sag?: SortOrder
    fr_guia_sag?: SortOrder
    fr_cer_sag?: SortOrder
    fr_sol_sag?: SortOrder
    fr_tip_sag?: SortOrder
    fr_cod_mer?: SortOrder
    fr_cod_mer1?: SortOrder
    fr_cod_mer2?: SortOrder
    fr_cod_mer3?: SortOrder
    fr_cod_mer4?: SortOrder
    fr_fec_fum?: SortOrder
    fr_guia_fum?: SortOrder
    fr_cer_fum?: SortOrder
    fr_cod_tipo_fum?: SortOrder
    fr_pfrio?: SortOrder
    fr_correlativo_rec?: SortOrder
    fr_cod_linea?: SortOrder
    fr_peso_original?: SortOrder
  }

  export type fr_repa_detSumOrderByAggregateInput = {
    id?: SortOrder
    id_rep_cab?: SortOrder
    fr_cor_sdt?: SortOrder
    fr_pla_sdt?: SortOrder
    fr_gui_sdt?: SortOrder
    fr_caj?: SortOrder
    fr_nro_mix?: SortOrder
    fr_proceso?: SortOrder
    fr_pk_ori?: SortOrder
    id_tip_io?: SortOrder
    fr_caj_usa?: SortOrder
    fr_guia_sag?: SortOrder
    fr_guia_fum?: SortOrder
    fr_correlativo_rec?: SortOrder
    fr_peso_original?: SortOrder
  }

  export type Gr_Tipo_CobroCountOrderByAggregateInput = {
    id?: SortOrder
    Descripcion?: SortOrder
    tipo_c?: SortOrder
  }

  export type Gr_Tipo_CobroAvgOrderByAggregateInput = {
    id?: SortOrder
    tipo_c?: SortOrder
  }

  export type Gr_Tipo_CobroMaxOrderByAggregateInput = {
    id?: SortOrder
    Descripcion?: SortOrder
    tipo_c?: SortOrder
  }

  export type Gr_Tipo_CobroMinOrderByAggregateInput = {
    id?: SortOrder
    Descripcion?: SortOrder
    tipo_c?: SortOrder
  }

  export type Gr_Tipo_CobroSumOrderByAggregateInput = {
    id?: SortOrder
    tipo_c?: SortOrder
  }

  export type insp_cabCountOrderByAggregateInput = {
    id_ins?: SortOrder
    nro_sag?: SortOrder
    cod_csp?: SortOrder
    id_tip_ins?: SortOrder
    fec_doc?: SortOrder
    fec_ins?: SortOrder
    id_usuario?: SortOrder
    cod_mer?: SortOrder
    cod_mer1?: SortOrder
    cod_mer2?: SortOrder
    cod_mer3?: SortOrder
    obs_insp?: SortOrder
    id_est_ins?: SortOrder
  }

  export type insp_cabAvgOrderByAggregateInput = {
    id_ins?: SortOrder
    nro_sag?: SortOrder
    id_tip_ins?: SortOrder
    id_est_ins?: SortOrder
  }

  export type insp_cabMaxOrderByAggregateInput = {
    id_ins?: SortOrder
    nro_sag?: SortOrder
    cod_csp?: SortOrder
    id_tip_ins?: SortOrder
    fec_doc?: SortOrder
    fec_ins?: SortOrder
    id_usuario?: SortOrder
    cod_mer?: SortOrder
    cod_mer1?: SortOrder
    cod_mer2?: SortOrder
    cod_mer3?: SortOrder
    obs_insp?: SortOrder
    id_est_ins?: SortOrder
  }

  export type insp_cabMinOrderByAggregateInput = {
    id_ins?: SortOrder
    nro_sag?: SortOrder
    cod_csp?: SortOrder
    id_tip_ins?: SortOrder
    fec_doc?: SortOrder
    fec_ins?: SortOrder
    id_usuario?: SortOrder
    cod_mer?: SortOrder
    cod_mer1?: SortOrder
    cod_mer2?: SortOrder
    cod_mer3?: SortOrder
    obs_insp?: SortOrder
    id_est_ins?: SortOrder
  }

  export type insp_cabSumOrderByAggregateInput = {
    id_ins?: SortOrder
    nro_sag?: SortOrder
    id_tip_ins?: SortOrder
    id_est_ins?: SortOrder
  }

  export type mae_sta_elenaCountOrderByAggregateInput = {
    cod_emb?: SortOrder
  }

  export type mae_sta_elenaMaxOrderByAggregateInput = {
    cod_emb?: SortOrder
  }

  export type mae_sta_elenaMinOrderByAggregateInput = {
    cod_emb?: SortOrder
  }

  export type maestro_pluCod_envopCod_calCompoundUniqueInput = {
    cod_envop: string
    cod_cal: string
  }

  export type maestro_pluCountOrderByAggregateInput = {
    cod_envop?: SortOrder
    cod_cal?: SortOrder
    cod_plu?: SortOrder
  }

  export type maestro_pluMaxOrderByAggregateInput = {
    cod_envop?: SortOrder
    cod_cal?: SortOrder
    cod_plu?: SortOrder
  }

  export type maestro_pluMinOrderByAggregateInput = {
    cod_envop?: SortOrder
    cod_cal?: SortOrder
    cod_plu?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type pk_desver_cabCountOrderByAggregateInput = {
    id?: SortOrder
    pro_nro?: SortOrder
    fec_ini?: SortOrder
    fec_fin?: SortOrder
    usu_res?: SortOrder
    pes_ini?: SortOrder
    pes_fin?: SortOrder
    cod_esp?: SortOrder
    fec_ven?: SortOrder
  }

  export type pk_desver_cabAvgOrderByAggregateInput = {
    id?: SortOrder
    pro_nro?: SortOrder
    pes_ini?: SortOrder
    pes_fin?: SortOrder
  }

  export type pk_desver_cabMaxOrderByAggregateInput = {
    id?: SortOrder
    pro_nro?: SortOrder
    fec_ini?: SortOrder
    fec_fin?: SortOrder
    usu_res?: SortOrder
    pes_ini?: SortOrder
    pes_fin?: SortOrder
    cod_esp?: SortOrder
    fec_ven?: SortOrder
  }

  export type pk_desver_cabMinOrderByAggregateInput = {
    id?: SortOrder
    pro_nro?: SortOrder
    fec_ini?: SortOrder
    fec_fin?: SortOrder
    usu_res?: SortOrder
    pes_ini?: SortOrder
    pes_fin?: SortOrder
    cod_esp?: SortOrder
    fec_ven?: SortOrder
  }

  export type pk_desver_cabSumOrderByAggregateInput = {
    id?: SortOrder
    pro_nro?: SortOrder
    pes_ini?: SortOrder
    pes_fin?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type pk_desver_detCountOrderByAggregateInput = {
    id?: SortOrder
    id_cab?: SortOrder
    folio?: SortOrder
    cod_var?: SortOrder
    cod_esp?: SortOrder
    peso_neto?: SortOrder
    peso_fin?: SortOrder
    cod_cal?: SortOrder
  }

  export type pk_desver_detAvgOrderByAggregateInput = {
    id?: SortOrder
    id_cab?: SortOrder
    peso_neto?: SortOrder
    peso_fin?: SortOrder
  }

  export type pk_desver_detMaxOrderByAggregateInput = {
    id?: SortOrder
    id_cab?: SortOrder
    folio?: SortOrder
    cod_var?: SortOrder
    cod_esp?: SortOrder
    peso_neto?: SortOrder
    peso_fin?: SortOrder
    cod_cal?: SortOrder
  }

  export type pk_desver_detMinOrderByAggregateInput = {
    id?: SortOrder
    id_cab?: SortOrder
    folio?: SortOrder
    cod_var?: SortOrder
    cod_esp?: SortOrder
    peso_neto?: SortOrder
    peso_fin?: SortOrder
    cod_cal?: SortOrder
  }

  export type pk_desver_detSumOrderByAggregateInput = {
    id?: SortOrder
    id_cab?: SortOrder
    peso_neto?: SortOrder
    peso_fin?: SortOrder
  }

  export type sys_logCountOrderByAggregateInput = {
    id?: SortOrder
    tip_eve?: SortOrder
    usu_sys?: SortOrder
    ip_pc?: SortOrder
    fecha_log?: SortOrder
    folio?: SortOrder
    modulo?: SortOrder
  }

  export type sys_logAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type sys_logMaxOrderByAggregateInput = {
    id?: SortOrder
    tip_eve?: SortOrder
    usu_sys?: SortOrder
    ip_pc?: SortOrder
    fecha_log?: SortOrder
    folio?: SortOrder
    modulo?: SortOrder
  }

  export type sys_logMinOrderByAggregateInput = {
    id?: SortOrder
    tip_eve?: SortOrder
    usu_sys?: SortOrder
    ip_pc?: SortOrder
    fecha_log?: SortOrder
    folio?: SortOrder
    modulo?: SortOrder
  }

  export type sys_logSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type sysdiagramsPrincipal_idNameCompoundUniqueInput = {
    principal_id: number
    name: string
  }

  export type sysdiagramsCountOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsAvgOrderByAggregateInput = {
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
  }

  export type sysdiagramsMaxOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsMinOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsSumOrderByAggregateInput = {
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
  }

  export type tipo_insCountOrderByAggregateInput = {
    id_tip_ins?: SortOrder
    des_tip_ins?: SortOrder
  }

  export type tipo_insAvgOrderByAggregateInput = {
    id_tip_ins?: SortOrder
  }

  export type tipo_insMaxOrderByAggregateInput = {
    id_tip_ins?: SortOrder
    des_tip_ins?: SortOrder
  }

  export type tipo_insMinOrderByAggregateInput = {
    id_tip_ins?: SortOrder
    des_tip_ins?: SortOrder
  }

  export type tipo_insSumOrderByAggregateInput = {
    id_tip_ins?: SortOrder
  }

  export type traductor_calibreCountOrderByAggregateInput = {
    id?: SortOrder
    n_calibre_std?: SortOrder
    val_calibre?: SortOrder
    cod_exp?: SortOrder
    n_calibre?: SortOrder
  }

  export type traductor_calibreAvgOrderByAggregateInput = {
    id?: SortOrder
    val_calibre?: SortOrder
  }

  export type traductor_calibreMaxOrderByAggregateInput = {
    id?: SortOrder
    n_calibre_std?: SortOrder
    val_calibre?: SortOrder
    cod_exp?: SortOrder
    n_calibre?: SortOrder
  }

  export type traductor_calibreMinOrderByAggregateInput = {
    id?: SortOrder
    n_calibre_std?: SortOrder
    val_calibre?: SortOrder
    cod_exp?: SortOrder
    n_calibre?: SortOrder
  }

  export type traductor_calibreSumOrderByAggregateInput = {
    id?: SortOrder
    val_calibre?: SortOrder
  }

  export type validacion_palletsCountOrderByAggregateInput = {
    id?: SortOrder
    numero_pallet?: SortOrder
    temporada?: SortOrder
  }

  export type validacion_palletsAvgOrderByAggregateInput = {
    id?: SortOrder
    temporada?: SortOrder
  }

  export type validacion_palletsMaxOrderByAggregateInput = {
    id?: SortOrder
    numero_pallet?: SortOrder
    temporada?: SortOrder
  }

  export type validacion_palletsMinOrderByAggregateInput = {
    id?: SortOrder
    numero_pallet?: SortOrder
    temporada?: SortOrder
  }

  export type validacion_palletsSumOrderByAggregateInput = {
    id?: SortOrder
    temporada?: SortOrder
  }

  export type existencias_cajasCountOrderByAggregateInput = {
    Camara?: SortOrder
    Especie?: SortOrder
    Fecha_packing?: SortOrder
    Hora_Packing?: SortOrder
    Packing?: SortOrder
    Folio?: SortOrder
    Productor?: SortOrder
    CSG?: SortOrder
    Marca?: SortOrder
    Embalaje?: SortOrder
    Linea?: SortOrder
    Exportadora?: SortOrder
    Jornada?: SortOrder
    Variedad?: SortOrder
    Calibre?: SortOrder
    Categoria?: SortOrder
    Cajas?: SortOrder
    Proceso?: SortOrder
  }

  export type existencias_cajasAvgOrderByAggregateInput = {
    Cajas?: SortOrder
    Proceso?: SortOrder
  }

  export type existencias_cajasMaxOrderByAggregateInput = {
    Camara?: SortOrder
    Especie?: SortOrder
    Fecha_packing?: SortOrder
    Hora_Packing?: SortOrder
    Packing?: SortOrder
    Folio?: SortOrder
    Productor?: SortOrder
    CSG?: SortOrder
    Marca?: SortOrder
    Embalaje?: SortOrder
    Linea?: SortOrder
    Exportadora?: SortOrder
    Jornada?: SortOrder
    Variedad?: SortOrder
    Calibre?: SortOrder
    Categoria?: SortOrder
    Cajas?: SortOrder
    Proceso?: SortOrder
  }

  export type existencias_cajasMinOrderByAggregateInput = {
    Camara?: SortOrder
    Especie?: SortOrder
    Fecha_packing?: SortOrder
    Hora_Packing?: SortOrder
    Packing?: SortOrder
    Folio?: SortOrder
    Productor?: SortOrder
    CSG?: SortOrder
    Marca?: SortOrder
    Embalaje?: SortOrder
    Linea?: SortOrder
    Exportadora?: SortOrder
    Jornada?: SortOrder
    Variedad?: SortOrder
    Calibre?: SortOrder
    Categoria?: SortOrder
    Cajas?: SortOrder
    Proceso?: SortOrder
  }

  export type existencias_cajasSumOrderByAggregateInput = {
    Cajas?: SortOrder
    Proceso?: SortOrder
  }

  export type existenciamix_cajasCountOrderByAggregateInput = {
    Camara?: SortOrder
    Fecha_Packing?: SortOrder
    Hora_Packing?: SortOrder
    Packing?: SortOrder
    Folio?: SortOrder
    Productor?: SortOrder
    CSG?: SortOrder
    Cuartel?: SortOrder
    Variedad?: SortOrder
    Embalaje?: SortOrder
    Etiqueta?: SortOrder
    Calibre?: SortOrder
    Categoria?: SortOrder
    Cajas?: SortOrder
    Proceso?: SortOrder
  }

  export type existenciamix_cajasAvgOrderByAggregateInput = {
    Cajas?: SortOrder
    Proceso?: SortOrder
  }

  export type existenciamix_cajasMaxOrderByAggregateInput = {
    Camara?: SortOrder
    Fecha_Packing?: SortOrder
    Hora_Packing?: SortOrder
    Packing?: SortOrder
    Folio?: SortOrder
    Productor?: SortOrder
    CSG?: SortOrder
    Cuartel?: SortOrder
    Variedad?: SortOrder
    Embalaje?: SortOrder
    Etiqueta?: SortOrder
    Calibre?: SortOrder
    Categoria?: SortOrder
    Cajas?: SortOrder
    Proceso?: SortOrder
  }

  export type existenciamix_cajasMinOrderByAggregateInput = {
    Camara?: SortOrder
    Fecha_Packing?: SortOrder
    Hora_Packing?: SortOrder
    Packing?: SortOrder
    Folio?: SortOrder
    Productor?: SortOrder
    CSG?: SortOrder
    Cuartel?: SortOrder
    Variedad?: SortOrder
    Embalaje?: SortOrder
    Etiqueta?: SortOrder
    Calibre?: SortOrder
    Categoria?: SortOrder
    Cajas?: SortOrder
    Proceso?: SortOrder
  }

  export type existenciamix_cajasSumOrderByAggregateInput = {
    Cajas?: SortOrder
    Proceso?: SortOrder
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use capacidad_lineasDefaultArgs instead
     */
    export type capacidad_lineasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = capacidad_lineasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use cc_checklistDefaultArgs instead
     */
    export type cc_checklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = cc_checklistDefaultArgs<ExtArgs>
    /**
     * @deprecated Use certificacionDefaultArgs instead
     */
    export type certificacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = certificacionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use correlativoDefaultArgs instead
     */
    export type correlativoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = correlativoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use env_x_sellarDefaultArgs instead
     */
    export type env_x_sellarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = env_x_sellarDefaultArgs<ExtArgs>
    /**
     * @deprecated Use estadosDefaultArgs instead
     */
    export type estadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = estadosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use foliosDefaultArgs instead
     */
    export type foliosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = foliosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use folios_frioDefaultArgs instead
     */
    export type folios_frioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = folios_frioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use folios_packDefaultArgs instead
     */
    export type folios_packArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = folios_packDefaultArgs<ExtArgs>
    /**
     * @deprecated Use folios_seDefaultArgs instead
     */
    export type folios_seArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = folios_seDefaultArgs<ExtArgs>
    /**
     * @deprecated Use fr_repa_cabDefaultArgs instead
     */
    export type fr_repa_cabArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = fr_repa_cabDefaultArgs<ExtArgs>
    /**
     * @deprecated Use fr_repa_detDefaultArgs instead
     */
    export type fr_repa_detArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = fr_repa_detDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Gr_Tipo_CobroDefaultArgs instead
     */
    export type Gr_Tipo_CobroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Gr_Tipo_CobroDefaultArgs<ExtArgs>
    /**
     * @deprecated Use insp_cabDefaultArgs instead
     */
    export type insp_cabArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = insp_cabDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mae_sta_elenaDefaultArgs instead
     */
    export type mae_sta_elenaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = mae_sta_elenaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use maestro_pluDefaultArgs instead
     */
    export type maestro_pluArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = maestro_pluDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pk_desver_cabDefaultArgs instead
     */
    export type pk_desver_cabArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pk_desver_cabDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pk_desver_detDefaultArgs instead
     */
    export type pk_desver_detArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pk_desver_detDefaultArgs<ExtArgs>
    /**
     * @deprecated Use sys_logDefaultArgs instead
     */
    export type sys_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = sys_logDefaultArgs<ExtArgs>
    /**
     * @deprecated Use sysdiagramsDefaultArgs instead
     */
    export type sysdiagramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = sysdiagramsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tipo_insDefaultArgs instead
     */
    export type tipo_insArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tipo_insDefaultArgs<ExtArgs>
    /**
     * @deprecated Use traductor_calibreDefaultArgs instead
     */
    export type traductor_calibreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = traductor_calibreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use validacion_palletsDefaultArgs instead
     */
    export type validacion_palletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = validacion_palletsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use existencias_cajasDefaultArgs instead
     */
    export type existencias_cajasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = existencias_cajasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use existenciamix_cajasDefaultArgs instead
     */
    export type existenciamix_cajasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = existenciamix_cajasDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}